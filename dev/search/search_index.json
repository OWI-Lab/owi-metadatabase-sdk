{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OWI-metadatabase SDK","text":"<p>Core Python SDK for the OWI-Lab metadatabase: geometry and location data</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p>The OWI-metadatabase SDK provides a Python interface to interact with the OWI-Lab metadatabase for offshore wind installations. This core package includes modules for:</p> <ul> <li>Geometry: Processing and analysis of offshore wind turbine geometry data</li> <li>Locations: Handling location and site data for offshore wind farms</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install owi-metadatabase\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from owi.metadatabase.geometry.io import GeometryAPI\nfrom owi.metadatabase.locations.io import LocationsAPI\n\n# Initialize APIs\ngeometry_api = GeometryAPI(token=\"your-token\")\nlocations_api = LocationsAPI(token=\"your-token\")\n\n# Get geometry data\nturbines = geometry_api.get_turbines(projectsite=\"YourProject\")\n\n# Get location data\nlocations = locations_api.get_locations(projectsite=\"YourProject\")\n</code></pre>"},{"location":"#namespace-package-structure","title":"Namespace Package Structure","text":"<p>This package follows PEP 420 namespace conventions, allowing for modular extensions:</p> <pre><code># Core package\nfrom owi.metadatabase.geometry import GeometryAPI\nfrom owi.metadatabase.locations import LocationsAPI\n\n# Future extensions (when available)\n# from owi.metadatabase.fatigue import FatigueAPI\n# from owi.metadatabase.soil import SoilAPI\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Installation and quickstart guide</li> <li>User Guide - Detailed usage documentation</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.9+</li> <li>numpy</li> <li>pandas</li> <li>requests</li> <li>plotly</li> <li>matplotlib</li> <li>tqdm</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the GNU General Public License v3.0 - see the LICENSE file for details.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use this package in your research, please cite:</p> <pre><code>@software{owi_metadatabase_sdk,\n  author = {OWI-Lab},\n  title = {OWI-metadatabase SDK},\n  year = {2026},\n  url = {https://github.com/OWI-Lab/owi-metadatabase-sdk},\n  doi = {10.5281/zenodo.10620568}\n}\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This package was developed as part of the ETF Smartlife (FOD165) and WILLOW (EUAR157) projects.</p>"},{"location":"#support","title":"Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Email: OWI-Lab Contact</li> </ul>"},{"location":"about/authors/","title":"Authors","text":"<p>Primary authors and maintainers:</p> <ul> <li>Arsen Melnikov</li> <li>Pietro D'Antuono</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":"<p>This page summarizes notable changes by release.</p> <p>For now, refer to the repository releases and commit history.</p>"},{"location":"about/license/","title":"License","text":"<p>This project is licensed under the GNU General Public License v3.0.</p> <p>See the LICENSE file in the repository for the full text.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for owi-metadatabase.</p>"},{"location":"api/#modules","title":"Modules","text":"<p>The owi-metadatabase package provides the following modules:</p>"},{"location":"api/#geometry","title":"Geometry","text":"<p>Tools for working with offshore wind turbine geometry data.</p> <ul> <li><code>GeometryAPI</code> - API client for geometry data</li> <li><code>OWT</code> - Single turbine geometry processor</li> <li><code>OWTs</code> - Multiple turbine geometry processor</li> </ul>"},{"location":"api/#locations","title":"Locations","text":"<p>Tools for working with offshore wind site location data.</p> <ul> <li><code>LocationsAPI</code> - API client for location/site data</li> </ul>"},{"location":"api/#io","title":"I/O","text":"<p>Low-level I/O utilities for API communication.</p> <ul> <li><code>RequestData</code> - Base class for API requests</li> </ul>"},{"location":"api/#utilities","title":"Utilities","text":"<p>Internal utilities and exceptions.</p> <ul> <li>Exception classes</li> <li>Helper functions</li> </ul>"},{"location":"api/#auto-generated-documentation","title":"Auto-Generated Documentation","text":"<p>This section provides automatically generated API documentation extracted from docstrings using mkdocstrings.</p>"},{"location":"api/#quick-links","title":"Quick Links","text":"Module Description Key Classes geometry.io Geometry API client <code>GeometryAPI</code> geometry.processing Geometry data processing <code>OWT</code>, <code>OWTs</code> geometry.structures Geometry data structures Various dataclasses locations.io Locations API client <code>LocationsAPI</code> io Base I/O utilities <code>RequestData</code> _utils Internal utilities Exception classes"},{"location":"api/#usage-examples","title":"Usage Examples","text":""},{"location":"api/#geometry-api","title":"Geometry API","text":"<pre><code>from owi.metadatabase.geometry.io import GeometryAPI\n\napi = GeometryAPI(api_root=\"https://api.example.com\")\nturbine_data = api.get_turbine_data(turbine_id=\"OWT001\")\n</code></pre>"},{"location":"api/#locations-api","title":"Locations API","text":"<pre><code>from owi.metadatabase.locations.io import LocationsAPI\n\napi = LocationsAPI(api_root=\"https://api.example.com\")\nlocation_data = api.get_location_data(project_id=\"PRJ001\")\n</code></pre>"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>All public APIs include complete type hints for improved IDE support and static analysis:</p> <pre><code>from owi.metadatabase.geometry.processing import OWT\nfrom pandas import DataFrame\n\ndef process_turbine(data: DataFrame) -&gt; OWT:\n    \"\"\"Process turbine geometry data.\"\"\"\n    return OWT(data)\n</code></pre>"},{"location":"api/#documentation-style","title":"Documentation Style","text":"<p>All docstrings follow the NumPy documentation style:</p> <pre><code>def function(arg1: int, arg2: str) -&gt; bool:\n    \"\"\"\n    Short description.\n\n    Longer description with more details about what the\n    function does and how to use it.\n\n    Parameters\n    ----------\n    arg1 : int\n        Description of arg1.\n    arg2 : str\n        Description of arg2.\n\n    Returns\n    -------\n    bool\n        Description of return value.\n\n    Examples\n    --------\n    &gt;&gt;&gt; function(42, \"test\")\n    True\n    \"\"\"\n    return True\n</code></pre>"},{"location":"api/geometry/","title":"Geometry Module","text":"<p>API reference for the geometry module.</p>"},{"location":"api/geometry/#owi.metadatabase.geometry","title":"geometry","text":"<p>Module for handling geometry data from OWI metadatabase.</p>"},{"location":"api/geometry/#owi.metadatabase.geometry-classes","title":"Classes","text":""},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI","title":"GeometryAPI","text":"<pre><code>GeometryAPI(api_subdir='/geometry/userroutes/', **kwargs)\n</code></pre> <p>               Bases: <code>API</code></p> <p>Class to connect to the geometry data API with methods to retrieve data.</p> <p>Create an instance of the GeometryAPI class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>api_subdir</code> <code>str</code> <p>Subdirectory of the API endpoint url for specific type of data.</p> <code>'/geometry/userroutes/'</code> <code>**kwargs</code> <p>Additional parameters to pass to the API (see the base class).</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; api.api_root.endswith(\"/geometry/userroutes/\")\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def __init__(\n    self,\n    api_subdir: str = \"/geometry/userroutes/\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Create an instance of the GeometryAPI class with required\n    parameters.\n\n    Parameters\n    ----------\n    api_subdir : str, optional\n        Subdirectory of the API endpoint url for specific type of\n        data.\n    **kwargs\n        Additional parameters to pass to the API (see the base\n        class).\n\n    Examples\n    --------\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; api.api_root.endswith(\"/geometry/userroutes/\")\n    True\n    \"\"\"\n    super().__init__(**kwargs)\n    self.loc_api = LocationsAPI(**kwargs)\n    self.api_root = self.api_root + api_subdir\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI-functions","title":"Functions","text":""},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compare two instances of the API class.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Another instance of the API class or a dictionary.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instances are equal, False otherwise.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If comparison is not possible due to incompatible types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api_1 = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; api_2 = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; api_1 == api_2\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Compare two instances of the API class.\n\n    Parameters\n    ----------\n    other : object\n        Another instance of the API class or a dictionary.\n\n    Returns\n    -------\n    bool\n        True if the instances are equal, False otherwise.\n\n    Raises\n    ------\n    AssertionError\n        If comparison is not possible due to incompatible types.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api_1 = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; api_2 = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; api_1 == api_2\n    True\n    \"\"\"\n    if not isinstance(other, (API, dict)):\n        return NotImplemented\n    if isinstance(other, type(self)):\n        comp = deepcompare(self, other)\n        assert comp[0], comp[1]\n    elif isinstance(other, dict):\n        comp = deepcompare(self.__dict__, other)\n        assert comp[0], comp[1]\n    else:\n        raise AssertionError(\"Comparison is not possible due to incompatible types!\")\n    return comp[0]\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.send_request","title":"send_request","text":"<pre><code>send_request(url_data_type, url_params)\n</code></pre> <p>Handle sending appropriate request.</p> <p>Handles sending appropriate request according to the type of authentication.</p> <p>Parameters:</p> Name Type Description Default <code>url_data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <code>url_params</code> <code>Mapping</code> <p>Parameters to send with the request to the database.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>An instance of the Response object.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If neither header nor username and password are defined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; response = SimpleNamespace(status_code=200, reason=\"OK\")\n&gt;&gt;&gt; with mock.patch(\"requests.get\", return_value=response):\n...     api = API(api_root=\"https://example\", token=\"test\")\n...     resp = api.send_request(\"/projects\", {})\n&gt;&gt;&gt; resp is response\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def send_request(\n    self,\n    url_data_type: str,\n    url_params: Mapping[str, Union[str, float, int, Sequence[Union[str, float, int]], None]],\n) -&gt; requests.Response:\n    \"\"\"\n    Handle sending appropriate request.\n\n    Handles sending appropriate request according to the type of\n    authentication.\n\n    Parameters\n    ----------\n    url_data_type : str\n        Type of the data we want to request (according to database\n        model).\n    url_params : Mapping\n        Parameters to send with the request to the database.\n\n    Returns\n    -------\n    requests.Response\n        An instance of the Response object.\n\n    Raises\n    ------\n    InvalidParameterError\n        If neither header nor username and password are defined.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; response = SimpleNamespace(status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; with mock.patch(\"requests.get\", return_value=response):\n    ...     api = API(api_root=\"https://example\", token=\"test\")\n    ...     resp = api.send_request(\"/projects\", {})\n    &gt;&gt;&gt; resp is response\n    True\n    \"\"\"\n    if self.header is not None:\n        response = requests.get(\n            url=self.api_root + url_data_type,\n            headers=self.header,\n            params=url_params,\n        )\n    else:\n        if self.uname is None or self.password is None:\n            e = \"Either self.header or self.uname and self.password must be defined.\"\n            raise InvalidParameterError(e)\n        else:\n            response = requests.get(\n                url=self.api_root + url_data_type,\n                auth=self.auth,\n                params=url_params,\n            )\n    return response\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.check_request_health","title":"check_request_health  <code>staticmethod</code>","text":"<pre><code>check_request_health(resp)\n</code></pre> <p>Check status code of the response and provide details.</p> <p>Checks status code of the response to request and provides details if unexpected.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>Instance of the Response object.</p> required <p>Raises:</p> Type Description <code>APIConnectionError</code> <p>If response status code is not 200.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; ok = SimpleNamespace(status_code=200, reason=\"OK\")\n&gt;&gt;&gt; API.check_request_health(ok)\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef check_request_health(resp: requests.Response) -&gt; None:\n    \"\"\"\n    Check status code of the response and provide details.\n\n    Checks status code of the response to request and provides\n    details if unexpected.\n\n    Parameters\n    ----------\n    resp : requests.Response\n        Instance of the Response object.\n\n    Raises\n    ------\n    APIConnectionError\n        If response status code is not 200.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; ok = SimpleNamespace(status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; API.check_request_health(ok)\n    \"\"\"\n    if resp.status_code != 200:\n        raise APIConnectionError(\n            message=f\"Error {resp.status_code}.\\n{resp.reason}\",\n            response=resp,\n        )\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.output_to_df","title":"output_to_df  <code>staticmethod</code>","text":"<pre><code>output_to_df(response)\n</code></pre> <p>Transform output to Pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Raw output of the sent request.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas dataframe of the data from the output.</p> <p>Raises:</p> Type Description <code>DataProcessingError</code> <p>If failed to decode JSON from API response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; resp = SimpleNamespace(text='[{\"a\": 1}]')\n&gt;&gt;&gt; int(API.output_to_df(resp)[\"a\"].iloc[0])\n1\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef output_to_df(response: requests.Response) -&gt; pd.DataFrame:\n    \"\"\"\n    Transform output to Pandas dataframe.\n\n    Parameters\n    ----------\n    response : requests.Response\n        Raw output of the sent request.\n\n    Returns\n    -------\n    pd.DataFrame\n        Pandas dataframe of the data from the output.\n\n    Raises\n    ------\n    DataProcessingError\n        If failed to decode JSON from API response.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; resp = SimpleNamespace(text='[{\"a\": 1}]')\n    &gt;&gt;&gt; int(API.output_to_df(resp)[\"a\"].iloc[0])\n    1\n    \"\"\"\n    try:\n        data = json.loads(response.text)\n    except Exception as err:\n        raise DataProcessingError(\"Failed to decode JSON from API response\") from err\n    return pd.DataFrame(data)\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.postprocess_data","title":"postprocess_data  <code>staticmethod</code>","text":"<pre><code>postprocess_data(df, output_type)\n</code></pre> <p>Process dataframe information to extract additional data.</p> <p>Processes dataframe information to extract the necessary additional data.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe of the output data.</p> required <code>output_type</code> <code>str</code> <p>Expected type (amount) of the data extracted.</p> required <p>Returns:</p> Type Description <code>PostprocessData</code> <p>Dictionary of the additional data extracted.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If more than one record was returned for 'single' output type, or if output type is not 'single' or 'list'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n&gt;&gt;&gt; int(API.postprocess_data(df, \"single\")[\"id\"])\n1\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef postprocess_data(df: pd.DataFrame, output_type: str) -&gt; PostprocessData:\n    \"\"\"\n    Process dataframe information to extract additional data.\n\n    Processes dataframe information to extract the necessary\n    additional data.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe of the output data.\n    output_type : str\n        Expected type (amount) of the data extracted.\n\n    Returns\n    -------\n    PostprocessData\n        Dictionary of the additional data extracted.\n\n    Raises\n    ------\n    InvalidParameterError\n        If more than one record was returned for 'single' output\n        type, or if output type is not 'single' or 'list'.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; int(API.postprocess_data(df, \"single\")[\"id\"])\n    1\n    \"\"\"\n    if output_type == \"single\":\n        if df.__len__() == 0:\n            exists = False\n            project_id = None\n        elif df.__len__() == 1:\n            exists = True\n            project_id = df[\"id\"].iloc[0]\n        else:\n            raise InvalidParameterError(\"More than one project site was returned, check search criteria.\")\n        data_add: PostprocessData = {\n            \"existance\": exists,\n            \"id\": project_id,\n            \"response\": None,\n        }\n    elif output_type == \"list\":\n        exists = df.__len__() != 0\n        data_add: PostprocessData = {\n            \"existance\": exists,\n            \"id\": None,\n            \"response\": None,\n        }\n    else:\n        raise InvalidParameterError(\"Output type must be either 'single' or 'list', not \" + output_type + \".\")\n    return data_add\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.validate_data","title":"validate_data  <code>staticmethod</code>","text":"<pre><code>validate_data(df, data_type)\n</code></pre> <p>Validate the data extracted from the database.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe of the output data.</p> required <code>data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with corrected data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame()\n&gt;&gt;&gt; API.validate_data(df, \"subassemblies\").empty\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef validate_data(df: pd.DataFrame, data_type: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Validate the data extracted from the database.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe of the output data.\n    data_type : str\n        Type of the data we want to request (according to database\n        model).\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with corrected data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame()\n    &gt;&gt;&gt; API.validate_data(df, \"subassemblies\").empty\n    True\n    \"\"\"\n    z_sa_mp = {\"min\": -100000, \"max\": -10000}\n    z_sa_tp = {\"min\": -20000, \"max\": -1000}\n    z_sa_tw = {\"min\": 1000, \"max\": 100000}\n    sa_type = [\"TW\", \"TP\", \"MP\"]\n    z = [z_sa_tw, z_sa_tp, z_sa_mp]\n    if data_type == \"subassemblies\":\n        if df.__len__() == 0:\n            return df\n        for i, sat in enumerate(sa_type):\n            cond_small_units = (df[\"subassembly_type\"] == sat) &amp; (df[\"z_position\"] &lt; z[i][\"min\"])\n            cond_big_units = (df[\"subassembly_type\"] == sat) &amp; (df[\"z_position\"] &gt; z[i][\"max\"])\n            if df[cond_small_units].__len__() &gt; 0:\n                df.loc[cond_small_units, \"z_position\"] = df.loc[cond_small_units, \"z_position\"] / 1e3\n                warnings.warn(\n                    f\"The value of z location for {df.loc[cond_small_units | cond_big_units, 'title'].values} \\\n                    might be wrong or in wrong units! There will be an attempt to correct the units.\",\n                    stacklevel=2,\n                )\n            if df[cond_big_units].__len__() &gt; 0:\n                df.loc[cond_big_units, \"z_position\"] = df.loc[cond_big_units, \"z_position\"] * 1e3\n                warnings.warn(\n                    f\"The value of z location for {df.loc[cond_small_units | cond_big_units, 'title'].values} \\\n                    might be wrong or in wrong units! There will be an attempt to correct the units.\",\n                    stacklevel=2,\n                )\n    return df\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.process_data","title":"process_data","text":"<pre><code>process_data(url_data_type, url_params, output_type)\n</code></pre> <p>Process output data according to specified request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>url_data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <code>url_params</code> <code>Mapping</code> <p>Parameters to send with the request to the database.</p> required <code>output_type</code> <code>str</code> <p>Expected type (amount) of the data extracted.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of dataframe with the requested data and additional data from postprocessing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; response = SimpleNamespace(text=\"[]\", status_code=200, reason=\"OK\")\n&gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; with mock.patch.object(API, \"send_request\", return_value=response):\n...     df, info = api.process_data(\"projects\", {}, \"list\")\n&gt;&gt;&gt; df.empty\nTrue\n&gt;&gt;&gt; info[\"existance\"]\nFalse\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def process_data(\n    self,\n    url_data_type: str,\n    url_params: Mapping[str, Union[str, float, int, Sequence[Union[str, float, int]], None]],\n    output_type: str,\n) -&gt; tuple[pd.DataFrame, PostprocessData]:\n    \"\"\"\n    Process output data according to specified request parameters.\n\n    Parameters\n    ----------\n    url_data_type : str\n        Type of the data we want to request (according to database\n        model).\n    url_params : Mapping\n        Parameters to send with the request to the database.\n    output_type : str\n        Expected type (amount) of the data extracted.\n\n    Returns\n    -------\n    tuple\n        A tuple of dataframe with the requested data and\n        additional data from postprocessing.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; response = SimpleNamespace(text=\"[]\", status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; with mock.patch.object(API, \"send_request\", return_value=response):\n    ...     df, info = api.process_data(\"projects\", {}, \"list\")\n    &gt;&gt;&gt; df.empty\n    True\n    &gt;&gt;&gt; info[\"existance\"]\n    False\n    \"\"\"\n    resp = self.send_request(url_data_type, url_params)\n    self.check_request_health(resp)\n    df = self.output_to_df(resp)\n    df = self.validate_data(df, url_data_type)\n    df_add = self.postprocess_data(df, output_type)\n    # Add the response object to the returned dictionary so tests can inspect it\n    df_add[\"response\"] = resp\n    return df, df_add\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.get_model_definitions","title":"get_model_definitions","text":"<pre><code>get_model_definitions(projectsite=None)\n</code></pre> <p>Get all relevant model definitions.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>Title of the projectsite.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the model definitions</li> <li>\"exists\": Boolean indicating whether matching records   are found</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_model_definitions(projectsite=\"Site\")\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_model_definitions(\n    self,\n    projectsite: Union[str, None] = None,\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get all relevant model definitions.\n\n    Parameters\n    ----------\n    projectsite : str, optional\n        Title of the projectsite.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the model definitions\n        - \"exists\": Boolean indicating whether matching records\n          are found\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = GeometryAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     GeometryAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True}),\n            ... ):\n            ...     out = api.get_model_definitions(projectsite=\"Site\")\n            &gt;&gt;&gt; out[\"exists\"]\n            True\n    \"\"\"\n    url_params = {}\n    if projectsite is not None:\n        url_params[\"site\"] = projectsite\n    url_data_type = \"modeldefinitions\"\n    output_type = \"list\"\n    with self._temp_api_root(self.api_root.replace(\"userroutes\", \"routes\")):\n        df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.get_modeldefinition_id","title":"get_modeldefinition_id","text":"<pre><code>get_modeldefinition_id(\n    assetlocation=None,\n    projectsite=None,\n    model_definition=None,\n)\n</code></pre> <p>Get the ID of a model definition.</p> <p>Either the asset location or the project site must be specified.</p> <p>Parameters:</p> Name Type Description Default <code>assetlocation</code> <code>str</code> <p>Title of the asset location.</p> <code>None</code> <code>projectsite</code> <code>str</code> <p>Title of the projectsite.</p> <code>None</code> <code>model_definition</code> <code>str</code> <p>Title of the model definition.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"id\": ID of the specified model definition</li> <li>\"multiple_modeldef\": Boolean indicating whether there   are multiple model definitions for the asset location   in general</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If at least one of assetlocation or projectsite is not specified, if no location found, if no model definitions found, if multiple model definitions found without specification, or if specified model definition not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; api.get_modeldefinition_id()\nTraceback (most recent call last):\n    ...\nValueError: At least either of the related ... must be specified!\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_modeldefinition_id(\n    self,\n    assetlocation: Union[str, None] = None,\n    projectsite: Union[str, None] = None,\n    model_definition: Union[str, None] = None,\n) -&gt; dict[str, Union[int, np.int64, bool, None]]:\n    \"\"\"\n    Get the ID of a model definition.\n\n    Either the asset location or the project site must be specified.\n\n    Parameters\n    ----------\n    assetlocation : str, optional\n        Title of the asset location.\n    projectsite : str, optional\n        Title of the projectsite.\n    model_definition : str, optional\n        Title of the model definition.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"id\": ID of the specified model definition\n        - \"multiple_modeldef\": Boolean indicating whether there\n          are multiple model definitions for the asset location\n          in general\n\n    Raises\n    ------\n    ValueError\n        If at least one of assetlocation or projectsite is not\n        specified, if no location found, if no model definitions\n        found, if multiple model definitions found without\n        specification, or if specified model definition not found.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; api.get_modeldefinition_id()  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: At least either of the related ... must be specified!\n    \"\"\"\n    if assetlocation is None and projectsite is None:\n        raise ValueError(\"At least either of the related `assetlocation` or `projectsite` must be specified!\")\n\n    result = {}\n    if projectsite is None:\n        if assetlocation is None:\n            raise ValueError(\"Asset location must be specified when projectsite is None.\")\n        location_data = self.loc_api.get_assetlocation_detail(assetlocation=assetlocation)\n        if location_data[\"exists\"]:\n            location = cast(pd.DataFrame, location_data[\"data\"])\n        else:\n            raise ValueError(f\"No location found for asset {assetlocation}.\")\n        projectsite = location[\"projectsite_name\"].loc[0]\n    model_definitions_data = self.get_model_definitions(projectsite=projectsite)\n    if model_definitions_data[\"exists\"]:\n        model_definitions = cast(pd.DataFrame, model_definitions_data[\"data\"])\n    else:\n        raise ValueError(f\"No model definitions found for project site {projectsite}.\")\n    if model_definition is None and len(model_definitions) &gt; 1:\n        raise ValueError(\n            f\"Multiple model definitions found for project site {projectsite}. Please specify which one to use.\"\n        )\n    if model_definition is None:\n        model_definition_id = model_definitions[\"id\"].values[0]\n        result[\"id\"] = model_definition_id\n        result[\"multiple_modeldef\"] = False\n    else:\n        matching_definitions = model_definitions[model_definitions[\"title\"] == model_definition]\n        if matching_definitions.empty:\n            raise ValueError(f\"Model definition '{model_definition}' not found for project site {projectsite}.\")\n        if len(matching_definitions) &gt; 1:\n            raise ValueError(\n                f\"Multiple model definitions found for '{model_definition}' in project site {projectsite}.\\n\"\n                f\"Please check the data consistency.\"\n            )\n        model_definition_id = matching_definitions[\"id\"].values[0]\n        result[\"id\"] = model_definition_id\n        result[\"multiple_modeldef\"] = len(model_definitions) &gt; 1\n    return result\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.get_subassemblies","title":"get_subassemblies","text":"<pre><code>get_subassemblies(\n    projectsite=None,\n    assetlocation=None,\n    subassembly_type=None,\n    model_definition=None,\n)\n</code></pre> <p>Get all relevant structure subassemblies.</p> <p>If you specify a model definition, you also must specify either the projectsite or the asset location.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>Title of the projectsite.</p> <code>None</code> <code>assetlocation</code> <code>str</code> <p>Title of the asset location.</p> <code>None</code> <code>subassembly_type</code> <code>str</code> <p>Type of the subassembly.</p> <code>None</code> <code>model_definition</code> <code>str</code> <p>Title of the model definition.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the location data for each   project</li> <li>\"exists\": Boolean indicating whether matching records   are found</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If model definition specified without projectsite or assetlocation, or if specified model definition not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n&gt;&gt;&gt; with mock.patch.object(\n...     GeometryAPI,\n...     \"process_data\",\n...     return_value=(df, {\"existance\": True}),\n... ):\n...     out = api.get_subassemblies(projectsite=\"Site\")\n&gt;&gt;&gt; out[\"exists\"]\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_subassemblies(\n    self,\n    projectsite: Union[str, None] = None,\n    assetlocation: Union[str, None] = None,\n    subassembly_type: Union[str, None] = None,\n    model_definition: Union[str, None] = None,\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get all relevant structure subassemblies.\n\n    If you specify a model definition, you also must specify either\n    the projectsite or the asset location.\n\n    Parameters\n    ----------\n    projectsite : str, optional\n        Title of the projectsite.\n    assetlocation : str, optional\n        Title of the asset location.\n    subassembly_type : str, optional\n        Type of the subassembly.\n    model_definition : str, optional\n        Title of the model definition.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the location data for each\n          project\n        - \"exists\": Boolean indicating whether matching records\n          are found\n\n    Raises\n    ------\n    ValueError\n        If model definition specified without projectsite or\n        assetlocation, or if specified model definition not found.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_subassemblies(projectsite=\"Site\")\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n    \"\"\"\n    url_params = {}\n    func_args = {}\n    if projectsite is not None:\n        url_params[\"asset__projectsite__title\"] = projectsite\n        func_args[\"projectsite\"] = projectsite\n    if assetlocation is not None:\n        url_params[\"asset__title\"] = assetlocation\n        func_args[\"assetlocation\"] = assetlocation\n    if subassembly_type is not None:\n        url_params[\"subassembly_type\"] = subassembly_type\n    if model_definition is not None:\n        if projectsite is not None or assetlocation is not None:\n            func_args[\"model_definition\"] = model_definition\n            modeldef_data = self.get_modeldefinition_id(**func_args)\n            if modeldef_data[\"id\"] is not None:\n                url_params[\"model_definition\"] = str(modeldef_data[\"id\"])\n            else:\n                raise ValueError(\n                    f\"No model definition {model_definition} found for project site {projectsite} \"\n                    f\"or asset location {assetlocation}.\"\n                )\n        else:\n            raise ValueError(\n                \"If you specify a model definition, you also must specify either \"\n                \"the projectsite or the asset location!\"\n            )\n    url_data_type = \"subassemblies\"\n    output_type = \"list\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.get_buildingblocks","title":"get_buildingblocks","text":"<pre><code>get_buildingblocks(\n    projectsite=None,\n    assetlocation=None,\n    subassembly_type=None,\n    subassembly_id=None,\n)\n</code></pre> <p>Get all relevant building blocks.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>Title of the projectsite.</p> <code>None</code> <code>assetlocation</code> <code>str</code> <p>Title of the asset location.</p> <code>None</code> <code>subassembly_type</code> <code>str</code> <p>Type of the subassemblies (e.g. 'MP', 'TW', 'TP').</p> <code>None</code> <code>subassembly_id</code> <code>int or int64</code> <p>ID of the subassembly.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the location data for each   project</li> <li>\"exists\": Boolean indicating whether matching records   are found</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_buildingblocks(projectsite=\"Site\")\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_buildingblocks(\n    self,\n    projectsite: Union[str, None] = None,\n    assetlocation: Union[str, None] = None,\n    subassembly_type: Union[str, None] = None,\n    subassembly_id: Union[int, np.int64, None] = None,\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get all relevant building blocks.\n\n    Parameters\n    ----------\n    projectsite : str, optional\n        Title of the projectsite.\n    assetlocation : str, optional\n        Title of the asset location.\n    subassembly_type : str, optional\n        Type of the subassemblies (e.g. 'MP', 'TW', 'TP').\n    subassembly_id : int or np.int64, optional\n        ID of the subassembly.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the location data for each\n          project\n        - \"exists\": Boolean indicating whether matching records\n          are found\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = GeometryAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     GeometryAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True}),\n            ... ):\n            ...     out = api.get_buildingblocks(projectsite=\"Site\")\n            &gt;&gt;&gt; out[\"exists\"]\n            True\n    \"\"\"\n    url_params = {}\n    if projectsite is not None:\n        url_params[\"sub_assembly__asset__projectsite__title\"] = projectsite\n    if assetlocation is not None:\n        url_params[\"sub_assembly__asset__title\"] = assetlocation\n    if subassembly_type is not None:\n        url_params[\"sub_assembly__subassembly_type\"] = subassembly_type\n    if subassembly_id is not None:\n        url_params[\"sub_assembly__id\"] = str(subassembly_id)\n    url_data_type = \"buildingblocks\"\n    output_type = \"list\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.get_materials","title":"get_materials","text":"<pre><code>get_materials()\n</code></pre> <p>Get all the materials of building blocks.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the location data for each   project</li> <li>\"exists\": Boolean indicating whether matching records   are found</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_materials()\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_materials(\n    self,\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get all the materials of building blocks.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the location data for each\n          project\n        - \"exists\": Boolean indicating whether matching records\n          are found\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = GeometryAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     GeometryAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True}),\n            ... ):\n            ...     out = api.get_materials()\n            &gt;&gt;&gt; out[\"exists\"]\n            True\n    \"\"\"\n    url_params = {}  # type: dict[str, str]\n    url_data_type = \"materials\"\n    output_type = \"list\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.get_subassembly_objects","title":"get_subassembly_objects","text":"<pre><code>get_subassembly_objects(\n    turbine, subassembly=None, model_definition_id=None\n)\n</code></pre> <p>Get all subassemblies for a given turbine, divided by type.</p> <p>Parameters:</p> Name Type Description Default <code>turbine</code> <code>str</code> <p>Turbine title.</p> required <code>subassembly</code> <code>str</code> <p>Sub-assembly type (e.g. 'MP', 'TW', 'TP').</p> <code>None</code> <code>model_definition_id</code> <code>int or int64</code> <p>ID of the model definition to filter the subassemblies.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"TW\": SubAssembly object for the tower</li> <li>\"TP\": SubAssembly object for the transition piece</li> <li>\"MP\": SubAssembly object for the monopile</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no subassemblies found for the turbine or if no materials found in the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; materials = pd.DataFrame(\n...     [\n...         {\n...             \"title\": \"Steel\",\n...             \"slug\": \"steel\",\n...             \"id\": np.int64(1),\n...             \"description\": \"\",\n...             \"young_modulus\": np.float64(210000.0),\n...             \"density\": np.float64(7850.0),\n...             \"poisson_ratio\": np.float64(0.3),\n...         }\n...     ]\n... )\n&gt;&gt;&gt; item = {\n...     \"id\": np.int64(1),\n...     \"title\": \"SA_1\",\n...     \"description\": \"\",\n...     \"slug\": \"sa\",\n...     \"x_position\": np.float64(0),\n...     \"y_position\": np.float64(0),\n...     \"z_position\": np.float64(0),\n...     \"vertical_position_reference_system\": \"LAT\",\n...     \"subassembly_type\": \"TW\",\n...     \"source\": \"api\",\n...     \"asset\": np.int64(1),\n...     \"model_definition\": np.int64(1),\n... }\n&gt;&gt;&gt; response = SimpleNamespace(\n...     status_code=200,\n...     reason=\"OK\",\n...     json=lambda: [item],\n... )\n&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; with mock.patch.object(\n...     GeometryAPI,\n...     \"send_request\",\n...     return_value=response,\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"get_materials\",\n...     return_value={\"exists\": True, \"data\": materials},\n... ):\n...     out = api.get_subassembly_objects(\"T01\")\n&gt;&gt;&gt; sorted(out.keys())\n['TW']\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_subassembly_objects(\n    self,\n    turbine: str,\n    subassembly: Union[str, None] = None,\n    model_definition_id: Union[int, np.int64, None] = None,\n) -&gt; dict[str, SubAssembly]:\n    \"\"\"\n    Get all subassemblies for a given turbine, divided by type.\n\n    Parameters\n    ----------\n    turbine : str\n        Turbine title.\n    subassembly : str, optional\n        Sub-assembly type (e.g. 'MP', 'TW', 'TP').\n    model_definition_id : int or np.int64, optional\n        ID of the model definition to filter the subassemblies.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"TW\": SubAssembly object for the tower\n        - \"TP\": SubAssembly object for the transition piece\n        - \"MP\": SubAssembly object for the monopile\n\n    Raises\n    ------\n    ValueError\n        If no subassemblies found for the turbine or if no\n        materials found in the database.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; materials = pd.DataFrame(\n    ...     [\n    ...         {\n    ...             \"title\": \"Steel\",\n    ...             \"slug\": \"steel\",\n    ...             \"id\": np.int64(1),\n    ...             \"description\": \"\",\n    ...             \"young_modulus\": np.float64(210000.0),\n    ...             \"density\": np.float64(7850.0),\n    ...             \"poisson_ratio\": np.float64(0.3),\n    ...         }\n    ...     ]\n    ... )\n    &gt;&gt;&gt; item = {\n    ...     \"id\": np.int64(1),\n    ...     \"title\": \"SA_1\",\n    ...     \"description\": \"\",\n    ...     \"slug\": \"sa\",\n    ...     \"x_position\": np.float64(0),\n    ...     \"y_position\": np.float64(0),\n    ...     \"z_position\": np.float64(0),\n    ...     \"vertical_position_reference_system\": \"LAT\",\n    ...     \"subassembly_type\": \"TW\",\n    ...     \"source\": \"api\",\n    ...     \"asset\": np.int64(1),\n    ...     \"model_definition\": np.int64(1),\n    ... }\n    &gt;&gt;&gt; response = SimpleNamespace(\n    ...     status_code=200,\n    ...     reason=\"OK\",\n    ...     json=lambda: [item],\n    ... )\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"send_request\",\n    ...     return_value=response,\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_materials\",\n    ...     return_value={\"exists\": True, \"data\": materials},\n    ... ):\n    ...     out = api.get_subassembly_objects(\"T01\")\n    &gt;&gt;&gt; sorted(out.keys())\n    ['TW']\n    \"\"\"\n    url_data_type = \"subassemblies\"\n    url_params = {\"asset__title\": turbine}\n    if subassembly is not None:\n        url_params[\"subassembly_type\"] = subassembly\n    if model_definition_id is not None:\n        url_params[\"model_definition\"] = str(model_definition_id)\n    resp = self.send_request(url_data_type, url_params)\n    self.check_request_health(resp)\n    if not resp.json():\n        raise ValueError(\"No subassemblies found for \" + str(turbine))\n\n    material_data = self.get_materials()\n    if material_data[\"exists\"]:\n        materials = material_data[\"data\"]\n    else:\n        raise ValueError(\"No materials found in the database.\")\n\n    subassemblies = {}\n    for item in resp.json():\n        subassembly_type = item[\"subassembly_type\"]\n        subassembly_obj = SubAssembly(materials, item, api_object=self)\n        if subassembly_type in subassemblies:\n            if not isinstance(subassemblies[subassembly_type], list):\n                subassemblies[subassembly_type] = [subassemblies[subassembly_type]]\n            subassemblies[subassembly_type].append(subassembly_obj)\n        else:\n            subassemblies[subassembly_type] = subassembly_obj\n\n    return subassemblies\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.get_owt_geometry_processor","title":"get_owt_geometry_processor","text":"<pre><code>get_owt_geometry_processor(\n    turbines,\n    model_definition=None,\n    tower_base=None,\n    monopile_head=None,\n)\n</code></pre> <p>Return the required processing class.</p> <p>Will return data even if some turbines have issues given that at least one is fully OK.</p> <p>Parameters:</p> Name Type Description Default <code>turbines</code> <code>str or list of str</code> <p>Title(s) of the turbines.</p> required <code>model_definition</code> <code>str</code> <p>Title of the model definition.</p> <code>None</code> <code>tower_base</code> <code>float or list of float</code> <p>Height(s) of the tower base.</p> <code>None</code> <code>monopile_head</code> <code>float or list of float</code> <p>Height(s) of the monopile head.</p> <code>None</code> <p>Returns:</p> Type Description <code>OWTs</code> <p>Object containing information about all the requested turbines.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no materials found in the database or if all turbines encounter processing errors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; materials = pd.DataFrame({\"id\": [1]})\n&gt;&gt;&gt; location = pd.DataFrame({\"projectsite_name\": [\"Site\"]})\n&gt;&gt;&gt; subassemblies = pd.DataFrame({\"subassembly_type\": [\"TW\"]})\n&gt;&gt;&gt; def _make_owt(*args, **kwargs):\n...     return \"owt\"\n&gt;&gt;&gt; def _make_owts(turbines, owts):\n...     return {\"turbines\": turbines, \"owts\": owts}\n&gt;&gt;&gt; with mock.patch.object(\n...     GeometryAPI,\n...     \"get_materials\",\n...     return_value={\"exists\": True, \"data\": materials},\n... ), mock.patch.object(\n...     api.loc_api,\n...     \"get_assetlocation_detail\",\n...     return_value={\"exists\": True, \"data\": location},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"get_subassemblies\",\n...     return_value={\"exists\": True, \"data\": subassemblies},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"_check_if_need_modeldef\",\n...     return_value=None,\n... ), mock.patch(\n...     \"geometry.io.OWT\",\n...     _make_owt,\n... ), mock.patch(\n...     \"geometry.io.OWTs\",\n...     _make_owts,\n... ):\n...     out = api.get_owt_geometry_processor(\"T01\")\n&gt;&gt;&gt; out[\"turbines\"]\n['T01']\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_owt_geometry_processor(\n    self,\n    turbines: Union[str, list[str]],\n    model_definition: Union[str, None] = None,\n    tower_base: Union[float, list[float], None] = None,\n    monopile_head: Union[float, list[float], None] = None,\n) -&gt; OWTs:\n    \"\"\"\n    Return the required processing class.\n\n    Will return data even if some turbines have issues given that at\n    least one is fully OK.\n\n    Parameters\n    ----------\n    turbines : str or list of str\n        Title(s) of the turbines.\n    model_definition : str, optional\n        Title of the model definition.\n    tower_base : float or list of float, optional\n        Height(s) of the tower base.\n    monopile_head : float or list of float, optional\n        Height(s) of the monopile head.\n\n    Returns\n    -------\n    OWTs\n        Object containing information about all the requested\n        turbines.\n\n    Raises\n    ------\n    ValueError\n        If no materials found in the database or if all turbines\n        encounter processing errors.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; materials = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; location = pd.DataFrame({\"projectsite_name\": [\"Site\"]})\n    &gt;&gt;&gt; subassemblies = pd.DataFrame({\"subassembly_type\": [\"TW\"]})\n    &gt;&gt;&gt; def _make_owt(*args, **kwargs):\n    ...     return \"owt\"\n    &gt;&gt;&gt; def _make_owts(turbines, owts):\n    ...     return {\"turbines\": turbines, \"owts\": owts}\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_materials\",\n    ...     return_value={\"exists\": True, \"data\": materials},\n    ... ), mock.patch.object(\n    ...     api.loc_api,\n    ...     \"get_assetlocation_detail\",\n    ...     return_value={\"exists\": True, \"data\": location},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_subassemblies\",\n    ...     return_value={\"exists\": True, \"data\": subassemblies},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"_check_if_need_modeldef\",\n    ...     return_value=None,\n    ... ), mock.patch(\n    ...     \"geometry.io.OWT\",\n    ...     _make_owt,\n    ... ), mock.patch(\n    ...     \"geometry.io.OWTs\",\n    ...     _make_owts,\n    ... ):\n    ...     out = api.get_owt_geometry_processor(\"T01\")\n    &gt;&gt;&gt; out[\"turbines\"]\n    ['T01']\n    \"\"\"\n    materials_data = self.get_materials()\n    if materials_data[\"exists\"]:\n        materials = cast(pd.DataFrame, materials_data[\"data\"])\n    else:\n        raise ValueError(\"No materials found in the database.\")\n    owts = []\n    successful_turbines = []\n    errors = []\n    turbines = [turbines] if isinstance(turbines, str) else turbines\n    if not isinstance(tower_base, list) and not isinstance(monopile_head, list):\n        tower_base = [tower_base] * len(turbines)  # type: ignore\n        monopile_head = [monopile_head] * len(turbines)  # type: ignore\n    for i, turbine in enumerate(turbines):\n        try:\n            location_data = self.loc_api.get_assetlocation_detail(assetlocation=turbine)\n            if location_data[\"exists\"]:\n                location = cast(pd.DataFrame, location_data[\"data\"])\n            else:\n                raise ValueError(f\"No location found for turbine {turbine}.\")\n            projectsite = location[\"projectsite_name\"].loc[0]\n            subassemblies_data = self.get_subassemblies(\n                projectsite=projectsite,\n                assetlocation=turbine,\n                model_definition=model_definition,\n            )\n            if subassemblies_data[\"exists\"]:\n                subassemblies = subassemblies_data[\"data\"]\n                self._check_if_need_modeldef(subassemblies, turbine)\n            else:\n                raise ValueError(\n                    f\"No subassemblies found for turbine {turbine}. Please check model definition or database data.\"\n                )\n            owts.append(\n                OWT(\n                    self,\n                    materials,\n                    subassemblies,\n                    location,\n                    tower_base[i] if isinstance(tower_base, list) else tower_base,\n                    (monopile_head[i] if isinstance(monopile_head, list) else monopile_head),\n                )\n            )\n            successful_turbines.append(turbine)\n        except ValueError as e:\n            errors.append(str(e))\n    if errors:\n        if successful_turbines:\n            warnings.warn(\n                f\"There were some errors during processing the request. \"\n                f\"But some turbines were processed successfully: {', '.join(successful_turbines)}.\"\n                f\"\\nErrors:\\n\" + \"\\n\".join(errors),\n                stacklevel=2,\n            )\n        else:\n            raise ValueError(\"\\n\".join(errors))\n    return OWTs(successful_turbines, owts)\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.get_monopile_pyles","title":"get_monopile_pyles","text":"<pre><code>get_monopile_pyles(\n    projectsite,\n    assetlocation,\n    cutoff_point=nan,\n    model_definition=None,\n)\n</code></pre> <p>Return a dataframe with the monopile geometry.</p> <p>Uses the mudline as reference.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>Name of the project site.</p> required <code>assetlocation</code> <code>str</code> <p>Name of the wind turbine location.</p> required <code>cutoff_point</code> <code>float</code> <p>Elevation of the load application point in (mLAT) above the mudline.</p> <code>nan</code> <code>model_definition</code> <code>str</code> <p>Title of the model definition.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with the monopile geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no subassemblies or location found for turbine.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; bbs = pd.DataFrame(\n...     [\n...         {\n...             \"z_position\": 0,\n...             \"material_name\": \"Steel\",\n...             \"density\": 7850.0,\n...             \"wall_thickness\": 20.0,\n...             \"bottom_outer_diameter\": 6.0,\n...             \"top_outer_diameter\": 6.0,\n...             \"youngs_modulus\": 210000.0,\n...             \"poissons_ratio\": 0.3,\n...         },\n...         {\n...             \"z_position\": -1000,\n...             \"material_name\": \"Steel\",\n...             \"density\": 7850.0,\n...             \"wall_thickness\": 20.0,\n...             \"bottom_outer_diameter\": 6.0,\n...             \"top_outer_diameter\": 6.0,\n...             \"youngs_modulus\": 210000.0,\n...             \"poissons_ratio\": 0.3,\n...         },\n...     ]\n... )\n&gt;&gt;&gt; sas = pd.DataFrame({\"z_position\": [-50000]})\n&gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n&gt;&gt;&gt; with mock.patch.object(\n...     GeometryAPI,\n...     \"get_buildingblocks\",\n...     return_value={\"exists\": True, \"data\": bbs},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"get_subassemblies\",\n...     return_value={\"exists\": True, \"data\": sas},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"_check_if_need_modeldef\",\n...     return_value=None,\n... ), mock.patch.object(\n...     api.loc_api,\n...     \"get_assetlocation_detail\",\n...     return_value={\"exists\": True, \"data\": location},\n... ):\n...     pile = api.get_monopile_pyles(\"Site\", \"T01\")\n&gt;&gt;&gt; \"Depth from [m]\" in pile.columns\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_monopile_pyles(\n    self,\n    projectsite,\n    assetlocation,\n    cutoff_point=np.nan,\n    model_definition: Union[str, None] = None,\n):\n    \"\"\"\n    Return a dataframe with the monopile geometry.\n\n    Uses the mudline as reference.\n\n    Parameters\n    ----------\n    projectsite : str\n        Name of the project site.\n    assetlocation : str\n        Name of the wind turbine location.\n    cutoff_point : float, optional\n        Elevation of the load application point in (mLAT) above the\n        mudline.\n    model_definition : str, optional\n        Title of the model definition.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with the monopile geometry.\n\n    Raises\n    ------\n    ValueError\n        If no subassemblies or location found for turbine.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; bbs = pd.DataFrame(\n    ...     [\n    ...         {\n    ...             \"z_position\": 0,\n    ...             \"material_name\": \"Steel\",\n    ...             \"density\": 7850.0,\n    ...             \"wall_thickness\": 20.0,\n    ...             \"bottom_outer_diameter\": 6.0,\n    ...             \"top_outer_diameter\": 6.0,\n    ...             \"youngs_modulus\": 210000.0,\n    ...             \"poissons_ratio\": 0.3,\n    ...         },\n    ...         {\n    ...             \"z_position\": -1000,\n    ...             \"material_name\": \"Steel\",\n    ...             \"density\": 7850.0,\n    ...             \"wall_thickness\": 20.0,\n    ...             \"bottom_outer_diameter\": 6.0,\n    ...             \"top_outer_diameter\": 6.0,\n    ...             \"youngs_modulus\": 210000.0,\n    ...             \"poissons_ratio\": 0.3,\n    ...         },\n    ...     ]\n    ... )\n    &gt;&gt;&gt; sas = pd.DataFrame({\"z_position\": [-50000]})\n    &gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_buildingblocks\",\n    ...     return_value={\"exists\": True, \"data\": bbs},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_subassemblies\",\n    ...     return_value={\"exists\": True, \"data\": sas},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"_check_if_need_modeldef\",\n    ...     return_value=None,\n    ... ), mock.patch.object(\n    ...     api.loc_api,\n    ...     \"get_assetlocation_detail\",\n    ...     return_value={\"exists\": True, \"data\": location},\n    ... ):\n    ...     pile = api.get_monopile_pyles(\"Site\", \"T01\")\n    &gt;&gt;&gt; \"Depth from [m]\" in pile.columns\n    True\n    \"\"\"\n    # Retrieve the monopile cans\n    bbs = self.get_buildingblocks(\n        projectsite=projectsite,\n        assetlocation=assetlocation,\n        subassembly_type=\"MP\",\n    )\n    # Retrieve the monopile subassembly\n    sas = self.get_subassemblies(\n        projectsite=projectsite,\n        assetlocation=assetlocation,\n        subassembly_type=\"MP\",\n        model_definition=model_definition,\n    )\n    if sas[\"exists\"]:\n        subassemblies = cast(pd.DataFrame, sas[\"data\"])\n        self._check_if_need_modeldef(subassemblies, assetlocation)\n    else:\n        raise ValueError(\n            f\"No subassemblies found for turbine {assetlocation}. Please check model definition or database data.\"\n        )\n    # Water depth\n    location_data = self.loc_api.get_assetlocation_detail(assetlocation=assetlocation, projectsite=projectsite)\n    if location_data[\"exists\"]:\n        location = cast(pd.DataFrame, location_data[\"data\"])\n        water_depth = location[\"elevation\"].values[0]\n    else:\n        raise ValueError(\n            f\"No location found for turbine {assetlocation} and hence no water depth can be retrieved.\"\n        )\n\n    # Calculate the pile penetration\n    sas_df = cast(pd.DataFrame, sas[\"data\"])\n    toe_depth_lat = sas_df[\"z_position\"].iloc[0]\n    penetration = -((1e-3 * toe_depth_lat) - water_depth)\n\n    # Create the pile for subsequent response analysis\n    pile = pd.DataFrame()\n\n    bbs_df = cast(pd.DataFrame, bbs[\"data\"])\n    for index in range(1, len(bbs_df)):\n        prev_row = bbs_df.iloc[index - 1]\n        row = bbs_df.iloc[index]\n        pile.loc[index, \"Depth to [m]\"] = penetration - 1e-3 * float(prev_row.at[\"z_position\"])\n        pile.loc[index, \"Depth from [m]\"] = penetration - 1e-3 * float(row.at[\"z_position\"])\n        pile.loc[index, \"Pile material\"] = str(row.at[\"material_name\"])\n        pile.loc[index, \"Pile material submerged unit weight [kN/m3]\"] = 1e-2 * float(row.at[\"density\"]) - 10\n        pile.loc[index, \"Wall thickness [mm]\"] = float(row.at[\"wall_thickness\"])\n        pile.loc[index, \"Diameter [m]\"] = (\n            1e-3 * 0.5 * (float(row.at[\"bottom_outer_diameter\"]) + float(row.at[\"top_outer_diameter\"]))\n        )\n        pile.loc[index, \"Youngs modulus [GPa]\"] = float(row.at[\"youngs_modulus\"])\n        pile.loc[index, \"Poissons ratio [-]\"] = float(row.at[\"poissons_ratio\"])\n\n    pile.sort_values(\"Depth from [m]\", inplace=True)\n    pile.reset_index(drop=True, inplace=True)\n\n    # Cut off at the mudline\n    if not np.isnan(cutoff_point):\n        pile = pile.loc[pile[\"Depth to [m]\"] &gt; cutoff_point].reset_index(drop=True)\n        pile.loc[0, \"Depth from [m]\"] = cutoff_point\n\n    return pile\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.GeometryAPI.plot_turbines","title":"plot_turbines","text":"<pre><code>plot_turbines(\n    turbines,\n    figures_per_line=5,\n    return_fig=False,\n    model_definition=None,\n)\n</code></pre> <p>Plot turbines' frontal geometry.</p> <p>Parameters:</p> Name Type Description Default <code>turbines</code> <code>str or list of str</code> <p>Title(s) of the turbines.</p> required <code>figures_per_line</code> <code>int</code> <p>Number of figures per line, default is 5.</p> <code>5</code> <code>return_fig</code> <code>bool</code> <p>Boolean indicating whether to return the figure, default is False.</p> <code>False</code> <code>model_definition</code> <code>str</code> <p>Title of the model definition.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure or None</code> <p>Plotly figure object with selected turbines front profiles (if requested) or nothing.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no materials or subassemblies found in the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; class _StubSubassembly:\n...     def __init__(self, *args, **kwargs):\n...         self.building_blocks = []\n...     def plotly(self):\n...         layout = {\n...             \"scene\": {},\n...             \"yaxis\": {\n...                 \"title\": {\"text\": \"Height , mm\"},\n...                 \"scaleanchor\": \"x\",\n...                 \"scaleratio\": 1,\n...                 \"type\": \"linear\",\n...             },\n...         }\n...         return [], layout\n&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; materials = pd.DataFrame({\"id\": [1]})\n&gt;&gt;&gt; subassemblies = pd.DataFrame({\"subassembly_type\": [\"TW\"]})\n&gt;&gt;&gt; with mock.patch.object(\n...     GeometryAPI,\n...     \"get_materials\",\n...     return_value={\"exists\": True, \"data\": materials},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"get_subassemblies\",\n...     return_value={\"exists\": True, \"data\": subassemblies},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"_check_if_need_modeldef\",\n...     return_value=None,\n... ), mock.patch(\n...     \"geometry.io.SubAssembly\",\n...     _StubSubassembly,\n... ):\n...     fig = api.plot_turbines([\"T01\"], return_fig=True)\n&gt;&gt;&gt; fig is not None\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def plot_turbines(\n    self,\n    turbines: Union[list[str], str],\n    figures_per_line: int = 5,\n    return_fig: bool = False,\n    model_definition: Union[str, None] = None,\n) -&gt; Union[go.Figure, None]:\n    \"\"\"\n    Plot turbines' frontal geometry.\n\n    Parameters\n    ----------\n    turbines : str or list of str\n        Title(s) of the turbines.\n    figures_per_line : int, optional\n        Number of figures per line, default is 5.\n    return_fig : bool, optional\n        Boolean indicating whether to return the figure, default\n        is False.\n    model_definition : str, optional\n        Title of the model definition.\n\n    Returns\n    -------\n    plotly.graph_objects.Figure or None\n        Plotly figure object with selected turbines front profiles\n        (if requested) or nothing.\n\n    Raises\n    ------\n    ValueError\n        If no materials or subassemblies found in the database.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; class _StubSubassembly:\n    ...     def __init__(self, *args, **kwargs):\n    ...         self.building_blocks = []\n    ...     def plotly(self):\n    ...         layout = {\n    ...             \"scene\": {},\n    ...             \"yaxis\": {\n    ...                 \"title\": {\"text\": \"Height , mm\"},\n    ...                 \"scaleanchor\": \"x\",\n    ...                 \"scaleratio\": 1,\n    ...                 \"type\": \"linear\",\n    ...             },\n    ...         }\n    ...         return [], layout\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; materials = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; subassemblies = pd.DataFrame({\"subassembly_type\": [\"TW\"]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_materials\",\n    ...     return_value={\"exists\": True, \"data\": materials},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_subassemblies\",\n    ...     return_value={\"exists\": True, \"data\": subassemblies},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"_check_if_need_modeldef\",\n    ...     return_value=None,\n    ... ), mock.patch(\n    ...     \"geometry.io.SubAssembly\",\n    ...     _StubSubassembly,\n    ... ):\n    ...     fig = api.plot_turbines([\"T01\"], return_fig=True)\n    &gt;&gt;&gt; fig is not None\n    True\n    \"\"\"\n    materials_data = self.get_materials()\n    if materials_data[\"exists\"]:\n        materials = materials_data[\"data\"]\n    else:\n        raise ValueError(\"No materials found in the database.\")\n    turbines = [turbines] if isinstance(turbines, str) else turbines\n    if len(turbines) &gt; figures_per_line:\n        n_rows = len(turbines) // figures_per_line + 1\n        n_cols = figures_per_line\n        rows = [i for i in range(1, n_rows + 1) for _ in range(n_cols)]\n        cols = [i for _ in range(n_rows) for i in range(1, n_cols + 1)]\n    else:\n        n_rows = 1\n        n_cols = len(turbines)\n        rows = [1 for _ in range(n_cols)]\n        cols = list(range(1, n_cols + 1))\n    autosize = not len(turbines) &lt; 3\n    fig = make_subplots(n_rows, n_cols, subplot_titles=turbines)\n    for i, turbine in enumerate(turbines):\n        subassemblies_data = self.get_subassemblies(\n            assetlocation=turbine,\n            model_definition=model_definition,\n        )\n        if subassemblies_data[\"exists\"]:\n            subassemblies = cast(pd.DataFrame, subassemblies_data[\"data\"])\n            self._check_if_need_modeldef(subassemblies, turbine)\n        else:\n            raise ValueError(\n                f\"No subassemblies found for turbine {turbine}. Please check model definition or database data.\"\n            )\n        for _, sa in subassemblies.iterrows():\n            subassembly = SubAssembly(materials, cast(DataSA, sa.to_dict()), api_object=self)\n            subassembly.building_blocks  # noqa: B018\n            plotly_data = subassembly.plotly()\n            for k in range(len(plotly_data[0])):\n                fig.add_trace(plotly_data[0][k], row=rows[i], col=cols[i])\n        plotly_layout = plotly_data[1]\n        if i &gt; 0:\n            plotly_layout[\"scene\" + str(i + 1)] = plotly_layout[\"scene\"]\n            plotly_layout[\"yaxis\" + str(i + 1)] = plotly_layout[\"yaxis\"]\n            plotly_layout[\"yaxis\" + str(i + 1)][\"scaleanchor\"] = \"x\" + str(i + 1)\n            plotly_layout.pop(\"scene\")\n            plotly_layout.pop(\"yaxis\")\n            plotly_layout[\"yaxis\" + str(i + 1)].pop(\"title\")\n        fig.update_layout(plotly_layout, autosize=autosize)\n    if return_fig:\n        return fig\n    else:\n        fig.show()\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT","title":"OWT","text":"<pre><code>OWT(\n    api,\n    materials,\n    subassemblies,\n    location,\n    tower_base=None,\n    pile_head=None,\n)\n</code></pre> <p>Class to process the geometry data of a single OWT.</p> <p>:param api: API object used to call get_* methods. :param materials: Pandas dataframe with the materials data. :param sub_assemblies: Dictionary of the subassemblies. :param tw_sub_assemblies: Pandas dataframe with the tower subassemblies data for a given turbine. :param tp_sub_assemblies: Pandas dataframe with the transition piece subassemblies data for a given turbine. :param mp_sub_assemblies: Pandas dataframe with the monopile subassemblies data for a given turbine. :param tower_base: Elevation of the OWT tower base in mLAT. :param pile_head: Elevation of the pile head in mLAT. :param water_depth: Water depth in mLAT. :param pile_toe: Elevation of the pile toe in mLAT. :param rna: Pandas dataframe with the RNA data. :param tower: Pandas dataframe with the tower data. :param transition_piece: Pandas dataframe with the transition piece data. :param monopile: Pandas dataframe with the monopile data. :param tw_lumped_mass: Pandas dataframe with the lumped masses data for the tower. :param tp_lumped_mass: Pandas dataframe with the lumped masses data for the transition piece. :param mp_lumped_mass: Pandas dataframe with the lumped masses data for the monopile. :param tp_distributed_mass: Pandas dataframe with the distributed masses data for the transition piece. :param mp_distributed_mass: Pandas dataframe with the distributed masses data for the monopile. :param grout: Pandas dataframe with the grout data. :param full_structure: Pandas dataframe with the full structure data. :param tp_skirt: Pandas dataframe with the transition piece skirt data. :param substructure: Pandas dataframe with the substructure data.</p> <p>Create an instance of the OWT class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>Any</code> <p>API object used to call get_* methods.</p> required <code>materials</code> <code>DataFrame or bool or int64 or None</code> <p>Pandas dataframe with the materials data.</p> required <code>subassemblies</code> <code>DataFrame or bool or int64 or None</code> <p>Pandas dataframe with the subassemblies data for a given turbine.</p> required <code>location</code> <code>DataFrame or bool or int64 or None</code> <p>Pandas dataframe with the location data for a given turbine.</p> required <code>tower_base</code> <code>float64</code> <p>Elevation of the OWT tower base in mLAT.</p> <code>None</code> <code>pile_head</code> <code>float64</code> <p>Elevation of the pile head in mLAT.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from contextlib import ExitStack\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n&gt;&gt;&gt; def _set_subassemblies(self, subassemblies):\n...     self.sub_assemblies = {}\n&gt;&gt;&gt; def _set_members(self):\n...     return None\n&gt;&gt;&gt; with mock.patch.object(\n...     OWT,\n...     \"_set_subassemblies\",\n...     _set_subassemblies,\n... ), mock.patch.object(OWT, \"_set_members\", _set_members):\n...     owt = OWT(\n...         api=object(),\n...         materials=pd.DataFrame(),\n...         subassemblies=pd.DataFrame(),\n...         location=location,\n...     )\n&gt;&gt;&gt; float(owt.water_depth)\n30.0\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def __init__(\n    self,\n    api: Any,\n    materials: Union[pd.DataFrame, bool, np.int64, None],\n    subassemblies: Union[pd.DataFrame, bool, np.int64, None],\n    location: Union[pd.DataFrame, bool, np.int64, None],\n    tower_base: Union[np.float64, float, None] = None,\n    pile_head: Union[np.float64, float, None] = None,\n) -&gt; None:\n    \"\"\"\n    Create an instance of the OWT class with required parameters.\n\n    Parameters\n    ----------\n    api : Any\n        API object used to call get_* methods.\n    materials : pd.DataFrame or bool or np.int64 or None\n        Pandas dataframe with the materials data.\n    subassemblies : pd.DataFrame or bool or np.int64 or None\n        Pandas dataframe with the subassemblies data for a given\n        turbine.\n    location : pd.DataFrame or bool or np.int64 or None\n        Pandas dataframe with the location data for a given\n        turbine.\n    tower_base : np.float64, optional\n        Elevation of the OWT tower base in mLAT.\n    pile_head : np.float64, optional\n        Elevation of the pile head in mLAT.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from contextlib import ExitStack\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n    &gt;&gt;&gt; def _set_subassemblies(self, subassemblies):\n    ...     self.sub_assemblies = {}\n    &gt;&gt;&gt; def _set_members(self):\n    ...     return None\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     OWT,\n    ...     \"_set_subassemblies\",\n    ...     _set_subassemblies,\n    ... ), mock.patch.object(OWT, \"_set_members\", _set_members):\n    ...     owt = OWT(\n    ...         api=object(),\n    ...         materials=pd.DataFrame(),\n    ...         subassemblies=pd.DataFrame(),\n    ...         location=location,\n    ...     )\n    &gt;&gt;&gt; float(owt.water_depth)\n    30.0\n    \"\"\"\n    self._init_proc = False\n    self._init_spec_part = False\n    self._init_spec_full = False\n    self.api = api\n    materials_df = cast(pd.DataFrame, materials)\n    subassemblies_df = cast(pd.DataFrame, subassemblies)\n    location_df = cast(pd.DataFrame, location)\n    self.materials = materials_df\n    self._set_subassemblies(subassemblies_df)\n    self.tw_sub_assemblies = None\n    self.tp_sub_assemblies = None\n    self.mp_sub_assemblies = None\n    self._set_members()\n    for attr in ATTR_PROC:\n        setattr(self, attr, None)\n    for attr in ATTR_SPEC:\n        setattr(self, attr, None)\n    self.water_depth = np.float64(location_df[\"elevation\"].values[0])\n    if not tower_base or not pile_head:\n        if \"TW\" in self.sub_assemblies:\n            self.tower_base = self.sub_assemblies[\"TW\"].absolute_bottom\n        elif \"TP\" in self.sub_assemblies:\n            self.tower_base = self.sub_assemblies[\"TP\"].absolute_top\n        else:\n            self.tower_base = None\n        if \"MP\" in self.sub_assemblies:\n            self.pile_head = self.sub_assemblies[\"MP\"].absolute_top\n        else:\n            self.pile_head = None\n    else:\n        self.tower_base = tower_base\n        self.pile_head = pile_head\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT-functions","title":"Functions","text":""},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.set_df_structure","title":"set_df_structure","text":"<pre><code>set_df_structure(idx)\n</code></pre> <p>Calculate and/or convert geometrical data of subassemblies.</p> <p>Calculates and/or converts geometrical data of subassemblies from the database.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Possible index to identify corresponding subassembly.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe containing geometry data from database with z in mLAT system.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If subassembly data not found or unknown index.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def set_df_structure(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate and/or convert geometrical data of subassemblies.\n\n    Calculates and/or converts geometrical data of subassemblies\n    from the database.\n\n    Parameters\n    ----------\n    idx : str\n        Possible index to identify corresponding subassembly.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe containing geometry data from database with z in\n        mLAT system.\n\n    Raises\n    ------\n    ValueError\n        If subassembly data not found or unknown index.\n    \"\"\"\n    cols = [\n        \"OD\",\n        \"height\",\n        \"mass\",\n        \"volume\",\n        \"wall_thickness\",\n        \"x\",\n        \"y\",\n        \"z\",\n    ]\n    if idx == \"tw\":\n        if self.tw_sub_assemblies is None:\n            raise ValueError(\"Tower subassembly data not found.\")\n        df_index = self.tw_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.tw_sub_assemblies.loc[df_index, cols])\n        depth_to = self.tower_base + df.z * 1e-3\n        depth_from = depth_to + df.height * 1e-3\n    elif idx == \"tp\":\n        if self.tp_sub_assemblies is None:\n            raise ValueError(\"Transition piece subassembly data not found.\")\n        # We don't take into account the grout, this element will be modelled as a distributed lumped mass.\n        df_index = (self.tp_sub_assemblies.index.str.contains(idx)) &amp; (\n            ~self.tp_sub_assemblies.index.str.contains(\"grout\")\n        )\n        df = deepcopy(self.tp_sub_assemblies.loc[df_index, cols])\n        bottom_tp = self.tower_base - df[\"height\"].sum() * 1e-3\n        depth_to = bottom_tp + df.z * 1e-3\n        depth_from = depth_to + df.height * 1e-3\n    elif idx == \"mp\":\n        if self.mp_sub_assemblies is None:\n            raise ValueError(\"Monopile subassembly data not found.\")\n        df_index = self.mp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.mp_sub_assemblies.loc[df_index, cols])\n        toe = self.pile_head - df[\"height\"].sum() * 1e-3\n        self.pile_toe = round(toe, 3)\n        depth_to = toe + df.z * 1e-3\n        depth_from = depth_to + df.height * 1e-3\n    else:\n        raise ValueError(\"Unknown index.\")\n    df[\"Elevation from [mLAT]\"] = depth_from\n    df[\"Elevation to [mLAT]\"] = depth_to\n    # Round elevations to mm to avoid numerical inconsistencies later when setting altitude values to apply loads.\n    df = df.round({\"Elevation from [mLAT]\": 3, \"Elevation to [mLAT]\": 3})\n    return df\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.process_structure_geometry","title":"process_structure_geometry","text":"<pre><code>process_structure_geometry(idx)\n</code></pre> <p>Calculate and/or convert geometrical data for FE models.</p> <p>Calculates and/or converts geometrical data of subassemblies from the database to use as input for FE models.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Possible index to identify corresponding subassembly.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe consisting of the required data to build FE models.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_structure_geometry(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate and/or convert geometrical data for FE models.\n\n    Calculates and/or converts geometrical data of subassemblies\n    from the database to use as input for FE models.\n\n    Parameters\n    ----------\n    idx : str\n        Possible index to identify corresponding subassembly.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe consisting of the required data to build FE\n        models.\n    \"\"\"\n    df = self.set_df_structure(idx)\n    df[\"height\"] = pd.to_numeric(df[\"height\"])\n    df[\"wall_thickness\"] = pd.to_numeric(df[\"wall_thickness\"])\n    df.rename(columns={\"wall_thickness\": \"Wall thickness [mm]\"}, inplace=True)\n    df.rename(columns={\"volume\": \"Volume [m3]\"}, inplace=True)\n    d_to = [d.split(\"/\", 1)[0] for d in df[\"OD\"].values]\n    d_from = [d.split(\"/\", 1)[1] if len(d.split(\"/\", 1)) &gt; 1 else d.split(\"/\", 1)[0] for d in df[\"OD\"].values]\n    df[\"Diameter from [m]\"] = np.array(d_from, dtype=float) * 1e-3\n    df[\"Diameter to [m]\"] = np.array(d_to, dtype=float) * 1e-3\n    df[\"rho [t/m]\"] = df[\"mass\"] / df[\"height\"]\n    df[\"Mass [t]\"] = df[\"mass\"] * 1e-3\n    df[\"Height [m]\"] = df[\"height\"] * 1e-3\n    df[\"Youngs modulus [GPa]\"] = 210\n    df[\"Poissons ratio [-]\"] = 0.3\n    cols = [\n        \"Elevation from [mLAT]\",\n        \"Elevation to [mLAT]\",\n        \"Height [m]\",\n        \"Diameter from [m]\",\n        \"Diameter to [m]\",\n        \"Volume [m3]\",\n        \"Wall thickness [mm]\",\n        \"Youngs modulus [GPa]\",\n        \"Poissons ratio [-]\",\n        \"Mass [t]\",\n        \"rho [t/m]\",\n    ]\n    return df[cols]\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.process_rna","title":"process_rna","text":"<pre><code>process_rna()\n</code></pre> <p>Set dataframe with required properties to model the RNA system.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If tower subassembly data not found.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_rna(self) -&gt; None:\n    \"\"\"\n    Set dataframe with required properties to model the RNA system.\n\n    Raises\n    ------\n    ValueError\n        If tower subassembly data not found.\n    \"\"\"\n    if self.tw_sub_assemblies is None:\n        raise ValueError(\"Tower subassembly data not found.\")\n    rna_index = self.tw_sub_assemblies.index.str.contains(\"RNA\")\n    rna = deepcopy(\n        self.tw_sub_assemblies.loc[\n            rna_index,\n            [\"mass\", \"moment_of_inertia\", \"x\", \"y\", \"z\", \"description\"],\n        ]\n    )\n    mi = rna[\"moment_of_inertia\"].values\n    i_xx, i_yy, i_zz = [], [], []\n    for m in mi:\n        i_xx.append(m[\"x\"] * 1e-3)\n        i_yy.append(m[\"y\"] * 1e-3)\n        i_zz.append(m[\"z\"] * 1e-3)\n    rna[\"Ixx [tm2]\"] = i_xx\n    rna[\"Iyy [tm2]\"] = i_yy\n    rna[\"Izz [tm2]\"] = i_zz\n    rna[\"Mass [t]\"] = rna[\"mass\"] * 1e-3\n    rna[\"X [m]\"] = rna[\"x\"] * 1e-3\n    rna[\"Y [m]\"] = rna[\"y\"] * 1e-3\n    rna[\"Z [mLAT]\"] = self.tower_base + rna[\"z\"] * 1e-3\n    rna.rename(columns={\"description\": \"Description\"}, inplace=True)\n    cols = [\n        \"X [m]\",\n        \"Y [m]\",\n        \"Z [mLAT]\",\n        \"Mass [t]\",\n        \"Ixx [tm2]\",\n        \"Iyy [tm2]\",\n        \"Izz [tm2]\",\n        \"Description\",\n    ]\n    self.rna = rna[cols]\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.set_df_appurtenances","title":"set_df_appurtenances","text":"<pre><code>set_df_appurtenances(idx)\n</code></pre> <p>Set dataframe with required properties for concentrated masses.</p> <p>Sets dataframe containing the required properties to model concentrated masses from database subassemblies.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Index to identify corresponding subassembly with possible values: 'TW', 'TP', 'MP'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe containing lumped masses data from database with Z coordinates in mLAT system.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If subassembly data not found or unknown index.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def set_df_appurtenances(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Set dataframe with required properties for concentrated masses.\n\n    Sets dataframe containing the required properties to model\n    concentrated masses from database subassemblies.\n\n    Parameters\n    ----------\n    idx : str\n        Index to identify corresponding subassembly with possible\n        values: 'TW', 'TP', 'MP'.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe containing lumped masses data from database with\n        Z coordinates in mLAT system.\n\n    Raises\n    ------\n    ValueError\n        If subassembly data not found or unknown index.\n    \"\"\"\n    cols = [\"mass\", \"x\", \"y\", \"z\", \"description\"]\n    if idx == \"TW\":\n        if self.tw_sub_assemblies is None:\n            raise ValueError(\"Tower subassembly data not found.\")\n        df_index = self.tw_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.tw_sub_assemblies.loc[df_index, cols])\n        df[\"Z [mLAT]\"] = self.tower_base + df[\"z\"] * 1e-3\n    elif idx == \"TP\":\n        if self.tp_sub_assemblies is None:\n            raise ValueError(\"Transition piece subassembly data not found.\")\n        df_index = self.tp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.tp_sub_assemblies.loc[df_index, cols + [\"height\"]])\n        # Lumped masses have 'None' height whereas distributed masses present not 'None' values\n        df[\"height\"] = pd.to_numeric(df[\"height\"])\n        df = df[df[\"height\"].isnull()]\n        bottom = self.sub_assemblies[\"TP\"].position.z * 1e-3  # m\n        df[\"Z [mLAT]\"] = bottom + df[\"z\"] * 1e-3  # m\n    elif idx == \"MP\":\n        if self.mp_sub_assemblies is None:\n            raise ValueError(\"Monopile subassembly data not found.\")\n        df_index = self.mp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.mp_sub_assemblies.loc[df_index, cols + [\"height\"]])\n        # Lumped masses have 'None' height whereas distributed masses present not 'None' values\n        df[\"height\"] = pd.to_numeric(df[\"height\"])\n        df = df[df[\"height\"].isnull()]\n        bottom = self.pile_toe\n        df[\"Z [mLAT]\"] = bottom + df[\"z\"] * 1e-3\n    else:\n        raise ValueError(\"Unknown index.\")\n    return df\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.process_lumped_masses","title":"process_lumped_masses","text":"<pre><code>process_lumped_masses(idx)\n</code></pre> <p>Create dataframe with required properties for lumped masses.</p> <p>Creates dataframe containing the required properties to model lumped mass appurtenances. Note that if the preprocessor package does not find any appurtenances it'll return an empty dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Index to identify corresponding subassembly with possible values: 'TW', 'TP', 'MP'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with lumped mass properties.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_lumped_masses(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Create dataframe with required properties for lumped masses.\n\n    Creates dataframe containing the required properties to model\n    lumped mass appurtenances. Note that if the preprocessor\n    package does not find any appurtenances it'll return an empty\n    dataframe.\n\n    Parameters\n    ----------\n    idx : str\n        Index to identify corresponding subassembly with possible\n        values: 'TW', 'TP', 'MP'.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with lumped mass properties.\n    \"\"\"\n    df = self.set_df_appurtenances(idx)\n    df[\"Mass [t]\"] = df.mass * 1e-3\n    df[\"X [m]\"] = df.x * 1e-3\n    df[\"Y [m]\"] = df.y * 1e-3\n    df.rename(columns={\"description\": \"Description\"}, inplace=True)\n    cols = [\"X [m]\", \"Y [m]\", \"Z [mLAT]\", \"Mass [t]\", \"Description\"]\n    return df[cols]\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.set_df_distributed_appurtenances","title":"set_df_distributed_appurtenances","text":"<pre><code>set_df_distributed_appurtenances(idx)\n</code></pre> <p>Set dataframe with required properties for distributed masses.</p> <p>Sets dataframe containing the required properties to model distributed lumped masses from database.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Index to identify corresponding subassembly with possible values: 'TW', 'TP', 'MP'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe containing distributed lumped masses data from database. Z coordinates in mLAT system.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If subassembly data not found or unknown index or distributed lumped masses located outside the transition piece.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def set_df_distributed_appurtenances(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Set dataframe with required properties for distributed masses.\n\n    Sets dataframe containing the required properties to model\n    distributed lumped masses from database.\n\n    Parameters\n    ----------\n    idx : str\n        Index to identify corresponding subassembly with possible\n        values: 'TW', 'TP', 'MP'.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe containing distributed lumped masses data from\n        database. Z coordinates in mLAT system.\n\n    Raises\n    ------\n    ValueError\n        If subassembly data not found or unknown index or\n        distributed lumped masses located outside the transition\n        piece.\n    \"\"\"\n    cols = [\"mass\", \"x\", \"y\", \"z\", \"height\", \"volume\", \"description\"]\n    if idx == \"TP\":\n        if self.tp_sub_assemblies is None:\n            raise ValueError(\"Transition piece subassembly data not found.\")\n        df_index = self.tp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.tp_sub_assemblies.loc[df_index, cols])\n        # Lumped masses have 'None' height whereas distributed masses present not 'None' values\n        df[\"height\"] = pd.to_numeric(df[\"height\"])\n        df = df[df[\"height\"].notnull()]\n        bottom_tp = self.tower_base - self.tp_sub_assemblies.iloc[0][\"z\"] * 1e-3\n        df[\"Z [mLAT]\"] = bottom_tp + df[\"z\"] * 1e-3\n    elif idx == \"MP\":\n        if self.mp_sub_assemblies is None:\n            raise ValueError(\"Monopile subassembly data not found.\")\n        df_index = self.mp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.mp_sub_assemblies.loc[df_index, cols])\n        # Lumped masses have 'None' height whereas distributed masses present not 'None' values\n        df[\"height\"] = pd.to_numeric(df[\"height\"])\n        df = df[df[\"height\"].notnull()]\n        bottom = self.pile_toe\n        df[\"Z [mLAT]\"] = bottom + df[\"z\"] * 1e-3\n    elif idx == \"grout\":\n        if self.tp_sub_assemblies is None:\n            raise ValueError(\"Transition piece subassembly data not found.\")\n        df_index = self.tp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.tp_sub_assemblies.loc[df_index, cols])\n        # Lumped masses have 'None' height whereas distributed masses present not 'None' values\n        df[\"height\"] = pd.to_numeric(df[\"height\"])\n        df = df[df[\"height\"].notnull()]\n        bottom_tp = self.tower_base - self.tp_sub_assemblies.iloc[0][\"z\"] * 1e-3\n        df[\"Z [mLAT]\"] = bottom_tp + df[\"z\"] * 1e-3\n    else:\n        raise ValueError(\"Unknown index or non distributed lumped masses located outside the transition piece.\")\n    return df\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.process_distributed_lumped_masses","title":"process_distributed_lumped_masses","text":"<pre><code>process_distributed_lumped_masses(idx)\n</code></pre> <p>Create dataframe with uniformly distributed appurtenances.</p> <p>Creates dataframe containing the required properties to model uniformly distributed appurtenances. Note that if the preprocessor package does not find any appurtenances it'll return an empty dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Index to identify corresponding subassembly with possible values: 'TP', 'MP'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with distributed lumped mass properties.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_distributed_lumped_masses(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Create dataframe with uniformly distributed appurtenances.\n\n    Creates dataframe containing the required properties to model\n    uniformly distributed appurtenances. Note that if the\n    preprocessor package does not find any appurtenances it'll\n    return an empty dataframe.\n\n    Parameters\n    ----------\n    idx : str\n        Index to identify corresponding subassembly with possible\n        values: 'TP', 'MP'.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with distributed lumped mass properties.\n    \"\"\"\n    df = self.set_df_distributed_appurtenances(idx)\n    df[\"Mass [t]\"] = df[\"mass\"] * 1e-3\n    df[\"X [m]\"] = df[\"x\"] * 1e-3\n    df[\"Y [m]\"] = df[\"y\"] * 1e-3\n    df[\"Height [m]\"] = df[\"height\"] * 1e-3\n    df.rename(columns={\"volume\": \"Volume [m3]\"}, inplace=True)\n    df.rename(columns={\"description\": \"Description\"}, inplace=True)\n    cols = [\n        \"X [m]\",\n        \"Y [m]\",\n        \"Z [mLAT]\",\n        \"Height [m]\",\n        \"Mass [t]\",\n        \"Volume [m3]\",\n        \"Description\",\n    ]\n    return df[cols]\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.process_structure","title":"process_structure","text":"<pre><code>process_structure(option='full')\n</code></pre> <p>Set dataframe with required properties to model the tower.</p> <p>Sets dataframe containing the required properties to model the tower geometry, including the RNA system.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>str</code> <p>Option to process the data for a specific subassembly. Possible values:</p> <ul> <li>\"full\": To process all the data for all subassemblies.</li> <li>\"tower\": To process only the data for the tower   subassembly.</li> <li>\"TP\": To process only the data for the transition piece   subassembly.</li> <li>\"monopile\": To process only the data for the monopile   foundation subassembly.</li> </ul> <code>'full'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from contextlib import ExitStack\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n&gt;&gt;&gt; def _set_subassemblies(self, subassemblies):\n...     self.sub_assemblies = {}\n&gt;&gt;&gt; def _set_members(self):\n...     return None\n&gt;&gt;&gt; with mock.patch.object(\n...     OWT,\n...     \"_set_subassemblies\",\n...     _set_subassemblies,\n... ), mock.patch.object(OWT, \"_set_members\", _set_members):\n...     owt = OWT(\n...         api=object(),\n...         materials=pd.DataFrame(),\n...         subassemblies=pd.DataFrame(),\n...         location=location,\n...     )\n&gt;&gt;&gt; empty_df = pd.DataFrame()\n&gt;&gt;&gt; with ExitStack() as stack:\n...     _ = stack.enter_context(mock.patch.object(OWT, \"process_rna\"))\n...     _ = stack.enter_context(\n...         mock.patch.object(\n...             OWT,\n...             \"process_structure_geometry\",\n...             return_value=empty_df,\n...         )\n...     )\n...     _ = stack.enter_context(\n...         mock.patch.object(\n...             OWT,\n...             \"process_lumped_masses\",\n...             return_value=empty_df,\n...         )\n...     )\n...     _ = stack.enter_context(\n...         mock.patch.object(\n...             OWT,\n...             \"process_distributed_lumped_masses\",\n...             return_value=empty_df,\n...         )\n...     )\n...     owt.process_structure(option=\"TW\")\n&gt;&gt;&gt; owt._init_proc\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_structure(self, option=\"full\") -&gt; None:\n    \"\"\"\n    Set dataframe with required properties to model the tower.\n\n    Sets dataframe containing the required properties to model the\n    tower geometry, including the RNA system.\n\n    Parameters\n    ----------\n    option : str, optional\n        Option to process the data for a specific subassembly.\n        Possible values:\n\n        - \"full\": To process all the data for all subassemblies.\n        - \"tower\": To process only the data for the tower\n          subassembly.\n        - \"TP\": To process only the data for the transition piece\n          subassembly.\n        - \"monopile\": To process only the data for the monopile\n          foundation subassembly.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from contextlib import ExitStack\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n    &gt;&gt;&gt; def _set_subassemblies(self, subassemblies):\n    ...     self.sub_assemblies = {}\n    &gt;&gt;&gt; def _set_members(self):\n    ...     return None\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     OWT,\n    ...     \"_set_subassemblies\",\n    ...     _set_subassemblies,\n    ... ), mock.patch.object(OWT, \"_set_members\", _set_members):\n    ...     owt = OWT(\n    ...         api=object(),\n    ...         materials=pd.DataFrame(),\n    ...         subassemblies=pd.DataFrame(),\n    ...         location=location,\n    ...     )\n    &gt;&gt;&gt; empty_df = pd.DataFrame()\n    &gt;&gt;&gt; with ExitStack() as stack:\n    ...     _ = stack.enter_context(mock.patch.object(OWT, \"process_rna\"))\n    ...     _ = stack.enter_context(\n    ...         mock.patch.object(\n    ...             OWT,\n    ...             \"process_structure_geometry\",\n    ...             return_value=empty_df,\n    ...         )\n    ...     )\n    ...     _ = stack.enter_context(\n    ...         mock.patch.object(\n    ...             OWT,\n    ...             \"process_lumped_masses\",\n    ...             return_value=empty_df,\n    ...         )\n    ...     )\n    ...     _ = stack.enter_context(\n    ...         mock.patch.object(\n    ...             OWT,\n    ...             \"process_distributed_lumped_masses\",\n    ...             return_value=empty_df,\n    ...         )\n    ...     )\n    ...     owt.process_structure(option=\"TW\")\n    &gt;&gt;&gt; owt._init_proc\n    True\n    \"\"\"\n    self._init_proc = True\n    if option == \"full\":\n        self.process_rna()\n        self.tower = self.process_structure_geometry(\"tw\")\n        self.transition_piece = self.process_structure_geometry(\"tp\")\n        self.monopile = self.process_structure_geometry(\"mp\")\n        self.tw_lumped_mass = self.process_lumped_masses(\"TW\")\n        self.tp_lumped_mass = self.process_lumped_masses(\"TP\")\n        self.mp_lumped_mass = self.process_lumped_masses(\"MP\")\n        self.tp_distributed_mass = self.process_distributed_lumped_masses(\"TP\")\n        self.mp_distributed_mass = self.process_distributed_lumped_masses(\"MP\")\n        self.grout = self.process_distributed_lumped_masses(\"grout\")\n    elif option == \"TW\":\n        self.process_rna()\n        self.tower = self.process_structure_geometry(\"tw\")\n        self.tw_lumped_mass = self.process_lumped_masses(\"TW\")\n    elif option == \"TP\":\n        self.transition_piece = self.process_structure_geometry(\"tp\")\n        self.tp_lumped_mass = self.process_lumped_masses(\"TP\")\n        self.tp_distributed_mass = self.process_distributed_lumped_masses(\"TP\")\n        self.grout = self.process_distributed_lumped_masses(\"grout\")\n    elif option == \"MP\":\n        self.monopile = self.process_structure_geometry(\"mp\")\n        self.mp_lumped_mass = self.process_lumped_masses(\"MP\")\n        self.mp_distributed_mass = self.process_distributed_lumped_masses(\"MP\")\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.can_adjust_properties","title":"can_adjust_properties  <code>staticmethod</code>","text":"<pre><code>can_adjust_properties(row)\n</code></pre> <p>Recalculate can properties based on section and elevations.</p> <p>Recalculation of can properties based on section properties and can elevations: height [m], volume [m3], mass [t], rho [t/m].</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>Series</code> <p>Original can properties.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Pandas series of recalculated can properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; row = pd.Series(\n...     {\n...         \"Mass [t]\": 10.0,\n...         \"Volume [m3]\": 5.0,\n...         \"Elevation from [mLAT]\": 10.0,\n...         \"Elevation to [mLAT]\": 0.0,\n...         \"Diameter from [m]\": 6.0,\n...         \"Diameter to [m]\": 6.0,\n...         \"Wall thickness [mm]\": 10.0,\n...     }\n... )\n&gt;&gt;&gt; out = OWT.can_adjust_properties(row)\n&gt;&gt;&gt; float(out[\"Height [m]\"])\n10.0\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>@staticmethod\ndef can_adjust_properties(row: pd.Series) -&gt; pd.Series:\n    \"\"\"\n    Recalculate can properties based on section and elevations.\n\n    Recalculation of can properties based on section properties and\n    can elevations: height [m], volume [m3], mass [t], rho [t/m].\n\n    Parameters\n    ----------\n    row : pd.Series\n        Original can properties.\n\n    Returns\n    -------\n    pd.Series\n        Pandas series of recalculated can properties.\n\n    Examples\n    --------\n    &gt;&gt;&gt; row = pd.Series(\n    ...     {\n    ...         \"Mass [t]\": 10.0,\n    ...         \"Volume [m3]\": 5.0,\n    ...         \"Elevation from [mLAT]\": 10.0,\n    ...         \"Elevation to [mLAT]\": 0.0,\n    ...         \"Diameter from [m]\": 6.0,\n    ...         \"Diameter to [m]\": 6.0,\n    ...         \"Wall thickness [mm]\": 10.0,\n    ...     }\n    ... )\n    &gt;&gt;&gt; out = OWT.can_adjust_properties(row)\n    &gt;&gt;&gt; float(out[\"Height [m]\"])\n    10.0\n    \"\"\"\n    density = row[\"Mass [t]\"] / row[\"Volume [m3]\"]\n    height = row[\"Elevation from [mLAT]\"] - row[\"Elevation to [mLAT]\"]\n    r1 = row[\"Diameter from [m]\"] / 2\n    r2 = row[\"Diameter to [m]\"] / 2\n    volume_out = 1 / 3 * np.pi * (r1**2 + r1 * r2 + r2**2) * height\n    wall_thickness = row[\"Wall thickness [mm]\"] * 1e-3\n    r1 = r1 - wall_thickness\n    r2 = r2 - wall_thickness\n    volume_in = 1 / 3 * np.pi * (r1**2 + r1 * r2 + r2**2) * height\n    volume = volume_out - volume_in\n    mass = volume * density\n    rho_m = mass / height\n    can_properties = pd.Series(\n        data=[height, volume, mass, rho_m],\n        index=[\"Height [m]\", \"Volume [m3]\", \"Mass [t]\", \"rho [t/m]\"],\n    )\n    return can_properties\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.can_modification","title":"can_modification","text":"<pre><code>can_modification(df, altitude, position='bottom')\n</code></pre> <p>Change can properties based on the altitude.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe containing the can properties.</p> required <code>altitude</code> <code>float64 or None</code> <p>Altitude in mLAT.</p> required <code>position</code> <code>str</code> <p>Position of the can with respect to the altitude with possible values: \"bottom\" or \"top\", default is \"bottom\".</p> <code>'bottom'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with the modified can properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame(\n...     {\n...         \"Elevation from [mLAT]\": [10.0],\n...         \"Elevation to [mLAT]\": [0.0],\n...         \"Diameter from [m]\": [6.0],\n...         \"Diameter to [m]\": [6.0],\n...         \"Wall thickness [mm]\": [10.0],\n...         \"Volume [m3]\": [5.0],\n...         \"Mass [t]\": [10.0],\n...         \"rho [t/m]\": [1.0],\n...     },\n...     index=[\"A\"],\n... )\n&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; helper = SimpleNamespace(can_adjust_properties=OWT.can_adjust_properties)\n&gt;&gt;&gt; out = OWT.can_modification(helper, df.copy(), np.float64(5.0))\n&gt;&gt;&gt; float(out[\"Elevation to [mLAT]\"].iloc[0])\n5.0\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def can_modification(\n    self,\n    df: pd.DataFrame,\n    altitude: Union[np.float64, float, None],\n    position: str = \"bottom\",\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Change can properties based on the altitude.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe containing the can properties.\n    altitude : np.float64 or None\n        Altitude in mLAT.\n    position : str, optional\n        Position of the can with respect to the altitude with\n        possible values: \"bottom\" or \"top\", default is \"bottom\".\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with the modified can properties.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame(\n    ...     {\n    ...         \"Elevation from [mLAT]\": [10.0],\n    ...         \"Elevation to [mLAT]\": [0.0],\n    ...         \"Diameter from [m]\": [6.0],\n    ...         \"Diameter to [m]\": [6.0],\n    ...         \"Wall thickness [mm]\": [10.0],\n    ...         \"Volume [m3]\": [5.0],\n    ...         \"Mass [t]\": [10.0],\n    ...         \"rho [t/m]\": [1.0],\n    ...     },\n    ...     index=[\"A\"],\n    ... )\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; helper = SimpleNamespace(can_adjust_properties=OWT.can_adjust_properties)\n    &gt;&gt;&gt; out = OWT.can_modification(helper, df.copy(), np.float64(5.0))\n    &gt;&gt;&gt; float(out[\"Elevation to [mLAT]\"].iloc[0])\n    5.0\n    \"\"\"\n    if position == \"bottom\":\n        ind = -1\n        _col = \" to \"\n    else:\n        ind = 0\n        _col = \" from \"\n    altitude_val = float(altitude) if altitude is not None else float(\"nan\")\n    row_index = df.index[ind]\n    df.loc[row_index, \"Elevation\" + _col + \"[mLAT]\"] = altitude_val\n    col_elev_from = df.columns.get_loc(\"Elevation from [mLAT]\")\n    col_elev_to = df.columns.get_loc(\"Elevation to [mLAT]\")\n    col_diam_from = df.columns.get_loc(\"Diameter from [m]\")\n    col_diam_to = df.columns.get_loc(\"Diameter to [m]\")\n    if not isinstance(col_elev_from, int):\n        raise ValueError(\"Expected scalar columns for elevation data.\")\n    if not isinstance(col_elev_to, int):\n        raise ValueError(\"Expected scalar columns for elevation data.\")\n    if not isinstance(col_diam_from, int):\n        raise ValueError(\"Expected scalar columns for diameter data.\")\n    if not isinstance(col_diam_to, int):\n        raise ValueError(\"Expected scalar columns for diameter data.\")\n    elevation = [\n        float(cast(float, df.iat[ind, col_elev_from])),\n        float(cast(float, df.iat[ind, col_elev_to])),\n    ]\n    diameters = [\n        float(cast(float, df.iat[ind, col_diam_from])),\n        float(cast(float, df.iat[ind, col_diam_to])),\n    ]\n    df.loc[row_index, \"Diameter\" + _col + \"[m]\"] = float(\n        np.interp(\n            altitude_val,\n            elevation,\n            diameters,\n        )\n    )\n    cols = [\"Height [m]\", \"Volume [m3]\", \"Mass [t]\", \"rho [t/m]\"]\n    df.loc[df.index[ind], cols] = self.can_adjust_properties(df.iloc[ind])\n    return df\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.assembly_tp_mp","title":"assembly_tp_mp","text":"<pre><code>assembly_tp_mp()\n</code></pre> <p>Process TP structural item to assembly with MP foundation.</p> <p>Processes TP structural item to assembly with MP foundation ensuring continuity. TP skirt is processed as well.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If TP or MP items need to be processed before.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     transition_piece=None,\n...     monopile=None,\n...     _init_spec_part=False,\n... )\n&gt;&gt;&gt; OWT.assembly_tp_mp(helper)\nTraceback (most recent call last):\n    ...\nTypeError: TP or MP items need to be processed before!\n&gt;&gt;&gt; tp = pd.DataFrame(\n...     {\n...         \"Elevation from [mLAT]\": [6.0, 0.0],\n...         \"Elevation to [mLAT]\": [8.0, 4.0],\n...         \"Diameter from [m]\": [6.0, 6.0],\n...         \"Diameter to [m]\": [6.0, 6.0],\n...         \"Wall thickness [mm]\": [10.0, 10.0],\n...         \"Volume [m3]\": [5.0, 5.0],\n...         \"Mass [t]\": [10.0, 10.0],\n...         \"rho [t/m]\": [1.0, 1.0],\n...     }\n... )\n&gt;&gt;&gt; mp = pd.DataFrame(\n...     {\n...         \"Elevation from [mLAT]\": [0.0],\n...         \"Elevation to [mLAT]\": [-10.0],\n...         \"Diameter from [m]\": [6.0],\n...         \"Diameter to [m]\": [6.0],\n...         \"Wall thickness [mm]\": [10.0],\n...         \"Volume [m3]\": [5.0],\n...         \"Mass [t]\": [10.0],\n...         \"rho [t/m]\": [1.0],\n...     }\n... )\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     transition_piece=tp,\n...     monopile=mp,\n...     pile_head=5.0,\n...     substructure=None,\n...     tp_skirt=None,\n...     _init_spec_part=False,\n... )\n&gt;&gt;&gt; helper.can_adjust_properties = OWT.can_adjust_properties\n&gt;&gt;&gt; helper.can_modification = lambda df, altitude, position=\"bottom\": OWT.can_modification(\n...     helper,\n...     df,\n...     altitude,\n...     position=position,\n... )\n&gt;&gt;&gt; OWT.assembly_tp_mp(helper)\n&gt;&gt;&gt; helper.substructure is not None\nTrue\n&gt;&gt;&gt; helper.tp_skirt is not None\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def assembly_tp_mp(self) -&gt; None:\n    \"\"\"\n    Process TP structural item to assembly with MP foundation.\n\n    Processes TP structural item to assembly with MP foundation\n    ensuring continuity. TP skirt is processed as well.\n\n    Raises\n    ------\n    TypeError\n        If TP or MP items need to be processed before.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     transition_piece=None,\n    ...     monopile=None,\n    ...     _init_spec_part=False,\n    ... )\n    &gt;&gt;&gt; OWT.assembly_tp_mp(helper)\n    Traceback (most recent call last):\n        ...\n    TypeError: TP or MP items need to be processed before!\n    &gt;&gt;&gt; tp = pd.DataFrame(\n    ...     {\n    ...         \"Elevation from [mLAT]\": [6.0, 0.0],\n    ...         \"Elevation to [mLAT]\": [8.0, 4.0],\n    ...         \"Diameter from [m]\": [6.0, 6.0],\n    ...         \"Diameter to [m]\": [6.0, 6.0],\n    ...         \"Wall thickness [mm]\": [10.0, 10.0],\n    ...         \"Volume [m3]\": [5.0, 5.0],\n    ...         \"Mass [t]\": [10.0, 10.0],\n    ...         \"rho [t/m]\": [1.0, 1.0],\n    ...     }\n    ... )\n    &gt;&gt;&gt; mp = pd.DataFrame(\n    ...     {\n    ...         \"Elevation from [mLAT]\": [0.0],\n    ...         \"Elevation to [mLAT]\": [-10.0],\n    ...         \"Diameter from [m]\": [6.0],\n    ...         \"Diameter to [m]\": [6.0],\n    ...         \"Wall thickness [mm]\": [10.0],\n    ...         \"Volume [m3]\": [5.0],\n    ...         \"Mass [t]\": [10.0],\n    ...         \"rho [t/m]\": [1.0],\n    ...     }\n    ... )\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     transition_piece=tp,\n    ...     monopile=mp,\n    ...     pile_head=5.0,\n    ...     substructure=None,\n    ...     tp_skirt=None,\n    ...     _init_spec_part=False,\n    ... )\n    &gt;&gt;&gt; helper.can_adjust_properties = OWT.can_adjust_properties\n    &gt;&gt;&gt; helper.can_modification = lambda df, altitude, position=\"bottom\": OWT.can_modification(\n    ...     helper,\n    ...     df,\n    ...     altitude,\n    ...     position=position,\n    ... )\n    &gt;&gt;&gt; OWT.assembly_tp_mp(helper)\n    &gt;&gt;&gt; helper.substructure is not None\n    True\n    &gt;&gt;&gt; helper.tp_skirt is not None\n    True\n    \"\"\"\n    self._init_spec_part = True\n    if (self.transition_piece is not None) and (self.monopile is not None):\n        mp_head = self.pile_head\n        tp = self.transition_piece\n        df = deepcopy(tp[tp[\"Elevation from [mLAT]\"] &gt; mp_head])\n        if df.loc[df.index[0], \"Elevation to [mLAT]\"] != mp_head:\n            # Not bolted connection (i.e. Rentel) preprocessing needed\n            tp1 = self.can_modification(df, mp_head, position=\"bottom\")\n            self.substructure = pd.concat([tp1, deepcopy(self.monopile)])\n        else:\n            # Bolted connection, nothing to do\n            self.substructure = pd.concat([df, deepcopy(self.monopile)])\n        df = deepcopy(tp[tp[\"Elevation to [mLAT]\"] &lt; mp_head])\n        self.tp_skirt = self.can_modification(df, mp_head, position=\"top\")\n    else:\n        raise TypeError(\"TP or MP items need to be processed before!\")\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.assembly_full_structure","title":"assembly_full_structure","text":"<pre><code>assembly_full_structure()\n</code></pre> <p>Process the full structure of the OWT.</p> <p>Processes the full structure of the OWT: tower + tp combination with monopile.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If tower or substructure needs to be processed before.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     substructure=pd.DataFrame({\"Height [m]\": [1.0]}),\n...     tower=pd.DataFrame({\"Height [m]\": [2.0]}),\n...     _init_spec_full=False,\n... )\n&gt;&gt;&gt; OWT.assembly_full_structure(helper)\n&gt;&gt;&gt; float(helper.full_structure[\"Height [m]\"].sum())\n3.0\n&gt;&gt;&gt; helper._init_spec_full\nTrue\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     substructure=None,\n...     tower=None,\n...     _init_spec_full=False,\n... )\n&gt;&gt;&gt; OWT.assembly_full_structure(helper)\nTraceback (most recent call last):\n    ...\nTypeError: Substructure needs to be processed before!\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     substructure=pd.DataFrame({\"Height [m]\": [1.0]}),\n...     tower=None,\n...     _init_spec_full=False,\n... )\n&gt;&gt;&gt; OWT.assembly_full_structure(helper)\nTraceback (most recent call last):\n    ...\nTypeError: Tower needs to be processed before!\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def assembly_full_structure(self) -&gt; None:\n    \"\"\"\n    Process the full structure of the OWT.\n\n    Processes the full structure of the OWT: tower + tp combination\n    with monopile.\n\n    Raises\n    ------\n    TypeError\n        If tower or substructure needs to be processed before.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     substructure=pd.DataFrame({\"Height [m]\": [1.0]}),\n    ...     tower=pd.DataFrame({\"Height [m]\": [2.0]}),\n    ...     _init_spec_full=False,\n    ... )\n    &gt;&gt;&gt; OWT.assembly_full_structure(helper)\n    &gt;&gt;&gt; float(helper.full_structure[\"Height [m]\"].sum())\n    3.0\n    &gt;&gt;&gt; helper._init_spec_full\n    True\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     substructure=None,\n    ...     tower=None,\n    ...     _init_spec_full=False,\n    ... )\n    &gt;&gt;&gt; OWT.assembly_full_structure(helper)\n    Traceback (most recent call last):\n        ...\n    TypeError: Substructure needs to be processed before!\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     substructure=pd.DataFrame({\"Height [m]\": [1.0]}),\n    ...     tower=None,\n    ...     _init_spec_full=False,\n    ... )\n    &gt;&gt;&gt; OWT.assembly_full_structure(helper)\n    Traceback (most recent call last):\n        ...\n    TypeError: Tower needs to be processed before!\n    \"\"\"\n    self._init_spec_full = True\n    if self.substructure is not None:\n        if self.tower is not None:\n            self.full_structure = pd.concat([self.tower, self.substructure])\n        else:\n            raise TypeError(\"Tower needs to be processed before!\")\n    else:\n        raise TypeError(\"Substructure needs to be processed before!\")\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.extend_dfs","title":"extend_dfs","text":"<pre><code>extend_dfs()\n</code></pre> <p>Extend the dataframes with the subassembly columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     pile_toe=None,\n...     rna=None,\n...     tower=pd.DataFrame({\"Height [m]\": [1.0]}),\n...     transition_piece=None,\n...     monopile=None,\n...     tw_lumped_mass=None,\n...     tp_lumped_mass=None,\n...     mp_lumped_mass=None,\n...     tp_distributed_mass=None,\n...     mp_distributed_mass=None,\n...     grout=None,\n...     sub_assemblies={},\n...     substructure=None,\n...     tp_skirt=None,\n...     full_structure=None,\n...     _init_spec_part=False,\n...     _init_spec_full=False,\n... )\n&gt;&gt;&gt; OWT.extend_dfs(helper)\n&gt;&gt;&gt; helper.tower[\"Subassembly\"].iloc[0]\n'TW'\n&gt;&gt;&gt; helper.tp_skirt is None\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def extend_dfs(self) -&gt; None:\n    \"\"\"\n    Extend the dataframes with the subassembly columns.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     pile_toe=None,\n    ...     rna=None,\n    ...     tower=pd.DataFrame({\"Height [m]\": [1.0]}),\n    ...     transition_piece=None,\n    ...     monopile=None,\n    ...     tw_lumped_mass=None,\n    ...     tp_lumped_mass=None,\n    ...     mp_lumped_mass=None,\n    ...     tp_distributed_mass=None,\n    ...     mp_distributed_mass=None,\n    ...     grout=None,\n    ...     sub_assemblies={},\n    ...     substructure=None,\n    ...     tp_skirt=None,\n    ...     full_structure=None,\n    ...     _init_spec_part=False,\n    ...     _init_spec_full=False,\n    ... )\n    &gt;&gt;&gt; OWT.extend_dfs(helper)\n    &gt;&gt;&gt; helper.tower[\"Subassembly\"].iloc[0]\n    'TW'\n    &gt;&gt;&gt; helper.tp_skirt is None\n    True\n    \"\"\"\n    for attr in ATTR_PROC:\n        df = getattr(self, attr)\n        if df is not None:\n            if \"tower\" in attr or \"tw_\" in attr or \"rna\" in attr:\n                df[\"Subassembly\"] = \"TW\"\n                setattr(self, attr, df)\n            elif \"tp_\" in attr or \"transition\" in attr or \"grout\" in attr:\n                df[\"Subassembly\"] = \"TP\"\n                setattr(self, attr, df)\n            elif \"mp_\" in attr or \"monopile\" in attr:\n                df[\"Subassembly\"] = \"MP\"\n                setattr(self, attr, df)\n    if \"TP\" in self.sub_assemblies and \"MP\" in self.sub_assemblies:\n        self.assembly_tp_mp()\n    else:\n        self._init_spec_part = True\n        self.tp_skirt = None\n    if \"TW\" in self.sub_assemblies:\n        self._init_spec_full = True\n        if self.substructure is not None:\n            self.assembly_full_structure()\n        else:\n            self.full_structure = None\n    else:\n        self.full_structure = None\n        self._init_spec_full = True\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWT.transform_monopile_geometry","title":"transform_monopile_geometry","text":"<pre><code>transform_monopile_geometry(cutoff_point=nan)\n</code></pre> <p>Return a dataframe with monopile geometry.</p> <p>Returns a dataframe with the monopile geometry with the mudline as reference.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff_point</code> <code>floating</code> <p>Depth from the mudline to cut the monopile geometry.</p> <code>nan</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with the monopile geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If monopile subassembly data not found.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>@typing.no_type_check\ndef transform_monopile_geometry(\n    self,\n    cutoff_point: np.floating = np.nan,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Return a dataframe with monopile geometry.\n\n    Returns a dataframe with the monopile geometry with the mudline\n    as reference.\n\n    Parameters\n    ----------\n    cutoff_point : np.floating, optional\n        Depth from the mudline to cut the monopile geometry.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with the monopile geometry.\n\n    Raises\n    ------\n    ValueError\n        If monopile subassembly data not found.\n    \"\"\"\n    toe_depth_lat = self.sub_assemblies[\"MP\"].position.z\n    penetration = -((1e-3 * toe_depth_lat) - self.water_depth)\n    pile = pd.DataFrame()\n    if self.mp_sub_assemblies is not None:\n        df = self.mp_sub_assemblies.copy()\n    else:\n        raise ValueError(\"Monopile subassembly data not found.\")\n    df.reset_index(inplace=True)\n    for i, row in df.iterrows():\n        if i != 0:\n            pile.loc[i, \"Elevation from [m]\"] = penetration - 1e-3 * df[\"z\"].iloc[i - 1]\n            pile.loc[i, \"Elevation to [m]\"] = penetration - 1e-3 * row[\"z\"]\n            pile.loc[i, \"Pile material\"] = self.sub_assemblies[\"MP\"].bb[0].material.title\n            pile.loc[i, \"Pile material submerged unit weight [kN/m3]\"] = (\n                1e-2 * self.sub_assemblies[\"MP\"].bb[0].material.density - 10\n            )\n            pile.loc[i, \"Wall thickness [mm]\"] = row[\"wall_thickness\"]\n            bot_od = row[\"OD\"].split(\"/\")[0] if \"/\" in row[\"OD\"] else row[\"OD\"]\n            top_od = row[\"OD\"].split(\"/\")[1] if \"/\" in row[\"OD\"] else row[\"OD\"]\n            pile.loc[i, \"Diameter [m]\"] = 1e-3 * 0.5 * (float(bot_od) + float(top_od))\n            pile.loc[i, \"Youngs modulus [GPa]\"] = self.sub_assemblies[\"MP\"].bb[0].material.young_modulus\n            pile.loc[i, \"Poissons ratio [-]\"] = self.sub_assemblies[\"MP\"].bb[0].material.poisson_ratio\n    if not np.isnan(cutoff_point):\n        pile = pile.loc[pile[\"Elevation to [m]\"] &gt; cutoff_point].reset_index(drop=True)\n        pile.loc[0, \"Elevation from [m]\"] = cutoff_point\n    return pile\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWTs","title":"OWTs","text":"<pre><code>OWTs(turbines, owts)\n</code></pre> <p>Class to process the geometry data of multiple OWTs.</p> <p>:param owts: List of OWT objects. :param api: API object used to call get_* methods. :param materials: Pandas dataframe with the materials data. :param sub_assemblies: Dictionary of dictionaries of the subassemblies for each turbine. :param tower_base: Dictionary of the elevation of the OWT tower base in mLAT for each turbine. :param pile_head: Dictionary of the elevation of the pile head in mLAT for each turbine. :param water_depth: Dictionary of the water depth in mLAT for each turbine. :param tw_sub_assemblies: Dataframe of the tower subassemblies data from each turbine. :param tp_sub_assemblies: Dataframe of the transition piece subassemblies data from each turbine. :param mp_sub_assemblies: Dataframe of the monopile subassemblies data from each turbine. :param pile_toe: Dataframe of the elevation of the pile toe in mLAT from each turbine. :param rna: Dataframe of the RNA data from each turbine. :param tower: Dataframe of the tower data from each turbine. :param transition_piece: Dataframe of the transition piece data from each turbine. :param monopile: Dataframe of the monopile data from each turbine. :param tw_lumped_mass: Dataframe of the lumped masses data of the tower from each turbine. :param tp_lumped_mass: Dataframe of the lumped masses data of the transition piece from each turbine. :param mp_lumped_mass: Dataframe of the lumped masses data of the monopile from each turbine. :param tp_distributed_mass: Dataframe of the distributed masses data of the transition piece from each turbine. :param mp_distributed_mass: Dataframe of the distributed masses data of the monopile from each turbine. :param grout: Dataframe of the grout data from each turbine. :param full_structure: Dataframe of the full structure data from each turbine. :param tp_skirt: Dataframe of the transition piece skirt data from each turbine. :param substructure: Dataframe of the substructure data from each turbine. :param all_turbines: Dataframe of the general geometry data from each turbine. :param all_tubular_structures: Dataframe of the tubular structures data from each turbine. :param all_distributed_mass: Dataframe of the distributed masses data from each turbine. :param all_lumped_mass: Dataframe of the lumped masses data from each turbine.</p> <p>Create an instance of the OWTs class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>turbines</code> <code>list of str</code> <p>List of turbine titles.</p> required <code>owts</code> <code>list of OWT</code> <p>List of OWT objects.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; stub = SimpleNamespace(\n...     api=\"api\",\n...     materials=\"materials\",\n...     sub_assemblies={},\n...     tower_base=0.0,\n...     pile_head=0.0,\n...     water_depth=0.0,\n...     tw_sub_assemblies=None,\n...     tp_sub_assemblies=None,\n...     mp_sub_assemblies=None,\n... )\n&gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n&gt;&gt;&gt; owts.api\n'api'\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def __init__(\n    self,\n    turbines: list[str],\n    owts: list[OWT],\n) -&gt; None:\n    \"\"\"\n    Create an instance of the OWTs class with required parameters.\n\n    Parameters\n    ----------\n    turbines : list of str\n        List of turbine titles.\n    owts : list of OWT\n        List of OWT objects.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; stub = SimpleNamespace(\n    ...     api=\"api\",\n    ...     materials=\"materials\",\n    ...     sub_assemblies={},\n    ...     tower_base=0.0,\n    ...     pile_head=0.0,\n    ...     water_depth=0.0,\n    ...     tw_sub_assemblies=None,\n    ...     tp_sub_assemblies=None,\n    ...     mp_sub_assemblies=None,\n    ... )\n    &gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n    &gt;&gt;&gt; owts.api\n    'api'\n    \"\"\"\n    self.owts = dict(zip(turbines, owts))\n    self.api = self.owts[turbines[0]].api\n    self.materials = self.owts[turbines[0]].materials\n    for attr in [\n        \"sub_assemblies\",\n        \"tower_base\",\n        \"pile_head\",\n        \"water_depth\",\n    ]:\n        dict_ = {k: getattr(owt, attr) for k, owt in zip(turbines, self.owts.values())}\n        setattr(self, attr, dict_)\n    for attr in [\n        \"tw_sub_assemblies\",\n        \"tp_sub_assemblies\",\n        \"mp_sub_assemblies\",\n    ]:\n        sa_turb_list = [getattr(owt, attr) for owt in self.owts.values() if getattr(owt, attr) is not None]\n        df = None if sa_turb_list == [] else pd.concat(sa_turb_list)\n        setattr(self, attr, df)\n    for attr in ATTR_PROC:\n        setattr(self, attr, [])\n    for attr in ATTR_SPEC:\n        setattr(self, attr, [])\n    for attr in ATTR_FULL:\n        setattr(self, attr, [])\n    self._init = False\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWTs-functions","title":"Functions","text":""},{"location":"api/geometry/#owi.metadatabase.geometry.OWTs.process_structures","title":"process_structures","text":"<pre><code>process_structures()\n</code></pre> <p>Set dataframes with required properties to model the tower.</p> <p>Sets dataframes containing the required properties to model the tower geometry, including the RNA system.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; stub = SimpleNamespace(\n...     api=\"api\",\n...     materials=\"materials\",\n...     sub_assemblies={\"TW\": 1, \"TP\": 1, \"MP\": 1},\n...     tower_base=0.0,\n...     pile_head=0.0,\n...     water_depth=0.0,\n...     tw_sub_assemblies=None,\n...     tp_sub_assemblies=None,\n...     mp_sub_assemblies=None,\n...     process_structure=lambda *args, **kwargs: None,\n...     extend_dfs=lambda *args, **kwargs: None,\n...     pile_toe=0.0,\n...     rna=None,\n...     tower=None,\n...     transition_piece=None,\n...     monopile=None,\n...     tw_lumped_mass=None,\n...     tp_lumped_mass=None,\n...     mp_lumped_mass=None,\n...     tp_distributed_mass=None,\n...     mp_distributed_mass=None,\n...     grout=None,\n...     full_structure=None,\n...     tp_skirt=None,\n...     substructure=None,\n...     all_tubular_structures=None,\n...     all_distributed_mass=None,\n...     all_lumped_mass=None,\n...     all_turbines=None,\n... )\n&gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n&gt;&gt;&gt; with mock.patch.object(OWTs, \"_concat_list\", lambda self, attrs: None), mock.patch.object(\n...     OWTs, \"_assembly_turbine\", lambda self: None\n... ):\n...     owts.process_structures()\n&gt;&gt;&gt; owts._init\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_structures(self) -&gt; None:\n    \"\"\"\n    Set dataframes with required properties to model the tower.\n\n    Sets dataframes containing the required properties to model the\n    tower geometry, including the RNA system.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; stub = SimpleNamespace(\n    ...     api=\"api\",\n    ...     materials=\"materials\",\n    ...     sub_assemblies={\"TW\": 1, \"TP\": 1, \"MP\": 1},\n    ...     tower_base=0.0,\n    ...     pile_head=0.0,\n    ...     water_depth=0.0,\n    ...     tw_sub_assemblies=None,\n    ...     tp_sub_assemblies=None,\n    ...     mp_sub_assemblies=None,\n    ...     process_structure=lambda *args, **kwargs: None,\n    ...     extend_dfs=lambda *args, **kwargs: None,\n    ...     pile_toe=0.0,\n    ...     rna=None,\n    ...     tower=None,\n    ...     transition_piece=None,\n    ...     monopile=None,\n    ...     tw_lumped_mass=None,\n    ...     tp_lumped_mass=None,\n    ...     mp_lumped_mass=None,\n    ...     tp_distributed_mass=None,\n    ...     mp_distributed_mass=None,\n    ...     grout=None,\n    ...     full_structure=None,\n    ...     tp_skirt=None,\n    ...     substructure=None,\n    ...     all_tubular_structures=None,\n    ...     all_distributed_mass=None,\n    ...     all_lumped_mass=None,\n    ...     all_turbines=None,\n    ... )\n    &gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n    &gt;&gt;&gt; with mock.patch.object(OWTs, \"_concat_list\", lambda self, attrs: None), mock.patch.object(\n    ...     OWTs, \"_assembly_turbine\", lambda self: None\n    ... ):\n    ...     owts.process_structures()\n    &gt;&gt;&gt; owts._init\n    True\n    \"\"\"\n    attr_list = ATTR_PROC + ATTR_SPEC + ATTR_FULL\n    attr_list.remove(\"all_turbines\")\n    if self._init:\n        return\n    self._init = True\n    for owt in self.owts.values():\n        if len(owt.sub_assemblies) != 3:\n            for sa in owt.sub_assemblies.keys():  # noqa: SIM118\n                owt.process_structure(option=sa)\n        else:\n            owt.process_structure()\n        owt.extend_dfs()\n        for attr in attr_list:\n            if attr == \"pile_toe\":\n                pile_toe_list = cast(list[Union[np.float64, float, None]], self.pile_toe)\n                pile_toe_list.append(getattr(owt, attr))\n                self.pile_toe = pile_toe_list\n            elif attr == \"all_tubular_structures\":\n                self.all_tubular_structures.extend([owt.tower, owt.transition_piece, owt.monopile])\n            elif attr == \"all_distributed_mass\":\n                self.all_distributed_mass.extend(\n                    [\n                        owt.tp_distributed_mass,\n                        owt.grout,\n                        owt.mp_distributed_mass,\n                    ]\n                )\n            elif attr == \"all_lumped_mass\":\n                if isinstance(owt.rna, pd.DataFrame):\n                    cols = [\n                        \"X [m]\",\n                        \"Y [m]\",\n                        \"Z [mLAT]\",\n                        \"Mass [t]\",\n                        \"Description\",\n                        \"Subassembly\",\n                    ]\n                    rna_ = owt.rna[cols]\n                else:\n                    rna_ = owt.rna\n                self.all_lumped_mass.extend(\n                    [\n                        rna_,\n                        owt.tw_lumped_mass,\n                        owt.tp_lumped_mass,\n                        owt.mp_lumped_mass,\n                    ]\n                )\n            else:\n                attr_val = getattr(self, attr)\n                owt_attr_val = getattr(owt, attr)\n                attr_val.append(owt_attr_val)\n    attr_list.remove(\"pile_toe\")\n    self.pile_toe = dict(zip(self.owts.keys(), self.pile_toe))\n    self._concat_list(attr_list)\n    self._assembly_turbine()\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.OWTs.select_owt","title":"select_owt","text":"<pre><code>select_owt(turbine)\n</code></pre> <p>Select OWT object from the OWTs object.</p> <p>Parameters:</p> Name Type Description Default <code>turbine</code> <code>str or int</code> <p>Title of the turbine or its index in the original list of turbine titles (from get method).</p> required <p>Returns:</p> Type Description <code>OWT</code> <p>OWT object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If turbine must be specified as single turbine title or its index from the get method input turbine list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; stub = SimpleNamespace(\n...     api=\"api\",\n...     materials=\"materials\",\n...     sub_assemblies={},\n...     tower_base=0.0,\n...     pile_head=0.0,\n...     water_depth=0.0,\n...     tw_sub_assemblies=None,\n...     tp_sub_assemblies=None,\n...     mp_sub_assemblies=None,\n... )\n&gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n&gt;&gt;&gt; owts.select_owt(\"T01\") is stub\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def select_owt(self, turbine: Union[str, int]) -&gt; OWT:\n    \"\"\"\n    Select OWT object from the OWTs object.\n\n    Parameters\n    ----------\n    turbine : str or int\n        Title of the turbine or its index in the original list of\n        turbine titles (from get method).\n\n    Returns\n    -------\n    OWT\n        OWT object.\n\n    Raises\n    ------\n    ValueError\n        If turbine must be specified as single turbine title or\n        its index from the get method input turbine list.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; stub = SimpleNamespace(\n    ...     api=\"api\",\n    ...     materials=\"materials\",\n    ...     sub_assemblies={},\n    ...     tower_base=0.0,\n    ...     pile_head=0.0,\n    ...     water_depth=0.0,\n    ...     tw_sub_assemblies=None,\n    ...     tp_sub_assemblies=None,\n    ...     mp_sub_assemblies=None,\n    ... )\n    &gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n    &gt;&gt;&gt; owts.select_owt(\"T01\") is stub\n    True\n    \"\"\"\n    if isinstance(turbine, int):\n        return self.owts[list(self.owts.keys())[turbine]]\n    elif isinstance(turbine, str):\n        return self.owts[turbine]\n    else:\n        raise ValueError(\n            \"You must specify a single turbine title or \\\n            its index from the the get method input turbine list.\"\n        )\n</code></pre>"},{"location":"api/geometry/#geometryio-api-client","title":"geometry.io - API Client","text":""},{"location":"api/geometry/#owi.metadatabase.geometry.io","title":"io","text":"<p>Module to connect to the database API to retrieve and operate on geometry data.</p>"},{"location":"api/geometry/#owi.metadatabase.geometry.io-classes","title":"Classes","text":""},{"location":"api/geometry/#owi.metadatabase.geometry.io.GeometryAPI","title":"GeometryAPI","text":"<pre><code>GeometryAPI(api_subdir='/geometry/userroutes/', **kwargs)\n</code></pre> <p>               Bases: <code>API</code></p> <p>Class to connect to the geometry data API with methods to retrieve data.</p> <p>Create an instance of the GeometryAPI class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>api_subdir</code> <code>str</code> <p>Subdirectory of the API endpoint url for specific type of data.</p> <code>'/geometry/userroutes/'</code> <code>**kwargs</code> <p>Additional parameters to pass to the API (see the base class).</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; api.api_root.endswith(\"/geometry/userroutes/\")\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def __init__(\n    self,\n    api_subdir: str = \"/geometry/userroutes/\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Create an instance of the GeometryAPI class with required\n    parameters.\n\n    Parameters\n    ----------\n    api_subdir : str, optional\n        Subdirectory of the API endpoint url for specific type of\n        data.\n    **kwargs\n        Additional parameters to pass to the API (see the base\n        class).\n\n    Examples\n    --------\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; api.api_root.endswith(\"/geometry/userroutes/\")\n    True\n    \"\"\"\n    super().__init__(**kwargs)\n    self.loc_api = LocationsAPI(**kwargs)\n    self.api_root = self.api_root + api_subdir\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.io.GeometryAPI-functions","title":"Functions","text":"get_model_definitions \u00b6 <pre><code>get_model_definitions(projectsite=None)\n</code></pre> <p>Get all relevant model definitions.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>Title of the projectsite.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the model definitions</li> <li>\"exists\": Boolean indicating whether matching records   are found</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_model_definitions(projectsite=\"Site\")\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_model_definitions(\n    self,\n    projectsite: Union[str, None] = None,\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get all relevant model definitions.\n\n    Parameters\n    ----------\n    projectsite : str, optional\n        Title of the projectsite.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the model definitions\n        - \"exists\": Boolean indicating whether matching records\n          are found\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = GeometryAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     GeometryAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True}),\n            ... ):\n            ...     out = api.get_model_definitions(projectsite=\"Site\")\n            &gt;&gt;&gt; out[\"exists\"]\n            True\n    \"\"\"\n    url_params = {}\n    if projectsite is not None:\n        url_params[\"site\"] = projectsite\n    url_data_type = \"modeldefinitions\"\n    output_type = \"list\"\n    with self._temp_api_root(self.api_root.replace(\"userroutes\", \"routes\")):\n        df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre> get_modeldefinition_id \u00b6 <pre><code>get_modeldefinition_id(\n    assetlocation=None,\n    projectsite=None,\n    model_definition=None,\n)\n</code></pre> <p>Get the ID of a model definition.</p> <p>Either the asset location or the project site must be specified.</p> <p>Parameters:</p> Name Type Description Default <code>assetlocation</code> <code>str</code> <p>Title of the asset location.</p> <code>None</code> <code>projectsite</code> <code>str</code> <p>Title of the projectsite.</p> <code>None</code> <code>model_definition</code> <code>str</code> <p>Title of the model definition.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"id\": ID of the specified model definition</li> <li>\"multiple_modeldef\": Boolean indicating whether there   are multiple model definitions for the asset location   in general</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If at least one of assetlocation or projectsite is not specified, if no location found, if no model definitions found, if multiple model definitions found without specification, or if specified model definition not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; api.get_modeldefinition_id()\nTraceback (most recent call last):\n    ...\nValueError: At least either of the related ... must be specified!\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_modeldefinition_id(\n    self,\n    assetlocation: Union[str, None] = None,\n    projectsite: Union[str, None] = None,\n    model_definition: Union[str, None] = None,\n) -&gt; dict[str, Union[int, np.int64, bool, None]]:\n    \"\"\"\n    Get the ID of a model definition.\n\n    Either the asset location or the project site must be specified.\n\n    Parameters\n    ----------\n    assetlocation : str, optional\n        Title of the asset location.\n    projectsite : str, optional\n        Title of the projectsite.\n    model_definition : str, optional\n        Title of the model definition.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"id\": ID of the specified model definition\n        - \"multiple_modeldef\": Boolean indicating whether there\n          are multiple model definitions for the asset location\n          in general\n\n    Raises\n    ------\n    ValueError\n        If at least one of assetlocation or projectsite is not\n        specified, if no location found, if no model definitions\n        found, if multiple model definitions found without\n        specification, or if specified model definition not found.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; api.get_modeldefinition_id()  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n        ...\n    ValueError: At least either of the related ... must be specified!\n    \"\"\"\n    if assetlocation is None and projectsite is None:\n        raise ValueError(\"At least either of the related `assetlocation` or `projectsite` must be specified!\")\n\n    result = {}\n    if projectsite is None:\n        if assetlocation is None:\n            raise ValueError(\"Asset location must be specified when projectsite is None.\")\n        location_data = self.loc_api.get_assetlocation_detail(assetlocation=assetlocation)\n        if location_data[\"exists\"]:\n            location = cast(pd.DataFrame, location_data[\"data\"])\n        else:\n            raise ValueError(f\"No location found for asset {assetlocation}.\")\n        projectsite = location[\"projectsite_name\"].loc[0]\n    model_definitions_data = self.get_model_definitions(projectsite=projectsite)\n    if model_definitions_data[\"exists\"]:\n        model_definitions = cast(pd.DataFrame, model_definitions_data[\"data\"])\n    else:\n        raise ValueError(f\"No model definitions found for project site {projectsite}.\")\n    if model_definition is None and len(model_definitions) &gt; 1:\n        raise ValueError(\n            f\"Multiple model definitions found for project site {projectsite}. Please specify which one to use.\"\n        )\n    if model_definition is None:\n        model_definition_id = model_definitions[\"id\"].values[0]\n        result[\"id\"] = model_definition_id\n        result[\"multiple_modeldef\"] = False\n    else:\n        matching_definitions = model_definitions[model_definitions[\"title\"] == model_definition]\n        if matching_definitions.empty:\n            raise ValueError(f\"Model definition '{model_definition}' not found for project site {projectsite}.\")\n        if len(matching_definitions) &gt; 1:\n            raise ValueError(\n                f\"Multiple model definitions found for '{model_definition}' in project site {projectsite}.\\n\"\n                f\"Please check the data consistency.\"\n            )\n        model_definition_id = matching_definitions[\"id\"].values[0]\n        result[\"id\"] = model_definition_id\n        result[\"multiple_modeldef\"] = len(model_definitions) &gt; 1\n    return result\n</code></pre> get_subassemblies \u00b6 <pre><code>get_subassemblies(\n    projectsite=None,\n    assetlocation=None,\n    subassembly_type=None,\n    model_definition=None,\n)\n</code></pre> <p>Get all relevant structure subassemblies.</p> <p>If you specify a model definition, you also must specify either the projectsite or the asset location.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>Title of the projectsite.</p> <code>None</code> <code>assetlocation</code> <code>str</code> <p>Title of the asset location.</p> <code>None</code> <code>subassembly_type</code> <code>str</code> <p>Type of the subassembly.</p> <code>None</code> <code>model_definition</code> <code>str</code> <p>Title of the model definition.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the location data for each   project</li> <li>\"exists\": Boolean indicating whether matching records   are found</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If model definition specified without projectsite or assetlocation, or if specified model definition not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n&gt;&gt;&gt; with mock.patch.object(\n...     GeometryAPI,\n...     \"process_data\",\n...     return_value=(df, {\"existance\": True}),\n... ):\n...     out = api.get_subassemblies(projectsite=\"Site\")\n&gt;&gt;&gt; out[\"exists\"]\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_subassemblies(\n    self,\n    projectsite: Union[str, None] = None,\n    assetlocation: Union[str, None] = None,\n    subassembly_type: Union[str, None] = None,\n    model_definition: Union[str, None] = None,\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get all relevant structure subassemblies.\n\n    If you specify a model definition, you also must specify either\n    the projectsite or the asset location.\n\n    Parameters\n    ----------\n    projectsite : str, optional\n        Title of the projectsite.\n    assetlocation : str, optional\n        Title of the asset location.\n    subassembly_type : str, optional\n        Type of the subassembly.\n    model_definition : str, optional\n        Title of the model definition.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the location data for each\n          project\n        - \"exists\": Boolean indicating whether matching records\n          are found\n\n    Raises\n    ------\n    ValueError\n        If model definition specified without projectsite or\n        assetlocation, or if specified model definition not found.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_subassemblies(projectsite=\"Site\")\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n    \"\"\"\n    url_params = {}\n    func_args = {}\n    if projectsite is not None:\n        url_params[\"asset__projectsite__title\"] = projectsite\n        func_args[\"projectsite\"] = projectsite\n    if assetlocation is not None:\n        url_params[\"asset__title\"] = assetlocation\n        func_args[\"assetlocation\"] = assetlocation\n    if subassembly_type is not None:\n        url_params[\"subassembly_type\"] = subassembly_type\n    if model_definition is not None:\n        if projectsite is not None or assetlocation is not None:\n            func_args[\"model_definition\"] = model_definition\n            modeldef_data = self.get_modeldefinition_id(**func_args)\n            if modeldef_data[\"id\"] is not None:\n                url_params[\"model_definition\"] = str(modeldef_data[\"id\"])\n            else:\n                raise ValueError(\n                    f\"No model definition {model_definition} found for project site {projectsite} \"\n                    f\"or asset location {assetlocation}.\"\n                )\n        else:\n            raise ValueError(\n                \"If you specify a model definition, you also must specify either \"\n                \"the projectsite or the asset location!\"\n            )\n    url_data_type = \"subassemblies\"\n    output_type = \"list\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre> get_buildingblocks \u00b6 <pre><code>get_buildingblocks(\n    projectsite=None,\n    assetlocation=None,\n    subassembly_type=None,\n    subassembly_id=None,\n)\n</code></pre> <p>Get all relevant building blocks.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>Title of the projectsite.</p> <code>None</code> <code>assetlocation</code> <code>str</code> <p>Title of the asset location.</p> <code>None</code> <code>subassembly_type</code> <code>str</code> <p>Type of the subassemblies (e.g. 'MP', 'TW', 'TP').</p> <code>None</code> <code>subassembly_id</code> <code>int or int64</code> <p>ID of the subassembly.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the location data for each   project</li> <li>\"exists\": Boolean indicating whether matching records   are found</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_buildingblocks(projectsite=\"Site\")\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_buildingblocks(\n    self,\n    projectsite: Union[str, None] = None,\n    assetlocation: Union[str, None] = None,\n    subassembly_type: Union[str, None] = None,\n    subassembly_id: Union[int, np.int64, None] = None,\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get all relevant building blocks.\n\n    Parameters\n    ----------\n    projectsite : str, optional\n        Title of the projectsite.\n    assetlocation : str, optional\n        Title of the asset location.\n    subassembly_type : str, optional\n        Type of the subassemblies (e.g. 'MP', 'TW', 'TP').\n    subassembly_id : int or np.int64, optional\n        ID of the subassembly.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the location data for each\n          project\n        - \"exists\": Boolean indicating whether matching records\n          are found\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = GeometryAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     GeometryAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True}),\n            ... ):\n            ...     out = api.get_buildingblocks(projectsite=\"Site\")\n            &gt;&gt;&gt; out[\"exists\"]\n            True\n    \"\"\"\n    url_params = {}\n    if projectsite is not None:\n        url_params[\"sub_assembly__asset__projectsite__title\"] = projectsite\n    if assetlocation is not None:\n        url_params[\"sub_assembly__asset__title\"] = assetlocation\n    if subassembly_type is not None:\n        url_params[\"sub_assembly__subassembly_type\"] = subassembly_type\n    if subassembly_id is not None:\n        url_params[\"sub_assembly__id\"] = str(subassembly_id)\n    url_data_type = \"buildingblocks\"\n    output_type = \"list\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre> get_materials \u00b6 <pre><code>get_materials()\n</code></pre> <p>Get all the materials of building blocks.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the location data for each   project</li> <li>\"exists\": Boolean indicating whether matching records   are found</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_materials()\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_materials(\n    self,\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get all the materials of building blocks.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the location data for each\n          project\n        - \"exists\": Boolean indicating whether matching records\n          are found\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = GeometryAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     GeometryAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True}),\n            ... ):\n            ...     out = api.get_materials()\n            &gt;&gt;&gt; out[\"exists\"]\n            True\n    \"\"\"\n    url_params = {}  # type: dict[str, str]\n    url_data_type = \"materials\"\n    output_type = \"list\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre> get_subassembly_objects \u00b6 <pre><code>get_subassembly_objects(\n    turbine, subassembly=None, model_definition_id=None\n)\n</code></pre> <p>Get all subassemblies for a given turbine, divided by type.</p> <p>Parameters:</p> Name Type Description Default <code>turbine</code> <code>str</code> <p>Turbine title.</p> required <code>subassembly</code> <code>str</code> <p>Sub-assembly type (e.g. 'MP', 'TW', 'TP').</p> <code>None</code> <code>model_definition_id</code> <code>int or int64</code> <p>ID of the model definition to filter the subassemblies.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"TW\": SubAssembly object for the tower</li> <li>\"TP\": SubAssembly object for the transition piece</li> <li>\"MP\": SubAssembly object for the monopile</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no subassemblies found for the turbine or if no materials found in the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; materials = pd.DataFrame(\n...     [\n...         {\n...             \"title\": \"Steel\",\n...             \"slug\": \"steel\",\n...             \"id\": np.int64(1),\n...             \"description\": \"\",\n...             \"young_modulus\": np.float64(210000.0),\n...             \"density\": np.float64(7850.0),\n...             \"poisson_ratio\": np.float64(0.3),\n...         }\n...     ]\n... )\n&gt;&gt;&gt; item = {\n...     \"id\": np.int64(1),\n...     \"title\": \"SA_1\",\n...     \"description\": \"\",\n...     \"slug\": \"sa\",\n...     \"x_position\": np.float64(0),\n...     \"y_position\": np.float64(0),\n...     \"z_position\": np.float64(0),\n...     \"vertical_position_reference_system\": \"LAT\",\n...     \"subassembly_type\": \"TW\",\n...     \"source\": \"api\",\n...     \"asset\": np.int64(1),\n...     \"model_definition\": np.int64(1),\n... }\n&gt;&gt;&gt; response = SimpleNamespace(\n...     status_code=200,\n...     reason=\"OK\",\n...     json=lambda: [item],\n... )\n&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; with mock.patch.object(\n...     GeometryAPI,\n...     \"send_request\",\n...     return_value=response,\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"get_materials\",\n...     return_value={\"exists\": True, \"data\": materials},\n... ):\n...     out = api.get_subassembly_objects(\"T01\")\n&gt;&gt;&gt; sorted(out.keys())\n['TW']\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_subassembly_objects(\n    self,\n    turbine: str,\n    subassembly: Union[str, None] = None,\n    model_definition_id: Union[int, np.int64, None] = None,\n) -&gt; dict[str, SubAssembly]:\n    \"\"\"\n    Get all subassemblies for a given turbine, divided by type.\n\n    Parameters\n    ----------\n    turbine : str\n        Turbine title.\n    subassembly : str, optional\n        Sub-assembly type (e.g. 'MP', 'TW', 'TP').\n    model_definition_id : int or np.int64, optional\n        ID of the model definition to filter the subassemblies.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"TW\": SubAssembly object for the tower\n        - \"TP\": SubAssembly object for the transition piece\n        - \"MP\": SubAssembly object for the monopile\n\n    Raises\n    ------\n    ValueError\n        If no subassemblies found for the turbine or if no\n        materials found in the database.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; materials = pd.DataFrame(\n    ...     [\n    ...         {\n    ...             \"title\": \"Steel\",\n    ...             \"slug\": \"steel\",\n    ...             \"id\": np.int64(1),\n    ...             \"description\": \"\",\n    ...             \"young_modulus\": np.float64(210000.0),\n    ...             \"density\": np.float64(7850.0),\n    ...             \"poisson_ratio\": np.float64(0.3),\n    ...         }\n    ...     ]\n    ... )\n    &gt;&gt;&gt; item = {\n    ...     \"id\": np.int64(1),\n    ...     \"title\": \"SA_1\",\n    ...     \"description\": \"\",\n    ...     \"slug\": \"sa\",\n    ...     \"x_position\": np.float64(0),\n    ...     \"y_position\": np.float64(0),\n    ...     \"z_position\": np.float64(0),\n    ...     \"vertical_position_reference_system\": \"LAT\",\n    ...     \"subassembly_type\": \"TW\",\n    ...     \"source\": \"api\",\n    ...     \"asset\": np.int64(1),\n    ...     \"model_definition\": np.int64(1),\n    ... }\n    &gt;&gt;&gt; response = SimpleNamespace(\n    ...     status_code=200,\n    ...     reason=\"OK\",\n    ...     json=lambda: [item],\n    ... )\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"send_request\",\n    ...     return_value=response,\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_materials\",\n    ...     return_value={\"exists\": True, \"data\": materials},\n    ... ):\n    ...     out = api.get_subassembly_objects(\"T01\")\n    &gt;&gt;&gt; sorted(out.keys())\n    ['TW']\n    \"\"\"\n    url_data_type = \"subassemblies\"\n    url_params = {\"asset__title\": turbine}\n    if subassembly is not None:\n        url_params[\"subassembly_type\"] = subassembly\n    if model_definition_id is not None:\n        url_params[\"model_definition\"] = str(model_definition_id)\n    resp = self.send_request(url_data_type, url_params)\n    self.check_request_health(resp)\n    if not resp.json():\n        raise ValueError(\"No subassemblies found for \" + str(turbine))\n\n    material_data = self.get_materials()\n    if material_data[\"exists\"]:\n        materials = material_data[\"data\"]\n    else:\n        raise ValueError(\"No materials found in the database.\")\n\n    subassemblies = {}\n    for item in resp.json():\n        subassembly_type = item[\"subassembly_type\"]\n        subassembly_obj = SubAssembly(materials, item, api_object=self)\n        if subassembly_type in subassemblies:\n            if not isinstance(subassemblies[subassembly_type], list):\n                subassemblies[subassembly_type] = [subassemblies[subassembly_type]]\n            subassemblies[subassembly_type].append(subassembly_obj)\n        else:\n            subassemblies[subassembly_type] = subassembly_obj\n\n    return subassemblies\n</code></pre> get_owt_geometry_processor \u00b6 <pre><code>get_owt_geometry_processor(\n    turbines,\n    model_definition=None,\n    tower_base=None,\n    monopile_head=None,\n)\n</code></pre> <p>Return the required processing class.</p> <p>Will return data even if some turbines have issues given that at least one is fully OK.</p> <p>Parameters:</p> Name Type Description Default <code>turbines</code> <code>str or list of str</code> <p>Title(s) of the turbines.</p> required <code>model_definition</code> <code>str</code> <p>Title of the model definition.</p> <code>None</code> <code>tower_base</code> <code>float or list of float</code> <p>Height(s) of the tower base.</p> <code>None</code> <code>monopile_head</code> <code>float or list of float</code> <p>Height(s) of the monopile head.</p> <code>None</code> <p>Returns:</p> Type Description <code>OWTs</code> <p>Object containing information about all the requested turbines.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no materials found in the database or if all turbines encounter processing errors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; materials = pd.DataFrame({\"id\": [1]})\n&gt;&gt;&gt; location = pd.DataFrame({\"projectsite_name\": [\"Site\"]})\n&gt;&gt;&gt; subassemblies = pd.DataFrame({\"subassembly_type\": [\"TW\"]})\n&gt;&gt;&gt; def _make_owt(*args, **kwargs):\n...     return \"owt\"\n&gt;&gt;&gt; def _make_owts(turbines, owts):\n...     return {\"turbines\": turbines, \"owts\": owts}\n&gt;&gt;&gt; with mock.patch.object(\n...     GeometryAPI,\n...     \"get_materials\",\n...     return_value={\"exists\": True, \"data\": materials},\n... ), mock.patch.object(\n...     api.loc_api,\n...     \"get_assetlocation_detail\",\n...     return_value={\"exists\": True, \"data\": location},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"get_subassemblies\",\n...     return_value={\"exists\": True, \"data\": subassemblies},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"_check_if_need_modeldef\",\n...     return_value=None,\n... ), mock.patch(\n...     \"geometry.io.OWT\",\n...     _make_owt,\n... ), mock.patch(\n...     \"geometry.io.OWTs\",\n...     _make_owts,\n... ):\n...     out = api.get_owt_geometry_processor(\"T01\")\n&gt;&gt;&gt; out[\"turbines\"]\n['T01']\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_owt_geometry_processor(\n    self,\n    turbines: Union[str, list[str]],\n    model_definition: Union[str, None] = None,\n    tower_base: Union[float, list[float], None] = None,\n    monopile_head: Union[float, list[float], None] = None,\n) -&gt; OWTs:\n    \"\"\"\n    Return the required processing class.\n\n    Will return data even if some turbines have issues given that at\n    least one is fully OK.\n\n    Parameters\n    ----------\n    turbines : str or list of str\n        Title(s) of the turbines.\n    model_definition : str, optional\n        Title of the model definition.\n    tower_base : float or list of float, optional\n        Height(s) of the tower base.\n    monopile_head : float or list of float, optional\n        Height(s) of the monopile head.\n\n    Returns\n    -------\n    OWTs\n        Object containing information about all the requested\n        turbines.\n\n    Raises\n    ------\n    ValueError\n        If no materials found in the database or if all turbines\n        encounter processing errors.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; materials = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; location = pd.DataFrame({\"projectsite_name\": [\"Site\"]})\n    &gt;&gt;&gt; subassemblies = pd.DataFrame({\"subassembly_type\": [\"TW\"]})\n    &gt;&gt;&gt; def _make_owt(*args, **kwargs):\n    ...     return \"owt\"\n    &gt;&gt;&gt; def _make_owts(turbines, owts):\n    ...     return {\"turbines\": turbines, \"owts\": owts}\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_materials\",\n    ...     return_value={\"exists\": True, \"data\": materials},\n    ... ), mock.patch.object(\n    ...     api.loc_api,\n    ...     \"get_assetlocation_detail\",\n    ...     return_value={\"exists\": True, \"data\": location},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_subassemblies\",\n    ...     return_value={\"exists\": True, \"data\": subassemblies},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"_check_if_need_modeldef\",\n    ...     return_value=None,\n    ... ), mock.patch(\n    ...     \"geometry.io.OWT\",\n    ...     _make_owt,\n    ... ), mock.patch(\n    ...     \"geometry.io.OWTs\",\n    ...     _make_owts,\n    ... ):\n    ...     out = api.get_owt_geometry_processor(\"T01\")\n    &gt;&gt;&gt; out[\"turbines\"]\n    ['T01']\n    \"\"\"\n    materials_data = self.get_materials()\n    if materials_data[\"exists\"]:\n        materials = cast(pd.DataFrame, materials_data[\"data\"])\n    else:\n        raise ValueError(\"No materials found in the database.\")\n    owts = []\n    successful_turbines = []\n    errors = []\n    turbines = [turbines] if isinstance(turbines, str) else turbines\n    if not isinstance(tower_base, list) and not isinstance(monopile_head, list):\n        tower_base = [tower_base] * len(turbines)  # type: ignore\n        monopile_head = [monopile_head] * len(turbines)  # type: ignore\n    for i, turbine in enumerate(turbines):\n        try:\n            location_data = self.loc_api.get_assetlocation_detail(assetlocation=turbine)\n            if location_data[\"exists\"]:\n                location = cast(pd.DataFrame, location_data[\"data\"])\n            else:\n                raise ValueError(f\"No location found for turbine {turbine}.\")\n            projectsite = location[\"projectsite_name\"].loc[0]\n            subassemblies_data = self.get_subassemblies(\n                projectsite=projectsite,\n                assetlocation=turbine,\n                model_definition=model_definition,\n            )\n            if subassemblies_data[\"exists\"]:\n                subassemblies = subassemblies_data[\"data\"]\n                self._check_if_need_modeldef(subassemblies, turbine)\n            else:\n                raise ValueError(\n                    f\"No subassemblies found for turbine {turbine}. Please check model definition or database data.\"\n                )\n            owts.append(\n                OWT(\n                    self,\n                    materials,\n                    subassemblies,\n                    location,\n                    tower_base[i] if isinstance(tower_base, list) else tower_base,\n                    (monopile_head[i] if isinstance(monopile_head, list) else monopile_head),\n                )\n            )\n            successful_turbines.append(turbine)\n        except ValueError as e:\n            errors.append(str(e))\n    if errors:\n        if successful_turbines:\n            warnings.warn(\n                f\"There were some errors during processing the request. \"\n                f\"But some turbines were processed successfully: {', '.join(successful_turbines)}.\"\n                f\"\\nErrors:\\n\" + \"\\n\".join(errors),\n                stacklevel=2,\n            )\n        else:\n            raise ValueError(\"\\n\".join(errors))\n    return OWTs(successful_turbines, owts)\n</code></pre> get_monopile_pyles \u00b6 <pre><code>get_monopile_pyles(\n    projectsite,\n    assetlocation,\n    cutoff_point=nan,\n    model_definition=None,\n)\n</code></pre> <p>Return a dataframe with the monopile geometry.</p> <p>Uses the mudline as reference.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>Name of the project site.</p> required <code>assetlocation</code> <code>str</code> <p>Name of the wind turbine location.</p> required <code>cutoff_point</code> <code>float</code> <p>Elevation of the load application point in (mLAT) above the mudline.</p> <code>nan</code> <code>model_definition</code> <code>str</code> <p>Title of the model definition.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with the monopile geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no subassemblies or location found for turbine.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; bbs = pd.DataFrame(\n...     [\n...         {\n...             \"z_position\": 0,\n...             \"material_name\": \"Steel\",\n...             \"density\": 7850.0,\n...             \"wall_thickness\": 20.0,\n...             \"bottom_outer_diameter\": 6.0,\n...             \"top_outer_diameter\": 6.0,\n...             \"youngs_modulus\": 210000.0,\n...             \"poissons_ratio\": 0.3,\n...         },\n...         {\n...             \"z_position\": -1000,\n...             \"material_name\": \"Steel\",\n...             \"density\": 7850.0,\n...             \"wall_thickness\": 20.0,\n...             \"bottom_outer_diameter\": 6.0,\n...             \"top_outer_diameter\": 6.0,\n...             \"youngs_modulus\": 210000.0,\n...             \"poissons_ratio\": 0.3,\n...         },\n...     ]\n... )\n&gt;&gt;&gt; sas = pd.DataFrame({\"z_position\": [-50000]})\n&gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n&gt;&gt;&gt; with mock.patch.object(\n...     GeometryAPI,\n...     \"get_buildingblocks\",\n...     return_value={\"exists\": True, \"data\": bbs},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"get_subassemblies\",\n...     return_value={\"exists\": True, \"data\": sas},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"_check_if_need_modeldef\",\n...     return_value=None,\n... ), mock.patch.object(\n...     api.loc_api,\n...     \"get_assetlocation_detail\",\n...     return_value={\"exists\": True, \"data\": location},\n... ):\n...     pile = api.get_monopile_pyles(\"Site\", \"T01\")\n&gt;&gt;&gt; \"Depth from [m]\" in pile.columns\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def get_monopile_pyles(\n    self,\n    projectsite,\n    assetlocation,\n    cutoff_point=np.nan,\n    model_definition: Union[str, None] = None,\n):\n    \"\"\"\n    Return a dataframe with the monopile geometry.\n\n    Uses the mudline as reference.\n\n    Parameters\n    ----------\n    projectsite : str\n        Name of the project site.\n    assetlocation : str\n        Name of the wind turbine location.\n    cutoff_point : float, optional\n        Elevation of the load application point in (mLAT) above the\n        mudline.\n    model_definition : str, optional\n        Title of the model definition.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with the monopile geometry.\n\n    Raises\n    ------\n    ValueError\n        If no subassemblies or location found for turbine.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; bbs = pd.DataFrame(\n    ...     [\n    ...         {\n    ...             \"z_position\": 0,\n    ...             \"material_name\": \"Steel\",\n    ...             \"density\": 7850.0,\n    ...             \"wall_thickness\": 20.0,\n    ...             \"bottom_outer_diameter\": 6.0,\n    ...             \"top_outer_diameter\": 6.0,\n    ...             \"youngs_modulus\": 210000.0,\n    ...             \"poissons_ratio\": 0.3,\n    ...         },\n    ...         {\n    ...             \"z_position\": -1000,\n    ...             \"material_name\": \"Steel\",\n    ...             \"density\": 7850.0,\n    ...             \"wall_thickness\": 20.0,\n    ...             \"bottom_outer_diameter\": 6.0,\n    ...             \"top_outer_diameter\": 6.0,\n    ...             \"youngs_modulus\": 210000.0,\n    ...             \"poissons_ratio\": 0.3,\n    ...         },\n    ...     ]\n    ... )\n    &gt;&gt;&gt; sas = pd.DataFrame({\"z_position\": [-50000]})\n    &gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_buildingblocks\",\n    ...     return_value={\"exists\": True, \"data\": bbs},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_subassemblies\",\n    ...     return_value={\"exists\": True, \"data\": sas},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"_check_if_need_modeldef\",\n    ...     return_value=None,\n    ... ), mock.patch.object(\n    ...     api.loc_api,\n    ...     \"get_assetlocation_detail\",\n    ...     return_value={\"exists\": True, \"data\": location},\n    ... ):\n    ...     pile = api.get_monopile_pyles(\"Site\", \"T01\")\n    &gt;&gt;&gt; \"Depth from [m]\" in pile.columns\n    True\n    \"\"\"\n    # Retrieve the monopile cans\n    bbs = self.get_buildingblocks(\n        projectsite=projectsite,\n        assetlocation=assetlocation,\n        subassembly_type=\"MP\",\n    )\n    # Retrieve the monopile subassembly\n    sas = self.get_subassemblies(\n        projectsite=projectsite,\n        assetlocation=assetlocation,\n        subassembly_type=\"MP\",\n        model_definition=model_definition,\n    )\n    if sas[\"exists\"]:\n        subassemblies = cast(pd.DataFrame, sas[\"data\"])\n        self._check_if_need_modeldef(subassemblies, assetlocation)\n    else:\n        raise ValueError(\n            f\"No subassemblies found for turbine {assetlocation}. Please check model definition or database data.\"\n        )\n    # Water depth\n    location_data = self.loc_api.get_assetlocation_detail(assetlocation=assetlocation, projectsite=projectsite)\n    if location_data[\"exists\"]:\n        location = cast(pd.DataFrame, location_data[\"data\"])\n        water_depth = location[\"elevation\"].values[0]\n    else:\n        raise ValueError(\n            f\"No location found for turbine {assetlocation} and hence no water depth can be retrieved.\"\n        )\n\n    # Calculate the pile penetration\n    sas_df = cast(pd.DataFrame, sas[\"data\"])\n    toe_depth_lat = sas_df[\"z_position\"].iloc[0]\n    penetration = -((1e-3 * toe_depth_lat) - water_depth)\n\n    # Create the pile for subsequent response analysis\n    pile = pd.DataFrame()\n\n    bbs_df = cast(pd.DataFrame, bbs[\"data\"])\n    for index in range(1, len(bbs_df)):\n        prev_row = bbs_df.iloc[index - 1]\n        row = bbs_df.iloc[index]\n        pile.loc[index, \"Depth to [m]\"] = penetration - 1e-3 * float(prev_row.at[\"z_position\"])\n        pile.loc[index, \"Depth from [m]\"] = penetration - 1e-3 * float(row.at[\"z_position\"])\n        pile.loc[index, \"Pile material\"] = str(row.at[\"material_name\"])\n        pile.loc[index, \"Pile material submerged unit weight [kN/m3]\"] = 1e-2 * float(row.at[\"density\"]) - 10\n        pile.loc[index, \"Wall thickness [mm]\"] = float(row.at[\"wall_thickness\"])\n        pile.loc[index, \"Diameter [m]\"] = (\n            1e-3 * 0.5 * (float(row.at[\"bottom_outer_diameter\"]) + float(row.at[\"top_outer_diameter\"]))\n        )\n        pile.loc[index, \"Youngs modulus [GPa]\"] = float(row.at[\"youngs_modulus\"])\n        pile.loc[index, \"Poissons ratio [-]\"] = float(row.at[\"poissons_ratio\"])\n\n    pile.sort_values(\"Depth from [m]\", inplace=True)\n    pile.reset_index(drop=True, inplace=True)\n\n    # Cut off at the mudline\n    if not np.isnan(cutoff_point):\n        pile = pile.loc[pile[\"Depth to [m]\"] &gt; cutoff_point].reset_index(drop=True)\n        pile.loc[0, \"Depth from [m]\"] = cutoff_point\n\n    return pile\n</code></pre> plot_turbines \u00b6 <pre><code>plot_turbines(\n    turbines,\n    figures_per_line=5,\n    return_fig=False,\n    model_definition=None,\n)\n</code></pre> <p>Plot turbines' frontal geometry.</p> <p>Parameters:</p> Name Type Description Default <code>turbines</code> <code>str or list of str</code> <p>Title(s) of the turbines.</p> required <code>figures_per_line</code> <code>int</code> <p>Number of figures per line, default is 5.</p> <code>5</code> <code>return_fig</code> <code>bool</code> <p>Boolean indicating whether to return the figure, default is False.</p> <code>False</code> <code>model_definition</code> <code>str</code> <p>Title of the model definition.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure or None</code> <p>Plotly figure object with selected turbines front profiles (if requested) or nothing.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no materials or subassemblies found in the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; class _StubSubassembly:\n...     def __init__(self, *args, **kwargs):\n...         self.building_blocks = []\n...     def plotly(self):\n...         layout = {\n...             \"scene\": {},\n...             \"yaxis\": {\n...                 \"title\": {\"text\": \"Height , mm\"},\n...                 \"scaleanchor\": \"x\",\n...                 \"scaleratio\": 1,\n...                 \"type\": \"linear\",\n...             },\n...         }\n...         return [], layout\n&gt;&gt;&gt; api = GeometryAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; materials = pd.DataFrame({\"id\": [1]})\n&gt;&gt;&gt; subassemblies = pd.DataFrame({\"subassembly_type\": [\"TW\"]})\n&gt;&gt;&gt; with mock.patch.object(\n...     GeometryAPI,\n...     \"get_materials\",\n...     return_value={\"exists\": True, \"data\": materials},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"get_subassemblies\",\n...     return_value={\"exists\": True, \"data\": subassemblies},\n... ), mock.patch.object(\n...     GeometryAPI,\n...     \"_check_if_need_modeldef\",\n...     return_value=None,\n... ), mock.patch(\n...     \"geometry.io.SubAssembly\",\n...     _StubSubassembly,\n... ):\n...     fig = api.plot_turbines([\"T01\"], return_fig=True)\n&gt;&gt;&gt; fig is not None\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/io.py</code> <pre><code>def plot_turbines(\n    self,\n    turbines: Union[list[str], str],\n    figures_per_line: int = 5,\n    return_fig: bool = False,\n    model_definition: Union[str, None] = None,\n) -&gt; Union[go.Figure, None]:\n    \"\"\"\n    Plot turbines' frontal geometry.\n\n    Parameters\n    ----------\n    turbines : str or list of str\n        Title(s) of the turbines.\n    figures_per_line : int, optional\n        Number of figures per line, default is 5.\n    return_fig : bool, optional\n        Boolean indicating whether to return the figure, default\n        is False.\n    model_definition : str, optional\n        Title of the model definition.\n\n    Returns\n    -------\n    plotly.graph_objects.Figure or None\n        Plotly figure object with selected turbines front profiles\n        (if requested) or nothing.\n\n    Raises\n    ------\n    ValueError\n        If no materials or subassemblies found in the database.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; class _StubSubassembly:\n    ...     def __init__(self, *args, **kwargs):\n    ...         self.building_blocks = []\n    ...     def plotly(self):\n    ...         layout = {\n    ...             \"scene\": {},\n    ...             \"yaxis\": {\n    ...                 \"title\": {\"text\": \"Height , mm\"},\n    ...                 \"scaleanchor\": \"x\",\n    ...                 \"scaleratio\": 1,\n    ...                 \"type\": \"linear\",\n    ...             },\n    ...         }\n    ...         return [], layout\n    &gt;&gt;&gt; api = GeometryAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; materials = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; subassemblies = pd.DataFrame({\"subassembly_type\": [\"TW\"]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_materials\",\n    ...     return_value={\"exists\": True, \"data\": materials},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"get_subassemblies\",\n    ...     return_value={\"exists\": True, \"data\": subassemblies},\n    ... ), mock.patch.object(\n    ...     GeometryAPI,\n    ...     \"_check_if_need_modeldef\",\n    ...     return_value=None,\n    ... ), mock.patch(\n    ...     \"geometry.io.SubAssembly\",\n    ...     _StubSubassembly,\n    ... ):\n    ...     fig = api.plot_turbines([\"T01\"], return_fig=True)\n    &gt;&gt;&gt; fig is not None\n    True\n    \"\"\"\n    materials_data = self.get_materials()\n    if materials_data[\"exists\"]:\n        materials = materials_data[\"data\"]\n    else:\n        raise ValueError(\"No materials found in the database.\")\n    turbines = [turbines] if isinstance(turbines, str) else turbines\n    if len(turbines) &gt; figures_per_line:\n        n_rows = len(turbines) // figures_per_line + 1\n        n_cols = figures_per_line\n        rows = [i for i in range(1, n_rows + 1) for _ in range(n_cols)]\n        cols = [i for _ in range(n_rows) for i in range(1, n_cols + 1)]\n    else:\n        n_rows = 1\n        n_cols = len(turbines)\n        rows = [1 for _ in range(n_cols)]\n        cols = list(range(1, n_cols + 1))\n    autosize = not len(turbines) &lt; 3\n    fig = make_subplots(n_rows, n_cols, subplot_titles=turbines)\n    for i, turbine in enumerate(turbines):\n        subassemblies_data = self.get_subassemblies(\n            assetlocation=turbine,\n            model_definition=model_definition,\n        )\n        if subassemblies_data[\"exists\"]:\n            subassemblies = cast(pd.DataFrame, subassemblies_data[\"data\"])\n            self._check_if_need_modeldef(subassemblies, turbine)\n        else:\n            raise ValueError(\n                f\"No subassemblies found for turbine {turbine}. Please check model definition or database data.\"\n            )\n        for _, sa in subassemblies.iterrows():\n            subassembly = SubAssembly(materials, cast(DataSA, sa.to_dict()), api_object=self)\n            subassembly.building_blocks  # noqa: B018\n            plotly_data = subassembly.plotly()\n            for k in range(len(plotly_data[0])):\n                fig.add_trace(plotly_data[0][k], row=rows[i], col=cols[i])\n        plotly_layout = plotly_data[1]\n        if i &gt; 0:\n            plotly_layout[\"scene\" + str(i + 1)] = plotly_layout[\"scene\"]\n            plotly_layout[\"yaxis\" + str(i + 1)] = plotly_layout[\"yaxis\"]\n            plotly_layout[\"yaxis\" + str(i + 1)][\"scaleanchor\"] = \"x\" + str(i + 1)\n            plotly_layout.pop(\"scene\")\n            plotly_layout.pop(\"yaxis\")\n            plotly_layout[\"yaxis\" + str(i + 1)].pop(\"title\")\n        fig.update_layout(plotly_layout, autosize=autosize)\n    if return_fig:\n        return fig\n    else:\n        fig.show()\n</code></pre> __eq__ \u00b6 <pre><code>__eq__(other)\n</code></pre> <p>Compare two instances of the API class.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Another instance of the API class or a dictionary.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instances are equal, False otherwise.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If comparison is not possible due to incompatible types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api_1 = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; api_2 = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; api_1 == api_2\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Compare two instances of the API class.\n\n    Parameters\n    ----------\n    other : object\n        Another instance of the API class or a dictionary.\n\n    Returns\n    -------\n    bool\n        True if the instances are equal, False otherwise.\n\n    Raises\n    ------\n    AssertionError\n        If comparison is not possible due to incompatible types.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api_1 = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; api_2 = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; api_1 == api_2\n    True\n    \"\"\"\n    if not isinstance(other, (API, dict)):\n        return NotImplemented\n    if isinstance(other, type(self)):\n        comp = deepcompare(self, other)\n        assert comp[0], comp[1]\n    elif isinstance(other, dict):\n        comp = deepcompare(self.__dict__, other)\n        assert comp[0], comp[1]\n    else:\n        raise AssertionError(\"Comparison is not possible due to incompatible types!\")\n    return comp[0]\n</code></pre> send_request \u00b6 <pre><code>send_request(url_data_type, url_params)\n</code></pre> <p>Handle sending appropriate request.</p> <p>Handles sending appropriate request according to the type of authentication.</p> <p>Parameters:</p> Name Type Description Default <code>url_data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <code>url_params</code> <code>Mapping</code> <p>Parameters to send with the request to the database.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>An instance of the Response object.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If neither header nor username and password are defined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; response = SimpleNamespace(status_code=200, reason=\"OK\")\n&gt;&gt;&gt; with mock.patch(\"requests.get\", return_value=response):\n...     api = API(api_root=\"https://example\", token=\"test\")\n...     resp = api.send_request(\"/projects\", {})\n&gt;&gt;&gt; resp is response\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def send_request(\n    self,\n    url_data_type: str,\n    url_params: Mapping[str, Union[str, float, int, Sequence[Union[str, float, int]], None]],\n) -&gt; requests.Response:\n    \"\"\"\n    Handle sending appropriate request.\n\n    Handles sending appropriate request according to the type of\n    authentication.\n\n    Parameters\n    ----------\n    url_data_type : str\n        Type of the data we want to request (according to database\n        model).\n    url_params : Mapping\n        Parameters to send with the request to the database.\n\n    Returns\n    -------\n    requests.Response\n        An instance of the Response object.\n\n    Raises\n    ------\n    InvalidParameterError\n        If neither header nor username and password are defined.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; response = SimpleNamespace(status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; with mock.patch(\"requests.get\", return_value=response):\n    ...     api = API(api_root=\"https://example\", token=\"test\")\n    ...     resp = api.send_request(\"/projects\", {})\n    &gt;&gt;&gt; resp is response\n    True\n    \"\"\"\n    if self.header is not None:\n        response = requests.get(\n            url=self.api_root + url_data_type,\n            headers=self.header,\n            params=url_params,\n        )\n    else:\n        if self.uname is None or self.password is None:\n            e = \"Either self.header or self.uname and self.password must be defined.\"\n            raise InvalidParameterError(e)\n        else:\n            response = requests.get(\n                url=self.api_root + url_data_type,\n                auth=self.auth,\n                params=url_params,\n            )\n    return response\n</code></pre> check_request_health <code>staticmethod</code> \u00b6 <pre><code>check_request_health(resp)\n</code></pre> <p>Check status code of the response and provide details.</p> <p>Checks status code of the response to request and provides details if unexpected.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>Instance of the Response object.</p> required <p>Raises:</p> Type Description <code>APIConnectionError</code> <p>If response status code is not 200.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; ok = SimpleNamespace(status_code=200, reason=\"OK\")\n&gt;&gt;&gt; API.check_request_health(ok)\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef check_request_health(resp: requests.Response) -&gt; None:\n    \"\"\"\n    Check status code of the response and provide details.\n\n    Checks status code of the response to request and provides\n    details if unexpected.\n\n    Parameters\n    ----------\n    resp : requests.Response\n        Instance of the Response object.\n\n    Raises\n    ------\n    APIConnectionError\n        If response status code is not 200.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; ok = SimpleNamespace(status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; API.check_request_health(ok)\n    \"\"\"\n    if resp.status_code != 200:\n        raise APIConnectionError(\n            message=f\"Error {resp.status_code}.\\n{resp.reason}\",\n            response=resp,\n        )\n</code></pre> output_to_df <code>staticmethod</code> \u00b6 <pre><code>output_to_df(response)\n</code></pre> <p>Transform output to Pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Raw output of the sent request.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas dataframe of the data from the output.</p> <p>Raises:</p> Type Description <code>DataProcessingError</code> <p>If failed to decode JSON from API response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; resp = SimpleNamespace(text='[{\"a\": 1}]')\n&gt;&gt;&gt; int(API.output_to_df(resp)[\"a\"].iloc[0])\n1\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef output_to_df(response: requests.Response) -&gt; pd.DataFrame:\n    \"\"\"\n    Transform output to Pandas dataframe.\n\n    Parameters\n    ----------\n    response : requests.Response\n        Raw output of the sent request.\n\n    Returns\n    -------\n    pd.DataFrame\n        Pandas dataframe of the data from the output.\n\n    Raises\n    ------\n    DataProcessingError\n        If failed to decode JSON from API response.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; resp = SimpleNamespace(text='[{\"a\": 1}]')\n    &gt;&gt;&gt; int(API.output_to_df(resp)[\"a\"].iloc[0])\n    1\n    \"\"\"\n    try:\n        data = json.loads(response.text)\n    except Exception as err:\n        raise DataProcessingError(\"Failed to decode JSON from API response\") from err\n    return pd.DataFrame(data)\n</code></pre> postprocess_data <code>staticmethod</code> \u00b6 <pre><code>postprocess_data(df, output_type)\n</code></pre> <p>Process dataframe information to extract additional data.</p> <p>Processes dataframe information to extract the necessary additional data.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe of the output data.</p> required <code>output_type</code> <code>str</code> <p>Expected type (amount) of the data extracted.</p> required <p>Returns:</p> Type Description <code>PostprocessData</code> <p>Dictionary of the additional data extracted.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If more than one record was returned for 'single' output type, or if output type is not 'single' or 'list'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n&gt;&gt;&gt; int(API.postprocess_data(df, \"single\")[\"id\"])\n1\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef postprocess_data(df: pd.DataFrame, output_type: str) -&gt; PostprocessData:\n    \"\"\"\n    Process dataframe information to extract additional data.\n\n    Processes dataframe information to extract the necessary\n    additional data.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe of the output data.\n    output_type : str\n        Expected type (amount) of the data extracted.\n\n    Returns\n    -------\n    PostprocessData\n        Dictionary of the additional data extracted.\n\n    Raises\n    ------\n    InvalidParameterError\n        If more than one record was returned for 'single' output\n        type, or if output type is not 'single' or 'list'.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; int(API.postprocess_data(df, \"single\")[\"id\"])\n    1\n    \"\"\"\n    if output_type == \"single\":\n        if df.__len__() == 0:\n            exists = False\n            project_id = None\n        elif df.__len__() == 1:\n            exists = True\n            project_id = df[\"id\"].iloc[0]\n        else:\n            raise InvalidParameterError(\"More than one project site was returned, check search criteria.\")\n        data_add: PostprocessData = {\n            \"existance\": exists,\n            \"id\": project_id,\n            \"response\": None,\n        }\n    elif output_type == \"list\":\n        exists = df.__len__() != 0\n        data_add: PostprocessData = {\n            \"existance\": exists,\n            \"id\": None,\n            \"response\": None,\n        }\n    else:\n        raise InvalidParameterError(\"Output type must be either 'single' or 'list', not \" + output_type + \".\")\n    return data_add\n</code></pre> validate_data <code>staticmethod</code> \u00b6 <pre><code>validate_data(df, data_type)\n</code></pre> <p>Validate the data extracted from the database.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe of the output data.</p> required <code>data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with corrected data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame()\n&gt;&gt;&gt; API.validate_data(df, \"subassemblies\").empty\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef validate_data(df: pd.DataFrame, data_type: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Validate the data extracted from the database.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe of the output data.\n    data_type : str\n        Type of the data we want to request (according to database\n        model).\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with corrected data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame()\n    &gt;&gt;&gt; API.validate_data(df, \"subassemblies\").empty\n    True\n    \"\"\"\n    z_sa_mp = {\"min\": -100000, \"max\": -10000}\n    z_sa_tp = {\"min\": -20000, \"max\": -1000}\n    z_sa_tw = {\"min\": 1000, \"max\": 100000}\n    sa_type = [\"TW\", \"TP\", \"MP\"]\n    z = [z_sa_tw, z_sa_tp, z_sa_mp]\n    if data_type == \"subassemblies\":\n        if df.__len__() == 0:\n            return df\n        for i, sat in enumerate(sa_type):\n            cond_small_units = (df[\"subassembly_type\"] == sat) &amp; (df[\"z_position\"] &lt; z[i][\"min\"])\n            cond_big_units = (df[\"subassembly_type\"] == sat) &amp; (df[\"z_position\"] &gt; z[i][\"max\"])\n            if df[cond_small_units].__len__() &gt; 0:\n                df.loc[cond_small_units, \"z_position\"] = df.loc[cond_small_units, \"z_position\"] / 1e3\n                warnings.warn(\n                    f\"The value of z location for {df.loc[cond_small_units | cond_big_units, 'title'].values} \\\n                    might be wrong or in wrong units! There will be an attempt to correct the units.\",\n                    stacklevel=2,\n                )\n            if df[cond_big_units].__len__() &gt; 0:\n                df.loc[cond_big_units, \"z_position\"] = df.loc[cond_big_units, \"z_position\"] * 1e3\n                warnings.warn(\n                    f\"The value of z location for {df.loc[cond_small_units | cond_big_units, 'title'].values} \\\n                    might be wrong or in wrong units! There will be an attempt to correct the units.\",\n                    stacklevel=2,\n                )\n    return df\n</code></pre> process_data \u00b6 <pre><code>process_data(url_data_type, url_params, output_type)\n</code></pre> <p>Process output data according to specified request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>url_data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <code>url_params</code> <code>Mapping</code> <p>Parameters to send with the request to the database.</p> required <code>output_type</code> <code>str</code> <p>Expected type (amount) of the data extracted.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of dataframe with the requested data and additional data from postprocessing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; response = SimpleNamespace(text=\"[]\", status_code=200, reason=\"OK\")\n&gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; with mock.patch.object(API, \"send_request\", return_value=response):\n...     df, info = api.process_data(\"projects\", {}, \"list\")\n&gt;&gt;&gt; df.empty\nTrue\n&gt;&gt;&gt; info[\"existance\"]\nFalse\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def process_data(\n    self,\n    url_data_type: str,\n    url_params: Mapping[str, Union[str, float, int, Sequence[Union[str, float, int]], None]],\n    output_type: str,\n) -&gt; tuple[pd.DataFrame, PostprocessData]:\n    \"\"\"\n    Process output data according to specified request parameters.\n\n    Parameters\n    ----------\n    url_data_type : str\n        Type of the data we want to request (according to database\n        model).\n    url_params : Mapping\n        Parameters to send with the request to the database.\n    output_type : str\n        Expected type (amount) of the data extracted.\n\n    Returns\n    -------\n    tuple\n        A tuple of dataframe with the requested data and\n        additional data from postprocessing.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; response = SimpleNamespace(text=\"[]\", status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; with mock.patch.object(API, \"send_request\", return_value=response):\n    ...     df, info = api.process_data(\"projects\", {}, \"list\")\n    &gt;&gt;&gt; df.empty\n    True\n    &gt;&gt;&gt; info[\"existance\"]\n    False\n    \"\"\"\n    resp = self.send_request(url_data_type, url_params)\n    self.check_request_health(resp)\n    df = self.output_to_df(resp)\n    df = self.validate_data(df, url_data_type)\n    df_add = self.postprocess_data(df, output_type)\n    # Add the response object to the returned dictionary so tests can inspect it\n    df_add[\"response\"] = resp\n    return df, df_add\n</code></pre>"},{"location":"api/geometry/#geometryprocessing-data-processing","title":"geometry.processing - Data Processing","text":""},{"location":"api/geometry/#owi.metadatabase.geometry.processing","title":"processing","text":"<p>Module containing the processing functions for the geometry data.</p>"},{"location":"api/geometry/#owi.metadatabase.geometry.processing-classes","title":"Classes","text":""},{"location":"api/geometry/#owi.metadatabase.geometry.processing.OWT","title":"OWT","text":"<pre><code>OWT(\n    api,\n    materials,\n    subassemblies,\n    location,\n    tower_base=None,\n    pile_head=None,\n)\n</code></pre> <p>Class to process the geometry data of a single OWT.</p> <p>:param api: API object used to call get_* methods. :param materials: Pandas dataframe with the materials data. :param sub_assemblies: Dictionary of the subassemblies. :param tw_sub_assemblies: Pandas dataframe with the tower subassemblies data for a given turbine. :param tp_sub_assemblies: Pandas dataframe with the transition piece subassemblies data for a given turbine. :param mp_sub_assemblies: Pandas dataframe with the monopile subassemblies data for a given turbine. :param tower_base: Elevation of the OWT tower base in mLAT. :param pile_head: Elevation of the pile head in mLAT. :param water_depth: Water depth in mLAT. :param pile_toe: Elevation of the pile toe in mLAT. :param rna: Pandas dataframe with the RNA data. :param tower: Pandas dataframe with the tower data. :param transition_piece: Pandas dataframe with the transition piece data. :param monopile: Pandas dataframe with the monopile data. :param tw_lumped_mass: Pandas dataframe with the lumped masses data for the tower. :param tp_lumped_mass: Pandas dataframe with the lumped masses data for the transition piece. :param mp_lumped_mass: Pandas dataframe with the lumped masses data for the monopile. :param tp_distributed_mass: Pandas dataframe with the distributed masses data for the transition piece. :param mp_distributed_mass: Pandas dataframe with the distributed masses data for the monopile. :param grout: Pandas dataframe with the grout data. :param full_structure: Pandas dataframe with the full structure data. :param tp_skirt: Pandas dataframe with the transition piece skirt data. :param substructure: Pandas dataframe with the substructure data.</p> <p>Create an instance of the OWT class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>Any</code> <p>API object used to call get_* methods.</p> required <code>materials</code> <code>DataFrame or bool or int64 or None</code> <p>Pandas dataframe with the materials data.</p> required <code>subassemblies</code> <code>DataFrame or bool or int64 or None</code> <p>Pandas dataframe with the subassemblies data for a given turbine.</p> required <code>location</code> <code>DataFrame or bool or int64 or None</code> <p>Pandas dataframe with the location data for a given turbine.</p> required <code>tower_base</code> <code>float64</code> <p>Elevation of the OWT tower base in mLAT.</p> <code>None</code> <code>pile_head</code> <code>float64</code> <p>Elevation of the pile head in mLAT.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from contextlib import ExitStack\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n&gt;&gt;&gt; def _set_subassemblies(self, subassemblies):\n...     self.sub_assemblies = {}\n&gt;&gt;&gt; def _set_members(self):\n...     return None\n&gt;&gt;&gt; with mock.patch.object(\n...     OWT,\n...     \"_set_subassemblies\",\n...     _set_subassemblies,\n... ), mock.patch.object(OWT, \"_set_members\", _set_members):\n...     owt = OWT(\n...         api=object(),\n...         materials=pd.DataFrame(),\n...         subassemblies=pd.DataFrame(),\n...         location=location,\n...     )\n&gt;&gt;&gt; float(owt.water_depth)\n30.0\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def __init__(\n    self,\n    api: Any,\n    materials: Union[pd.DataFrame, bool, np.int64, None],\n    subassemblies: Union[pd.DataFrame, bool, np.int64, None],\n    location: Union[pd.DataFrame, bool, np.int64, None],\n    tower_base: Union[np.float64, float, None] = None,\n    pile_head: Union[np.float64, float, None] = None,\n) -&gt; None:\n    \"\"\"\n    Create an instance of the OWT class with required parameters.\n\n    Parameters\n    ----------\n    api : Any\n        API object used to call get_* methods.\n    materials : pd.DataFrame or bool or np.int64 or None\n        Pandas dataframe with the materials data.\n    subassemblies : pd.DataFrame or bool or np.int64 or None\n        Pandas dataframe with the subassemblies data for a given\n        turbine.\n    location : pd.DataFrame or bool or np.int64 or None\n        Pandas dataframe with the location data for a given\n        turbine.\n    tower_base : np.float64, optional\n        Elevation of the OWT tower base in mLAT.\n    pile_head : np.float64, optional\n        Elevation of the pile head in mLAT.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from contextlib import ExitStack\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n    &gt;&gt;&gt; def _set_subassemblies(self, subassemblies):\n    ...     self.sub_assemblies = {}\n    &gt;&gt;&gt; def _set_members(self):\n    ...     return None\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     OWT,\n    ...     \"_set_subassemblies\",\n    ...     _set_subassemblies,\n    ... ), mock.patch.object(OWT, \"_set_members\", _set_members):\n    ...     owt = OWT(\n    ...         api=object(),\n    ...         materials=pd.DataFrame(),\n    ...         subassemblies=pd.DataFrame(),\n    ...         location=location,\n    ...     )\n    &gt;&gt;&gt; float(owt.water_depth)\n    30.0\n    \"\"\"\n    self._init_proc = False\n    self._init_spec_part = False\n    self._init_spec_full = False\n    self.api = api\n    materials_df = cast(pd.DataFrame, materials)\n    subassemblies_df = cast(pd.DataFrame, subassemblies)\n    location_df = cast(pd.DataFrame, location)\n    self.materials = materials_df\n    self._set_subassemblies(subassemblies_df)\n    self.tw_sub_assemblies = None\n    self.tp_sub_assemblies = None\n    self.mp_sub_assemblies = None\n    self._set_members()\n    for attr in ATTR_PROC:\n        setattr(self, attr, None)\n    for attr in ATTR_SPEC:\n        setattr(self, attr, None)\n    self.water_depth = np.float64(location_df[\"elevation\"].values[0])\n    if not tower_base or not pile_head:\n        if \"TW\" in self.sub_assemblies:\n            self.tower_base = self.sub_assemblies[\"TW\"].absolute_bottom\n        elif \"TP\" in self.sub_assemblies:\n            self.tower_base = self.sub_assemblies[\"TP\"].absolute_top\n        else:\n            self.tower_base = None\n        if \"MP\" in self.sub_assemblies:\n            self.pile_head = self.sub_assemblies[\"MP\"].absolute_top\n        else:\n            self.pile_head = None\n    else:\n        self.tower_base = tower_base\n        self.pile_head = pile_head\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.processing.OWT-functions","title":"Functions","text":"set_df_structure \u00b6 <pre><code>set_df_structure(idx)\n</code></pre> <p>Calculate and/or convert geometrical data of subassemblies.</p> <p>Calculates and/or converts geometrical data of subassemblies from the database.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Possible index to identify corresponding subassembly.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe containing geometry data from database with z in mLAT system.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If subassembly data not found or unknown index.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def set_df_structure(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate and/or convert geometrical data of subassemblies.\n\n    Calculates and/or converts geometrical data of subassemblies\n    from the database.\n\n    Parameters\n    ----------\n    idx : str\n        Possible index to identify corresponding subassembly.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe containing geometry data from database with z in\n        mLAT system.\n\n    Raises\n    ------\n    ValueError\n        If subassembly data not found or unknown index.\n    \"\"\"\n    cols = [\n        \"OD\",\n        \"height\",\n        \"mass\",\n        \"volume\",\n        \"wall_thickness\",\n        \"x\",\n        \"y\",\n        \"z\",\n    ]\n    if idx == \"tw\":\n        if self.tw_sub_assemblies is None:\n            raise ValueError(\"Tower subassembly data not found.\")\n        df_index = self.tw_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.tw_sub_assemblies.loc[df_index, cols])\n        depth_to = self.tower_base + df.z * 1e-3\n        depth_from = depth_to + df.height * 1e-3\n    elif idx == \"tp\":\n        if self.tp_sub_assemblies is None:\n            raise ValueError(\"Transition piece subassembly data not found.\")\n        # We don't take into account the grout, this element will be modelled as a distributed lumped mass.\n        df_index = (self.tp_sub_assemblies.index.str.contains(idx)) &amp; (\n            ~self.tp_sub_assemblies.index.str.contains(\"grout\")\n        )\n        df = deepcopy(self.tp_sub_assemblies.loc[df_index, cols])\n        bottom_tp = self.tower_base - df[\"height\"].sum() * 1e-3\n        depth_to = bottom_tp + df.z * 1e-3\n        depth_from = depth_to + df.height * 1e-3\n    elif idx == \"mp\":\n        if self.mp_sub_assemblies is None:\n            raise ValueError(\"Monopile subassembly data not found.\")\n        df_index = self.mp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.mp_sub_assemblies.loc[df_index, cols])\n        toe = self.pile_head - df[\"height\"].sum() * 1e-3\n        self.pile_toe = round(toe, 3)\n        depth_to = toe + df.z * 1e-3\n        depth_from = depth_to + df.height * 1e-3\n    else:\n        raise ValueError(\"Unknown index.\")\n    df[\"Elevation from [mLAT]\"] = depth_from\n    df[\"Elevation to [mLAT]\"] = depth_to\n    # Round elevations to mm to avoid numerical inconsistencies later when setting altitude values to apply loads.\n    df = df.round({\"Elevation from [mLAT]\": 3, \"Elevation to [mLAT]\": 3})\n    return df\n</code></pre> process_structure_geometry \u00b6 <pre><code>process_structure_geometry(idx)\n</code></pre> <p>Calculate and/or convert geometrical data for FE models.</p> <p>Calculates and/or converts geometrical data of subassemblies from the database to use as input for FE models.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Possible index to identify corresponding subassembly.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe consisting of the required data to build FE models.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_structure_geometry(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate and/or convert geometrical data for FE models.\n\n    Calculates and/or converts geometrical data of subassemblies\n    from the database to use as input for FE models.\n\n    Parameters\n    ----------\n    idx : str\n        Possible index to identify corresponding subassembly.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe consisting of the required data to build FE\n        models.\n    \"\"\"\n    df = self.set_df_structure(idx)\n    df[\"height\"] = pd.to_numeric(df[\"height\"])\n    df[\"wall_thickness\"] = pd.to_numeric(df[\"wall_thickness\"])\n    df.rename(columns={\"wall_thickness\": \"Wall thickness [mm]\"}, inplace=True)\n    df.rename(columns={\"volume\": \"Volume [m3]\"}, inplace=True)\n    d_to = [d.split(\"/\", 1)[0] for d in df[\"OD\"].values]\n    d_from = [d.split(\"/\", 1)[1] if len(d.split(\"/\", 1)) &gt; 1 else d.split(\"/\", 1)[0] for d in df[\"OD\"].values]\n    df[\"Diameter from [m]\"] = np.array(d_from, dtype=float) * 1e-3\n    df[\"Diameter to [m]\"] = np.array(d_to, dtype=float) * 1e-3\n    df[\"rho [t/m]\"] = df[\"mass\"] / df[\"height\"]\n    df[\"Mass [t]\"] = df[\"mass\"] * 1e-3\n    df[\"Height [m]\"] = df[\"height\"] * 1e-3\n    df[\"Youngs modulus [GPa]\"] = 210\n    df[\"Poissons ratio [-]\"] = 0.3\n    cols = [\n        \"Elevation from [mLAT]\",\n        \"Elevation to [mLAT]\",\n        \"Height [m]\",\n        \"Diameter from [m]\",\n        \"Diameter to [m]\",\n        \"Volume [m3]\",\n        \"Wall thickness [mm]\",\n        \"Youngs modulus [GPa]\",\n        \"Poissons ratio [-]\",\n        \"Mass [t]\",\n        \"rho [t/m]\",\n    ]\n    return df[cols]\n</code></pre> process_rna \u00b6 <pre><code>process_rna()\n</code></pre> <p>Set dataframe with required properties to model the RNA system.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If tower subassembly data not found.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_rna(self) -&gt; None:\n    \"\"\"\n    Set dataframe with required properties to model the RNA system.\n\n    Raises\n    ------\n    ValueError\n        If tower subassembly data not found.\n    \"\"\"\n    if self.tw_sub_assemblies is None:\n        raise ValueError(\"Tower subassembly data not found.\")\n    rna_index = self.tw_sub_assemblies.index.str.contains(\"RNA\")\n    rna = deepcopy(\n        self.tw_sub_assemblies.loc[\n            rna_index,\n            [\"mass\", \"moment_of_inertia\", \"x\", \"y\", \"z\", \"description\"],\n        ]\n    )\n    mi = rna[\"moment_of_inertia\"].values\n    i_xx, i_yy, i_zz = [], [], []\n    for m in mi:\n        i_xx.append(m[\"x\"] * 1e-3)\n        i_yy.append(m[\"y\"] * 1e-3)\n        i_zz.append(m[\"z\"] * 1e-3)\n    rna[\"Ixx [tm2]\"] = i_xx\n    rna[\"Iyy [tm2]\"] = i_yy\n    rna[\"Izz [tm2]\"] = i_zz\n    rna[\"Mass [t]\"] = rna[\"mass\"] * 1e-3\n    rna[\"X [m]\"] = rna[\"x\"] * 1e-3\n    rna[\"Y [m]\"] = rna[\"y\"] * 1e-3\n    rna[\"Z [mLAT]\"] = self.tower_base + rna[\"z\"] * 1e-3\n    rna.rename(columns={\"description\": \"Description\"}, inplace=True)\n    cols = [\n        \"X [m]\",\n        \"Y [m]\",\n        \"Z [mLAT]\",\n        \"Mass [t]\",\n        \"Ixx [tm2]\",\n        \"Iyy [tm2]\",\n        \"Izz [tm2]\",\n        \"Description\",\n    ]\n    self.rna = rna[cols]\n</code></pre> set_df_appurtenances \u00b6 <pre><code>set_df_appurtenances(idx)\n</code></pre> <p>Set dataframe with required properties for concentrated masses.</p> <p>Sets dataframe containing the required properties to model concentrated masses from database subassemblies.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Index to identify corresponding subassembly with possible values: 'TW', 'TP', 'MP'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe containing lumped masses data from database with Z coordinates in mLAT system.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If subassembly data not found or unknown index.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def set_df_appurtenances(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Set dataframe with required properties for concentrated masses.\n\n    Sets dataframe containing the required properties to model\n    concentrated masses from database subassemblies.\n\n    Parameters\n    ----------\n    idx : str\n        Index to identify corresponding subassembly with possible\n        values: 'TW', 'TP', 'MP'.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe containing lumped masses data from database with\n        Z coordinates in mLAT system.\n\n    Raises\n    ------\n    ValueError\n        If subassembly data not found or unknown index.\n    \"\"\"\n    cols = [\"mass\", \"x\", \"y\", \"z\", \"description\"]\n    if idx == \"TW\":\n        if self.tw_sub_assemblies is None:\n            raise ValueError(\"Tower subassembly data not found.\")\n        df_index = self.tw_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.tw_sub_assemblies.loc[df_index, cols])\n        df[\"Z [mLAT]\"] = self.tower_base + df[\"z\"] * 1e-3\n    elif idx == \"TP\":\n        if self.tp_sub_assemblies is None:\n            raise ValueError(\"Transition piece subassembly data not found.\")\n        df_index = self.tp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.tp_sub_assemblies.loc[df_index, cols + [\"height\"]])\n        # Lumped masses have 'None' height whereas distributed masses present not 'None' values\n        df[\"height\"] = pd.to_numeric(df[\"height\"])\n        df = df[df[\"height\"].isnull()]\n        bottom = self.sub_assemblies[\"TP\"].position.z * 1e-3  # m\n        df[\"Z [mLAT]\"] = bottom + df[\"z\"] * 1e-3  # m\n    elif idx == \"MP\":\n        if self.mp_sub_assemblies is None:\n            raise ValueError(\"Monopile subassembly data not found.\")\n        df_index = self.mp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.mp_sub_assemblies.loc[df_index, cols + [\"height\"]])\n        # Lumped masses have 'None' height whereas distributed masses present not 'None' values\n        df[\"height\"] = pd.to_numeric(df[\"height\"])\n        df = df[df[\"height\"].isnull()]\n        bottom = self.pile_toe\n        df[\"Z [mLAT]\"] = bottom + df[\"z\"] * 1e-3\n    else:\n        raise ValueError(\"Unknown index.\")\n    return df\n</code></pre> process_lumped_masses \u00b6 <pre><code>process_lumped_masses(idx)\n</code></pre> <p>Create dataframe with required properties for lumped masses.</p> <p>Creates dataframe containing the required properties to model lumped mass appurtenances. Note that if the preprocessor package does not find any appurtenances it'll return an empty dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Index to identify corresponding subassembly with possible values: 'TW', 'TP', 'MP'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with lumped mass properties.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_lumped_masses(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Create dataframe with required properties for lumped masses.\n\n    Creates dataframe containing the required properties to model\n    lumped mass appurtenances. Note that if the preprocessor\n    package does not find any appurtenances it'll return an empty\n    dataframe.\n\n    Parameters\n    ----------\n    idx : str\n        Index to identify corresponding subassembly with possible\n        values: 'TW', 'TP', 'MP'.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with lumped mass properties.\n    \"\"\"\n    df = self.set_df_appurtenances(idx)\n    df[\"Mass [t]\"] = df.mass * 1e-3\n    df[\"X [m]\"] = df.x * 1e-3\n    df[\"Y [m]\"] = df.y * 1e-3\n    df.rename(columns={\"description\": \"Description\"}, inplace=True)\n    cols = [\"X [m]\", \"Y [m]\", \"Z [mLAT]\", \"Mass [t]\", \"Description\"]\n    return df[cols]\n</code></pre> set_df_distributed_appurtenances \u00b6 <pre><code>set_df_distributed_appurtenances(idx)\n</code></pre> <p>Set dataframe with required properties for distributed masses.</p> <p>Sets dataframe containing the required properties to model distributed lumped masses from database.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Index to identify corresponding subassembly with possible values: 'TW', 'TP', 'MP'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe containing distributed lumped masses data from database. Z coordinates in mLAT system.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If subassembly data not found or unknown index or distributed lumped masses located outside the transition piece.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def set_df_distributed_appurtenances(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Set dataframe with required properties for distributed masses.\n\n    Sets dataframe containing the required properties to model\n    distributed lumped masses from database.\n\n    Parameters\n    ----------\n    idx : str\n        Index to identify corresponding subassembly with possible\n        values: 'TW', 'TP', 'MP'.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe containing distributed lumped masses data from\n        database. Z coordinates in mLAT system.\n\n    Raises\n    ------\n    ValueError\n        If subassembly data not found or unknown index or\n        distributed lumped masses located outside the transition\n        piece.\n    \"\"\"\n    cols = [\"mass\", \"x\", \"y\", \"z\", \"height\", \"volume\", \"description\"]\n    if idx == \"TP\":\n        if self.tp_sub_assemblies is None:\n            raise ValueError(\"Transition piece subassembly data not found.\")\n        df_index = self.tp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.tp_sub_assemblies.loc[df_index, cols])\n        # Lumped masses have 'None' height whereas distributed masses present not 'None' values\n        df[\"height\"] = pd.to_numeric(df[\"height\"])\n        df = df[df[\"height\"].notnull()]\n        bottom_tp = self.tower_base - self.tp_sub_assemblies.iloc[0][\"z\"] * 1e-3\n        df[\"Z [mLAT]\"] = bottom_tp + df[\"z\"] * 1e-3\n    elif idx == \"MP\":\n        if self.mp_sub_assemblies is None:\n            raise ValueError(\"Monopile subassembly data not found.\")\n        df_index = self.mp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.mp_sub_assemblies.loc[df_index, cols])\n        # Lumped masses have 'None' height whereas distributed masses present not 'None' values\n        df[\"height\"] = pd.to_numeric(df[\"height\"])\n        df = df[df[\"height\"].notnull()]\n        bottom = self.pile_toe\n        df[\"Z [mLAT]\"] = bottom + df[\"z\"] * 1e-3\n    elif idx == \"grout\":\n        if self.tp_sub_assemblies is None:\n            raise ValueError(\"Transition piece subassembly data not found.\")\n        df_index = self.tp_sub_assemblies.index.str.contains(idx)\n        df = deepcopy(self.tp_sub_assemblies.loc[df_index, cols])\n        # Lumped masses have 'None' height whereas distributed masses present not 'None' values\n        df[\"height\"] = pd.to_numeric(df[\"height\"])\n        df = df[df[\"height\"].notnull()]\n        bottom_tp = self.tower_base - self.tp_sub_assemblies.iloc[0][\"z\"] * 1e-3\n        df[\"Z [mLAT]\"] = bottom_tp + df[\"z\"] * 1e-3\n    else:\n        raise ValueError(\"Unknown index or non distributed lumped masses located outside the transition piece.\")\n    return df\n</code></pre> process_distributed_lumped_masses \u00b6 <pre><code>process_distributed_lumped_masses(idx)\n</code></pre> <p>Create dataframe with uniformly distributed appurtenances.</p> <p>Creates dataframe containing the required properties to model uniformly distributed appurtenances. Note that if the preprocessor package does not find any appurtenances it'll return an empty dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>str</code> <p>Index to identify corresponding subassembly with possible values: 'TP', 'MP'.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with distributed lumped mass properties.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_distributed_lumped_masses(self, idx: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Create dataframe with uniformly distributed appurtenances.\n\n    Creates dataframe containing the required properties to model\n    uniformly distributed appurtenances. Note that if the\n    preprocessor package does not find any appurtenances it'll\n    return an empty dataframe.\n\n    Parameters\n    ----------\n    idx : str\n        Index to identify corresponding subassembly with possible\n        values: 'TP', 'MP'.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with distributed lumped mass properties.\n    \"\"\"\n    df = self.set_df_distributed_appurtenances(idx)\n    df[\"Mass [t]\"] = df[\"mass\"] * 1e-3\n    df[\"X [m]\"] = df[\"x\"] * 1e-3\n    df[\"Y [m]\"] = df[\"y\"] * 1e-3\n    df[\"Height [m]\"] = df[\"height\"] * 1e-3\n    df.rename(columns={\"volume\": \"Volume [m3]\"}, inplace=True)\n    df.rename(columns={\"description\": \"Description\"}, inplace=True)\n    cols = [\n        \"X [m]\",\n        \"Y [m]\",\n        \"Z [mLAT]\",\n        \"Height [m]\",\n        \"Mass [t]\",\n        \"Volume [m3]\",\n        \"Description\",\n    ]\n    return df[cols]\n</code></pre> process_structure \u00b6 <pre><code>process_structure(option='full')\n</code></pre> <p>Set dataframe with required properties to model the tower.</p> <p>Sets dataframe containing the required properties to model the tower geometry, including the RNA system.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>str</code> <p>Option to process the data for a specific subassembly. Possible values:</p> <ul> <li>\"full\": To process all the data for all subassemblies.</li> <li>\"tower\": To process only the data for the tower   subassembly.</li> <li>\"TP\": To process only the data for the transition piece   subassembly.</li> <li>\"monopile\": To process only the data for the monopile   foundation subassembly.</li> </ul> <code>'full'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from contextlib import ExitStack\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n&gt;&gt;&gt; def _set_subassemblies(self, subassemblies):\n...     self.sub_assemblies = {}\n&gt;&gt;&gt; def _set_members(self):\n...     return None\n&gt;&gt;&gt; with mock.patch.object(\n...     OWT,\n...     \"_set_subassemblies\",\n...     _set_subassemblies,\n... ), mock.patch.object(OWT, \"_set_members\", _set_members):\n...     owt = OWT(\n...         api=object(),\n...         materials=pd.DataFrame(),\n...         subassemblies=pd.DataFrame(),\n...         location=location,\n...     )\n&gt;&gt;&gt; empty_df = pd.DataFrame()\n&gt;&gt;&gt; with ExitStack() as stack:\n...     _ = stack.enter_context(mock.patch.object(OWT, \"process_rna\"))\n...     _ = stack.enter_context(\n...         mock.patch.object(\n...             OWT,\n...             \"process_structure_geometry\",\n...             return_value=empty_df,\n...         )\n...     )\n...     _ = stack.enter_context(\n...         mock.patch.object(\n...             OWT,\n...             \"process_lumped_masses\",\n...             return_value=empty_df,\n...         )\n...     )\n...     _ = stack.enter_context(\n...         mock.patch.object(\n...             OWT,\n...             \"process_distributed_lumped_masses\",\n...             return_value=empty_df,\n...         )\n...     )\n...     owt.process_structure(option=\"TW\")\n&gt;&gt;&gt; owt._init_proc\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_structure(self, option=\"full\") -&gt; None:\n    \"\"\"\n    Set dataframe with required properties to model the tower.\n\n    Sets dataframe containing the required properties to model the\n    tower geometry, including the RNA system.\n\n    Parameters\n    ----------\n    option : str, optional\n        Option to process the data for a specific subassembly.\n        Possible values:\n\n        - \"full\": To process all the data for all subassemblies.\n        - \"tower\": To process only the data for the tower\n          subassembly.\n        - \"TP\": To process only the data for the transition piece\n          subassembly.\n        - \"monopile\": To process only the data for the monopile\n          foundation subassembly.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from contextlib import ExitStack\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; location = pd.DataFrame({\"elevation\": [30.0]})\n    &gt;&gt;&gt; def _set_subassemblies(self, subassemblies):\n    ...     self.sub_assemblies = {}\n    &gt;&gt;&gt; def _set_members(self):\n    ...     return None\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     OWT,\n    ...     \"_set_subassemblies\",\n    ...     _set_subassemblies,\n    ... ), mock.patch.object(OWT, \"_set_members\", _set_members):\n    ...     owt = OWT(\n    ...         api=object(),\n    ...         materials=pd.DataFrame(),\n    ...         subassemblies=pd.DataFrame(),\n    ...         location=location,\n    ...     )\n    &gt;&gt;&gt; empty_df = pd.DataFrame()\n    &gt;&gt;&gt; with ExitStack() as stack:\n    ...     _ = stack.enter_context(mock.patch.object(OWT, \"process_rna\"))\n    ...     _ = stack.enter_context(\n    ...         mock.patch.object(\n    ...             OWT,\n    ...             \"process_structure_geometry\",\n    ...             return_value=empty_df,\n    ...         )\n    ...     )\n    ...     _ = stack.enter_context(\n    ...         mock.patch.object(\n    ...             OWT,\n    ...             \"process_lumped_masses\",\n    ...             return_value=empty_df,\n    ...         )\n    ...     )\n    ...     _ = stack.enter_context(\n    ...         mock.patch.object(\n    ...             OWT,\n    ...             \"process_distributed_lumped_masses\",\n    ...             return_value=empty_df,\n    ...         )\n    ...     )\n    ...     owt.process_structure(option=\"TW\")\n    &gt;&gt;&gt; owt._init_proc\n    True\n    \"\"\"\n    self._init_proc = True\n    if option == \"full\":\n        self.process_rna()\n        self.tower = self.process_structure_geometry(\"tw\")\n        self.transition_piece = self.process_structure_geometry(\"tp\")\n        self.monopile = self.process_structure_geometry(\"mp\")\n        self.tw_lumped_mass = self.process_lumped_masses(\"TW\")\n        self.tp_lumped_mass = self.process_lumped_masses(\"TP\")\n        self.mp_lumped_mass = self.process_lumped_masses(\"MP\")\n        self.tp_distributed_mass = self.process_distributed_lumped_masses(\"TP\")\n        self.mp_distributed_mass = self.process_distributed_lumped_masses(\"MP\")\n        self.grout = self.process_distributed_lumped_masses(\"grout\")\n    elif option == \"TW\":\n        self.process_rna()\n        self.tower = self.process_structure_geometry(\"tw\")\n        self.tw_lumped_mass = self.process_lumped_masses(\"TW\")\n    elif option == \"TP\":\n        self.transition_piece = self.process_structure_geometry(\"tp\")\n        self.tp_lumped_mass = self.process_lumped_masses(\"TP\")\n        self.tp_distributed_mass = self.process_distributed_lumped_masses(\"TP\")\n        self.grout = self.process_distributed_lumped_masses(\"grout\")\n    elif option == \"MP\":\n        self.monopile = self.process_structure_geometry(\"mp\")\n        self.mp_lumped_mass = self.process_lumped_masses(\"MP\")\n        self.mp_distributed_mass = self.process_distributed_lumped_masses(\"MP\")\n</code></pre> can_adjust_properties <code>staticmethod</code> \u00b6 <pre><code>can_adjust_properties(row)\n</code></pre> <p>Recalculate can properties based on section and elevations.</p> <p>Recalculation of can properties based on section properties and can elevations: height [m], volume [m3], mass [t], rho [t/m].</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>Series</code> <p>Original can properties.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Pandas series of recalculated can properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; row = pd.Series(\n...     {\n...         \"Mass [t]\": 10.0,\n...         \"Volume [m3]\": 5.0,\n...         \"Elevation from [mLAT]\": 10.0,\n...         \"Elevation to [mLAT]\": 0.0,\n...         \"Diameter from [m]\": 6.0,\n...         \"Diameter to [m]\": 6.0,\n...         \"Wall thickness [mm]\": 10.0,\n...     }\n... )\n&gt;&gt;&gt; out = OWT.can_adjust_properties(row)\n&gt;&gt;&gt; float(out[\"Height [m]\"])\n10.0\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>@staticmethod\ndef can_adjust_properties(row: pd.Series) -&gt; pd.Series:\n    \"\"\"\n    Recalculate can properties based on section and elevations.\n\n    Recalculation of can properties based on section properties and\n    can elevations: height [m], volume [m3], mass [t], rho [t/m].\n\n    Parameters\n    ----------\n    row : pd.Series\n        Original can properties.\n\n    Returns\n    -------\n    pd.Series\n        Pandas series of recalculated can properties.\n\n    Examples\n    --------\n    &gt;&gt;&gt; row = pd.Series(\n    ...     {\n    ...         \"Mass [t]\": 10.0,\n    ...         \"Volume [m3]\": 5.0,\n    ...         \"Elevation from [mLAT]\": 10.0,\n    ...         \"Elevation to [mLAT]\": 0.0,\n    ...         \"Diameter from [m]\": 6.0,\n    ...         \"Diameter to [m]\": 6.0,\n    ...         \"Wall thickness [mm]\": 10.0,\n    ...     }\n    ... )\n    &gt;&gt;&gt; out = OWT.can_adjust_properties(row)\n    &gt;&gt;&gt; float(out[\"Height [m]\"])\n    10.0\n    \"\"\"\n    density = row[\"Mass [t]\"] / row[\"Volume [m3]\"]\n    height = row[\"Elevation from [mLAT]\"] - row[\"Elevation to [mLAT]\"]\n    r1 = row[\"Diameter from [m]\"] / 2\n    r2 = row[\"Diameter to [m]\"] / 2\n    volume_out = 1 / 3 * np.pi * (r1**2 + r1 * r2 + r2**2) * height\n    wall_thickness = row[\"Wall thickness [mm]\"] * 1e-3\n    r1 = r1 - wall_thickness\n    r2 = r2 - wall_thickness\n    volume_in = 1 / 3 * np.pi * (r1**2 + r1 * r2 + r2**2) * height\n    volume = volume_out - volume_in\n    mass = volume * density\n    rho_m = mass / height\n    can_properties = pd.Series(\n        data=[height, volume, mass, rho_m],\n        index=[\"Height [m]\", \"Volume [m3]\", \"Mass [t]\", \"rho [t/m]\"],\n    )\n    return can_properties\n</code></pre> can_modification \u00b6 <pre><code>can_modification(df, altitude, position='bottom')\n</code></pre> <p>Change can properties based on the altitude.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe containing the can properties.</p> required <code>altitude</code> <code>float64 or None</code> <p>Altitude in mLAT.</p> required <code>position</code> <code>str</code> <p>Position of the can with respect to the altitude with possible values: \"bottom\" or \"top\", default is \"bottom\".</p> <code>'bottom'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with the modified can properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame(\n...     {\n...         \"Elevation from [mLAT]\": [10.0],\n...         \"Elevation to [mLAT]\": [0.0],\n...         \"Diameter from [m]\": [6.0],\n...         \"Diameter to [m]\": [6.0],\n...         \"Wall thickness [mm]\": [10.0],\n...         \"Volume [m3]\": [5.0],\n...         \"Mass [t]\": [10.0],\n...         \"rho [t/m]\": [1.0],\n...     },\n...     index=[\"A\"],\n... )\n&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; helper = SimpleNamespace(can_adjust_properties=OWT.can_adjust_properties)\n&gt;&gt;&gt; out = OWT.can_modification(helper, df.copy(), np.float64(5.0))\n&gt;&gt;&gt; float(out[\"Elevation to [mLAT]\"].iloc[0])\n5.0\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def can_modification(\n    self,\n    df: pd.DataFrame,\n    altitude: Union[np.float64, float, None],\n    position: str = \"bottom\",\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Change can properties based on the altitude.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe containing the can properties.\n    altitude : np.float64 or None\n        Altitude in mLAT.\n    position : str, optional\n        Position of the can with respect to the altitude with\n        possible values: \"bottom\" or \"top\", default is \"bottom\".\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with the modified can properties.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame(\n    ...     {\n    ...         \"Elevation from [mLAT]\": [10.0],\n    ...         \"Elevation to [mLAT]\": [0.0],\n    ...         \"Diameter from [m]\": [6.0],\n    ...         \"Diameter to [m]\": [6.0],\n    ...         \"Wall thickness [mm]\": [10.0],\n    ...         \"Volume [m3]\": [5.0],\n    ...         \"Mass [t]\": [10.0],\n    ...         \"rho [t/m]\": [1.0],\n    ...     },\n    ...     index=[\"A\"],\n    ... )\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; helper = SimpleNamespace(can_adjust_properties=OWT.can_adjust_properties)\n    &gt;&gt;&gt; out = OWT.can_modification(helper, df.copy(), np.float64(5.0))\n    &gt;&gt;&gt; float(out[\"Elevation to [mLAT]\"].iloc[0])\n    5.0\n    \"\"\"\n    if position == \"bottom\":\n        ind = -1\n        _col = \" to \"\n    else:\n        ind = 0\n        _col = \" from \"\n    altitude_val = float(altitude) if altitude is not None else float(\"nan\")\n    row_index = df.index[ind]\n    df.loc[row_index, \"Elevation\" + _col + \"[mLAT]\"] = altitude_val\n    col_elev_from = df.columns.get_loc(\"Elevation from [mLAT]\")\n    col_elev_to = df.columns.get_loc(\"Elevation to [mLAT]\")\n    col_diam_from = df.columns.get_loc(\"Diameter from [m]\")\n    col_diam_to = df.columns.get_loc(\"Diameter to [m]\")\n    if not isinstance(col_elev_from, int):\n        raise ValueError(\"Expected scalar columns for elevation data.\")\n    if not isinstance(col_elev_to, int):\n        raise ValueError(\"Expected scalar columns for elevation data.\")\n    if not isinstance(col_diam_from, int):\n        raise ValueError(\"Expected scalar columns for diameter data.\")\n    if not isinstance(col_diam_to, int):\n        raise ValueError(\"Expected scalar columns for diameter data.\")\n    elevation = [\n        float(cast(float, df.iat[ind, col_elev_from])),\n        float(cast(float, df.iat[ind, col_elev_to])),\n    ]\n    diameters = [\n        float(cast(float, df.iat[ind, col_diam_from])),\n        float(cast(float, df.iat[ind, col_diam_to])),\n    ]\n    df.loc[row_index, \"Diameter\" + _col + \"[m]\"] = float(\n        np.interp(\n            altitude_val,\n            elevation,\n            diameters,\n        )\n    )\n    cols = [\"Height [m]\", \"Volume [m3]\", \"Mass [t]\", \"rho [t/m]\"]\n    df.loc[df.index[ind], cols] = self.can_adjust_properties(df.iloc[ind])\n    return df\n</code></pre> assembly_tp_mp \u00b6 <pre><code>assembly_tp_mp()\n</code></pre> <p>Process TP structural item to assembly with MP foundation.</p> <p>Processes TP structural item to assembly with MP foundation ensuring continuity. TP skirt is processed as well.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If TP or MP items need to be processed before.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     transition_piece=None,\n...     monopile=None,\n...     _init_spec_part=False,\n... )\n&gt;&gt;&gt; OWT.assembly_tp_mp(helper)\nTraceback (most recent call last):\n    ...\nTypeError: TP or MP items need to be processed before!\n&gt;&gt;&gt; tp = pd.DataFrame(\n...     {\n...         \"Elevation from [mLAT]\": [6.0, 0.0],\n...         \"Elevation to [mLAT]\": [8.0, 4.0],\n...         \"Diameter from [m]\": [6.0, 6.0],\n...         \"Diameter to [m]\": [6.0, 6.0],\n...         \"Wall thickness [mm]\": [10.0, 10.0],\n...         \"Volume [m3]\": [5.0, 5.0],\n...         \"Mass [t]\": [10.0, 10.0],\n...         \"rho [t/m]\": [1.0, 1.0],\n...     }\n... )\n&gt;&gt;&gt; mp = pd.DataFrame(\n...     {\n...         \"Elevation from [mLAT]\": [0.0],\n...         \"Elevation to [mLAT]\": [-10.0],\n...         \"Diameter from [m]\": [6.0],\n...         \"Diameter to [m]\": [6.0],\n...         \"Wall thickness [mm]\": [10.0],\n...         \"Volume [m3]\": [5.0],\n...         \"Mass [t]\": [10.0],\n...         \"rho [t/m]\": [1.0],\n...     }\n... )\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     transition_piece=tp,\n...     monopile=mp,\n...     pile_head=5.0,\n...     substructure=None,\n...     tp_skirt=None,\n...     _init_spec_part=False,\n... )\n&gt;&gt;&gt; helper.can_adjust_properties = OWT.can_adjust_properties\n&gt;&gt;&gt; helper.can_modification = lambda df, altitude, position=\"bottom\": OWT.can_modification(\n...     helper,\n...     df,\n...     altitude,\n...     position=position,\n... )\n&gt;&gt;&gt; OWT.assembly_tp_mp(helper)\n&gt;&gt;&gt; helper.substructure is not None\nTrue\n&gt;&gt;&gt; helper.tp_skirt is not None\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def assembly_tp_mp(self) -&gt; None:\n    \"\"\"\n    Process TP structural item to assembly with MP foundation.\n\n    Processes TP structural item to assembly with MP foundation\n    ensuring continuity. TP skirt is processed as well.\n\n    Raises\n    ------\n    TypeError\n        If TP or MP items need to be processed before.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     transition_piece=None,\n    ...     monopile=None,\n    ...     _init_spec_part=False,\n    ... )\n    &gt;&gt;&gt; OWT.assembly_tp_mp(helper)\n    Traceback (most recent call last):\n        ...\n    TypeError: TP or MP items need to be processed before!\n    &gt;&gt;&gt; tp = pd.DataFrame(\n    ...     {\n    ...         \"Elevation from [mLAT]\": [6.0, 0.0],\n    ...         \"Elevation to [mLAT]\": [8.0, 4.0],\n    ...         \"Diameter from [m]\": [6.0, 6.0],\n    ...         \"Diameter to [m]\": [6.0, 6.0],\n    ...         \"Wall thickness [mm]\": [10.0, 10.0],\n    ...         \"Volume [m3]\": [5.0, 5.0],\n    ...         \"Mass [t]\": [10.0, 10.0],\n    ...         \"rho [t/m]\": [1.0, 1.0],\n    ...     }\n    ... )\n    &gt;&gt;&gt; mp = pd.DataFrame(\n    ...     {\n    ...         \"Elevation from [mLAT]\": [0.0],\n    ...         \"Elevation to [mLAT]\": [-10.0],\n    ...         \"Diameter from [m]\": [6.0],\n    ...         \"Diameter to [m]\": [6.0],\n    ...         \"Wall thickness [mm]\": [10.0],\n    ...         \"Volume [m3]\": [5.0],\n    ...         \"Mass [t]\": [10.0],\n    ...         \"rho [t/m]\": [1.0],\n    ...     }\n    ... )\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     transition_piece=tp,\n    ...     monopile=mp,\n    ...     pile_head=5.0,\n    ...     substructure=None,\n    ...     tp_skirt=None,\n    ...     _init_spec_part=False,\n    ... )\n    &gt;&gt;&gt; helper.can_adjust_properties = OWT.can_adjust_properties\n    &gt;&gt;&gt; helper.can_modification = lambda df, altitude, position=\"bottom\": OWT.can_modification(\n    ...     helper,\n    ...     df,\n    ...     altitude,\n    ...     position=position,\n    ... )\n    &gt;&gt;&gt; OWT.assembly_tp_mp(helper)\n    &gt;&gt;&gt; helper.substructure is not None\n    True\n    &gt;&gt;&gt; helper.tp_skirt is not None\n    True\n    \"\"\"\n    self._init_spec_part = True\n    if (self.transition_piece is not None) and (self.monopile is not None):\n        mp_head = self.pile_head\n        tp = self.transition_piece\n        df = deepcopy(tp[tp[\"Elevation from [mLAT]\"] &gt; mp_head])\n        if df.loc[df.index[0], \"Elevation to [mLAT]\"] != mp_head:\n            # Not bolted connection (i.e. Rentel) preprocessing needed\n            tp1 = self.can_modification(df, mp_head, position=\"bottom\")\n            self.substructure = pd.concat([tp1, deepcopy(self.monopile)])\n        else:\n            # Bolted connection, nothing to do\n            self.substructure = pd.concat([df, deepcopy(self.monopile)])\n        df = deepcopy(tp[tp[\"Elevation to [mLAT]\"] &lt; mp_head])\n        self.tp_skirt = self.can_modification(df, mp_head, position=\"top\")\n    else:\n        raise TypeError(\"TP or MP items need to be processed before!\")\n</code></pre> assembly_full_structure \u00b6 <pre><code>assembly_full_structure()\n</code></pre> <p>Process the full structure of the OWT.</p> <p>Processes the full structure of the OWT: tower + tp combination with monopile.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If tower or substructure needs to be processed before.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     substructure=pd.DataFrame({\"Height [m]\": [1.0]}),\n...     tower=pd.DataFrame({\"Height [m]\": [2.0]}),\n...     _init_spec_full=False,\n... )\n&gt;&gt;&gt; OWT.assembly_full_structure(helper)\n&gt;&gt;&gt; float(helper.full_structure[\"Height [m]\"].sum())\n3.0\n&gt;&gt;&gt; helper._init_spec_full\nTrue\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     substructure=None,\n...     tower=None,\n...     _init_spec_full=False,\n... )\n&gt;&gt;&gt; OWT.assembly_full_structure(helper)\nTraceback (most recent call last):\n    ...\nTypeError: Substructure needs to be processed before!\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     substructure=pd.DataFrame({\"Height [m]\": [1.0]}),\n...     tower=None,\n...     _init_spec_full=False,\n... )\n&gt;&gt;&gt; OWT.assembly_full_structure(helper)\nTraceback (most recent call last):\n    ...\nTypeError: Tower needs to be processed before!\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def assembly_full_structure(self) -&gt; None:\n    \"\"\"\n    Process the full structure of the OWT.\n\n    Processes the full structure of the OWT: tower + tp combination\n    with monopile.\n\n    Raises\n    ------\n    TypeError\n        If tower or substructure needs to be processed before.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     substructure=pd.DataFrame({\"Height [m]\": [1.0]}),\n    ...     tower=pd.DataFrame({\"Height [m]\": [2.0]}),\n    ...     _init_spec_full=False,\n    ... )\n    &gt;&gt;&gt; OWT.assembly_full_structure(helper)\n    &gt;&gt;&gt; float(helper.full_structure[\"Height [m]\"].sum())\n    3.0\n    &gt;&gt;&gt; helper._init_spec_full\n    True\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     substructure=None,\n    ...     tower=None,\n    ...     _init_spec_full=False,\n    ... )\n    &gt;&gt;&gt; OWT.assembly_full_structure(helper)\n    Traceback (most recent call last):\n        ...\n    TypeError: Substructure needs to be processed before!\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     substructure=pd.DataFrame({\"Height [m]\": [1.0]}),\n    ...     tower=None,\n    ...     _init_spec_full=False,\n    ... )\n    &gt;&gt;&gt; OWT.assembly_full_structure(helper)\n    Traceback (most recent call last):\n        ...\n    TypeError: Tower needs to be processed before!\n    \"\"\"\n    self._init_spec_full = True\n    if self.substructure is not None:\n        if self.tower is not None:\n            self.full_structure = pd.concat([self.tower, self.substructure])\n        else:\n            raise TypeError(\"Tower needs to be processed before!\")\n    else:\n        raise TypeError(\"Substructure needs to be processed before!\")\n</code></pre> extend_dfs \u00b6 <pre><code>extend_dfs()\n</code></pre> <p>Extend the dataframes with the subassembly columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; helper = SimpleNamespace(\n...     pile_toe=None,\n...     rna=None,\n...     tower=pd.DataFrame({\"Height [m]\": [1.0]}),\n...     transition_piece=None,\n...     monopile=None,\n...     tw_lumped_mass=None,\n...     tp_lumped_mass=None,\n...     mp_lumped_mass=None,\n...     tp_distributed_mass=None,\n...     mp_distributed_mass=None,\n...     grout=None,\n...     sub_assemblies={},\n...     substructure=None,\n...     tp_skirt=None,\n...     full_structure=None,\n...     _init_spec_part=False,\n...     _init_spec_full=False,\n... )\n&gt;&gt;&gt; OWT.extend_dfs(helper)\n&gt;&gt;&gt; helper.tower[\"Subassembly\"].iloc[0]\n'TW'\n&gt;&gt;&gt; helper.tp_skirt is None\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def extend_dfs(self) -&gt; None:\n    \"\"\"\n    Extend the dataframes with the subassembly columns.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pandas as pd\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; helper = SimpleNamespace(\n    ...     pile_toe=None,\n    ...     rna=None,\n    ...     tower=pd.DataFrame({\"Height [m]\": [1.0]}),\n    ...     transition_piece=None,\n    ...     monopile=None,\n    ...     tw_lumped_mass=None,\n    ...     tp_lumped_mass=None,\n    ...     mp_lumped_mass=None,\n    ...     tp_distributed_mass=None,\n    ...     mp_distributed_mass=None,\n    ...     grout=None,\n    ...     sub_assemblies={},\n    ...     substructure=None,\n    ...     tp_skirt=None,\n    ...     full_structure=None,\n    ...     _init_spec_part=False,\n    ...     _init_spec_full=False,\n    ... )\n    &gt;&gt;&gt; OWT.extend_dfs(helper)\n    &gt;&gt;&gt; helper.tower[\"Subassembly\"].iloc[0]\n    'TW'\n    &gt;&gt;&gt; helper.tp_skirt is None\n    True\n    \"\"\"\n    for attr in ATTR_PROC:\n        df = getattr(self, attr)\n        if df is not None:\n            if \"tower\" in attr or \"tw_\" in attr or \"rna\" in attr:\n                df[\"Subassembly\"] = \"TW\"\n                setattr(self, attr, df)\n            elif \"tp_\" in attr or \"transition\" in attr or \"grout\" in attr:\n                df[\"Subassembly\"] = \"TP\"\n                setattr(self, attr, df)\n            elif \"mp_\" in attr or \"monopile\" in attr:\n                df[\"Subassembly\"] = \"MP\"\n                setattr(self, attr, df)\n    if \"TP\" in self.sub_assemblies and \"MP\" in self.sub_assemblies:\n        self.assembly_tp_mp()\n    else:\n        self._init_spec_part = True\n        self.tp_skirt = None\n    if \"TW\" in self.sub_assemblies:\n        self._init_spec_full = True\n        if self.substructure is not None:\n            self.assembly_full_structure()\n        else:\n            self.full_structure = None\n    else:\n        self.full_structure = None\n        self._init_spec_full = True\n</code></pre> transform_monopile_geometry \u00b6 <pre><code>transform_monopile_geometry(cutoff_point=nan)\n</code></pre> <p>Return a dataframe with monopile geometry.</p> <p>Returns a dataframe with the monopile geometry with the mudline as reference.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff_point</code> <code>floating</code> <p>Depth from the mudline to cut the monopile geometry.</p> <code>nan</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with the monopile geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If monopile subassembly data not found.</p> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>@typing.no_type_check\ndef transform_monopile_geometry(\n    self,\n    cutoff_point: np.floating = np.nan,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Return a dataframe with monopile geometry.\n\n    Returns a dataframe with the monopile geometry with the mudline\n    as reference.\n\n    Parameters\n    ----------\n    cutoff_point : np.floating, optional\n        Depth from the mudline to cut the monopile geometry.\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with the monopile geometry.\n\n    Raises\n    ------\n    ValueError\n        If monopile subassembly data not found.\n    \"\"\"\n    toe_depth_lat = self.sub_assemblies[\"MP\"].position.z\n    penetration = -((1e-3 * toe_depth_lat) - self.water_depth)\n    pile = pd.DataFrame()\n    if self.mp_sub_assemblies is not None:\n        df = self.mp_sub_assemblies.copy()\n    else:\n        raise ValueError(\"Monopile subassembly data not found.\")\n    df.reset_index(inplace=True)\n    for i, row in df.iterrows():\n        if i != 0:\n            pile.loc[i, \"Elevation from [m]\"] = penetration - 1e-3 * df[\"z\"].iloc[i - 1]\n            pile.loc[i, \"Elevation to [m]\"] = penetration - 1e-3 * row[\"z\"]\n            pile.loc[i, \"Pile material\"] = self.sub_assemblies[\"MP\"].bb[0].material.title\n            pile.loc[i, \"Pile material submerged unit weight [kN/m3]\"] = (\n                1e-2 * self.sub_assemblies[\"MP\"].bb[0].material.density - 10\n            )\n            pile.loc[i, \"Wall thickness [mm]\"] = row[\"wall_thickness\"]\n            bot_od = row[\"OD\"].split(\"/\")[0] if \"/\" in row[\"OD\"] else row[\"OD\"]\n            top_od = row[\"OD\"].split(\"/\")[1] if \"/\" in row[\"OD\"] else row[\"OD\"]\n            pile.loc[i, \"Diameter [m]\"] = 1e-3 * 0.5 * (float(bot_od) + float(top_od))\n            pile.loc[i, \"Youngs modulus [GPa]\"] = self.sub_assemblies[\"MP\"].bb[0].material.young_modulus\n            pile.loc[i, \"Poissons ratio [-]\"] = self.sub_assemblies[\"MP\"].bb[0].material.poisson_ratio\n    if not np.isnan(cutoff_point):\n        pile = pile.loc[pile[\"Elevation to [m]\"] &gt; cutoff_point].reset_index(drop=True)\n        pile.loc[0, \"Elevation from [m]\"] = cutoff_point\n    return pile\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.processing.OWTs","title":"OWTs","text":"<pre><code>OWTs(turbines, owts)\n</code></pre> <p>Class to process the geometry data of multiple OWTs.</p> <p>:param owts: List of OWT objects. :param api: API object used to call get_* methods. :param materials: Pandas dataframe with the materials data. :param sub_assemblies: Dictionary of dictionaries of the subassemblies for each turbine. :param tower_base: Dictionary of the elevation of the OWT tower base in mLAT for each turbine. :param pile_head: Dictionary of the elevation of the pile head in mLAT for each turbine. :param water_depth: Dictionary of the water depth in mLAT for each turbine. :param tw_sub_assemblies: Dataframe of the tower subassemblies data from each turbine. :param tp_sub_assemblies: Dataframe of the transition piece subassemblies data from each turbine. :param mp_sub_assemblies: Dataframe of the monopile subassemblies data from each turbine. :param pile_toe: Dataframe of the elevation of the pile toe in mLAT from each turbine. :param rna: Dataframe of the RNA data from each turbine. :param tower: Dataframe of the tower data from each turbine. :param transition_piece: Dataframe of the transition piece data from each turbine. :param monopile: Dataframe of the monopile data from each turbine. :param tw_lumped_mass: Dataframe of the lumped masses data of the tower from each turbine. :param tp_lumped_mass: Dataframe of the lumped masses data of the transition piece from each turbine. :param mp_lumped_mass: Dataframe of the lumped masses data of the monopile from each turbine. :param tp_distributed_mass: Dataframe of the distributed masses data of the transition piece from each turbine. :param mp_distributed_mass: Dataframe of the distributed masses data of the monopile from each turbine. :param grout: Dataframe of the grout data from each turbine. :param full_structure: Dataframe of the full structure data from each turbine. :param tp_skirt: Dataframe of the transition piece skirt data from each turbine. :param substructure: Dataframe of the substructure data from each turbine. :param all_turbines: Dataframe of the general geometry data from each turbine. :param all_tubular_structures: Dataframe of the tubular structures data from each turbine. :param all_distributed_mass: Dataframe of the distributed masses data from each turbine. :param all_lumped_mass: Dataframe of the lumped masses data from each turbine.</p> <p>Create an instance of the OWTs class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>turbines</code> <code>list of str</code> <p>List of turbine titles.</p> required <code>owts</code> <code>list of OWT</code> <p>List of OWT objects.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; stub = SimpleNamespace(\n...     api=\"api\",\n...     materials=\"materials\",\n...     sub_assemblies={},\n...     tower_base=0.0,\n...     pile_head=0.0,\n...     water_depth=0.0,\n...     tw_sub_assemblies=None,\n...     tp_sub_assemblies=None,\n...     mp_sub_assemblies=None,\n... )\n&gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n&gt;&gt;&gt; owts.api\n'api'\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def __init__(\n    self,\n    turbines: list[str],\n    owts: list[OWT],\n) -&gt; None:\n    \"\"\"\n    Create an instance of the OWTs class with required parameters.\n\n    Parameters\n    ----------\n    turbines : list of str\n        List of turbine titles.\n    owts : list of OWT\n        List of OWT objects.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; stub = SimpleNamespace(\n    ...     api=\"api\",\n    ...     materials=\"materials\",\n    ...     sub_assemblies={},\n    ...     tower_base=0.0,\n    ...     pile_head=0.0,\n    ...     water_depth=0.0,\n    ...     tw_sub_assemblies=None,\n    ...     tp_sub_assemblies=None,\n    ...     mp_sub_assemblies=None,\n    ... )\n    &gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n    &gt;&gt;&gt; owts.api\n    'api'\n    \"\"\"\n    self.owts = dict(zip(turbines, owts))\n    self.api = self.owts[turbines[0]].api\n    self.materials = self.owts[turbines[0]].materials\n    for attr in [\n        \"sub_assemblies\",\n        \"tower_base\",\n        \"pile_head\",\n        \"water_depth\",\n    ]:\n        dict_ = {k: getattr(owt, attr) for k, owt in zip(turbines, self.owts.values())}\n        setattr(self, attr, dict_)\n    for attr in [\n        \"tw_sub_assemblies\",\n        \"tp_sub_assemblies\",\n        \"mp_sub_assemblies\",\n    ]:\n        sa_turb_list = [getattr(owt, attr) for owt in self.owts.values() if getattr(owt, attr) is not None]\n        df = None if sa_turb_list == [] else pd.concat(sa_turb_list)\n        setattr(self, attr, df)\n    for attr in ATTR_PROC:\n        setattr(self, attr, [])\n    for attr in ATTR_SPEC:\n        setattr(self, attr, [])\n    for attr in ATTR_FULL:\n        setattr(self, attr, [])\n    self._init = False\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.processing.OWTs-functions","title":"Functions","text":"process_structures \u00b6 <pre><code>process_structures()\n</code></pre> <p>Set dataframes with required properties to model the tower.</p> <p>Sets dataframes containing the required properties to model the tower geometry, including the RNA system.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; stub = SimpleNamespace(\n...     api=\"api\",\n...     materials=\"materials\",\n...     sub_assemblies={\"TW\": 1, \"TP\": 1, \"MP\": 1},\n...     tower_base=0.0,\n...     pile_head=0.0,\n...     water_depth=0.0,\n...     tw_sub_assemblies=None,\n...     tp_sub_assemblies=None,\n...     mp_sub_assemblies=None,\n...     process_structure=lambda *args, **kwargs: None,\n...     extend_dfs=lambda *args, **kwargs: None,\n...     pile_toe=0.0,\n...     rna=None,\n...     tower=None,\n...     transition_piece=None,\n...     monopile=None,\n...     tw_lumped_mass=None,\n...     tp_lumped_mass=None,\n...     mp_lumped_mass=None,\n...     tp_distributed_mass=None,\n...     mp_distributed_mass=None,\n...     grout=None,\n...     full_structure=None,\n...     tp_skirt=None,\n...     substructure=None,\n...     all_tubular_structures=None,\n...     all_distributed_mass=None,\n...     all_lumped_mass=None,\n...     all_turbines=None,\n... )\n&gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n&gt;&gt;&gt; with mock.patch.object(OWTs, \"_concat_list\", lambda self, attrs: None), mock.patch.object(\n...     OWTs, \"_assembly_turbine\", lambda self: None\n... ):\n...     owts.process_structures()\n&gt;&gt;&gt; owts._init\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def process_structures(self) -&gt; None:\n    \"\"\"\n    Set dataframes with required properties to model the tower.\n\n    Sets dataframes containing the required properties to model the\n    tower geometry, including the RNA system.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; stub = SimpleNamespace(\n    ...     api=\"api\",\n    ...     materials=\"materials\",\n    ...     sub_assemblies={\"TW\": 1, \"TP\": 1, \"MP\": 1},\n    ...     tower_base=0.0,\n    ...     pile_head=0.0,\n    ...     water_depth=0.0,\n    ...     tw_sub_assemblies=None,\n    ...     tp_sub_assemblies=None,\n    ...     mp_sub_assemblies=None,\n    ...     process_structure=lambda *args, **kwargs: None,\n    ...     extend_dfs=lambda *args, **kwargs: None,\n    ...     pile_toe=0.0,\n    ...     rna=None,\n    ...     tower=None,\n    ...     transition_piece=None,\n    ...     monopile=None,\n    ...     tw_lumped_mass=None,\n    ...     tp_lumped_mass=None,\n    ...     mp_lumped_mass=None,\n    ...     tp_distributed_mass=None,\n    ...     mp_distributed_mass=None,\n    ...     grout=None,\n    ...     full_structure=None,\n    ...     tp_skirt=None,\n    ...     substructure=None,\n    ...     all_tubular_structures=None,\n    ...     all_distributed_mass=None,\n    ...     all_lumped_mass=None,\n    ...     all_turbines=None,\n    ... )\n    &gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n    &gt;&gt;&gt; with mock.patch.object(OWTs, \"_concat_list\", lambda self, attrs: None), mock.patch.object(\n    ...     OWTs, \"_assembly_turbine\", lambda self: None\n    ... ):\n    ...     owts.process_structures()\n    &gt;&gt;&gt; owts._init\n    True\n    \"\"\"\n    attr_list = ATTR_PROC + ATTR_SPEC + ATTR_FULL\n    attr_list.remove(\"all_turbines\")\n    if self._init:\n        return\n    self._init = True\n    for owt in self.owts.values():\n        if len(owt.sub_assemblies) != 3:\n            for sa in owt.sub_assemblies.keys():  # noqa: SIM118\n                owt.process_structure(option=sa)\n        else:\n            owt.process_structure()\n        owt.extend_dfs()\n        for attr in attr_list:\n            if attr == \"pile_toe\":\n                pile_toe_list = cast(list[Union[np.float64, float, None]], self.pile_toe)\n                pile_toe_list.append(getattr(owt, attr))\n                self.pile_toe = pile_toe_list\n            elif attr == \"all_tubular_structures\":\n                self.all_tubular_structures.extend([owt.tower, owt.transition_piece, owt.monopile])\n            elif attr == \"all_distributed_mass\":\n                self.all_distributed_mass.extend(\n                    [\n                        owt.tp_distributed_mass,\n                        owt.grout,\n                        owt.mp_distributed_mass,\n                    ]\n                )\n            elif attr == \"all_lumped_mass\":\n                if isinstance(owt.rna, pd.DataFrame):\n                    cols = [\n                        \"X [m]\",\n                        \"Y [m]\",\n                        \"Z [mLAT]\",\n                        \"Mass [t]\",\n                        \"Description\",\n                        \"Subassembly\",\n                    ]\n                    rna_ = owt.rna[cols]\n                else:\n                    rna_ = owt.rna\n                self.all_lumped_mass.extend(\n                    [\n                        rna_,\n                        owt.tw_lumped_mass,\n                        owt.tp_lumped_mass,\n                        owt.mp_lumped_mass,\n                    ]\n                )\n            else:\n                attr_val = getattr(self, attr)\n                owt_attr_val = getattr(owt, attr)\n                attr_val.append(owt_attr_val)\n    attr_list.remove(\"pile_toe\")\n    self.pile_toe = dict(zip(self.owts.keys(), self.pile_toe))\n    self._concat_list(attr_list)\n    self._assembly_turbine()\n</code></pre> select_owt \u00b6 <pre><code>select_owt(turbine)\n</code></pre> <p>Select OWT object from the OWTs object.</p> <p>Parameters:</p> Name Type Description Default <code>turbine</code> <code>str or int</code> <p>Title of the turbine or its index in the original list of turbine titles (from get method).</p> required <p>Returns:</p> Type Description <code>OWT</code> <p>OWT object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If turbine must be specified as single turbine title or its index from the get method input turbine list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; stub = SimpleNamespace(\n...     api=\"api\",\n...     materials=\"materials\",\n...     sub_assemblies={},\n...     tower_base=0.0,\n...     pile_head=0.0,\n...     water_depth=0.0,\n...     tw_sub_assemblies=None,\n...     tp_sub_assemblies=None,\n...     mp_sub_assemblies=None,\n... )\n&gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n&gt;&gt;&gt; owts.select_owt(\"T01\") is stub\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/processing.py</code> <pre><code>def select_owt(self, turbine: Union[str, int]) -&gt; OWT:\n    \"\"\"\n    Select OWT object from the OWTs object.\n\n    Parameters\n    ----------\n    turbine : str or int\n        Title of the turbine or its index in the original list of\n        turbine titles (from get method).\n\n    Returns\n    -------\n    OWT\n        OWT object.\n\n    Raises\n    ------\n    ValueError\n        If turbine must be specified as single turbine title or\n        its index from the get method input turbine list.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; stub = SimpleNamespace(\n    ...     api=\"api\",\n    ...     materials=\"materials\",\n    ...     sub_assemblies={},\n    ...     tower_base=0.0,\n    ...     pile_head=0.0,\n    ...     water_depth=0.0,\n    ...     tw_sub_assemblies=None,\n    ...     tp_sub_assemblies=None,\n    ...     mp_sub_assemblies=None,\n    ... )\n    &gt;&gt;&gt; owts = OWTs([\"T01\"], [stub])\n    &gt;&gt;&gt; owts.select_owt(\"T01\") is stub\n    True\n    \"\"\"\n    if isinstance(turbine, int):\n        return self.owts[list(self.owts.keys())[turbine]]\n    elif isinstance(turbine, str):\n        return self.owts[turbine]\n    else:\n        raise ValueError(\n            \"You must specify a single turbine title or \\\n            its index from the the get method input turbine list.\"\n        )\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.processing-functions","title":"Functions","text":""},{"location":"api/geometry/#geometrystructures-data-structures","title":"geometry.structures - Data Structures","text":""},{"location":"api/geometry/#owi.metadatabase.geometry.structures","title":"structures","text":"<p>Module containing the data classes for the geometry module.</p>"},{"location":"api/geometry/#owi.metadatabase.geometry.structures-classes","title":"Classes","text":""},{"location":"api/geometry/#owi.metadatabase.geometry.structures.BaseStructure","title":"BaseStructure","text":"<p>Base class for all structures.</p>"},{"location":"api/geometry/#owi.metadatabase.geometry.structures.Material","title":"Material","text":"<pre><code>Material(json)\n</code></pre> <p>               Bases: <code>BaseStructure</code></p> <p>Material derived from the raw data.</p> <p>Create an instance of the Material class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>DataMat</code> <p>JSON data containing the material information.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\n...     \"title\": \"Steel\",\n...     \"slug\": \"steel\",\n...     \"id\": np.int64(1),\n...     \"description\": \"\",\n...     \"young_modulus\": np.float64(210000.0),\n...     \"density\": np.float64(7850.0),\n...     \"poisson_ratio\": np.float64(0.3),\n... }\n&gt;&gt;&gt; material = Material(data)\n&gt;&gt;&gt; material.title\n'Steel'\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/structures.py</code> <pre><code>def __init__(self, json: DataMat) -&gt; None:\n    \"\"\"\n    Create an instance of the Material class with required\n    parameters.\n\n    Parameters\n    ----------\n    json : DataMat\n        JSON data containing the material information.\n\n    Examples\n    --------\n    &gt;&gt;&gt; data = {\n    ...     \"title\": \"Steel\",\n    ...     \"slug\": \"steel\",\n    ...     \"id\": np.int64(1),\n    ...     \"description\": \"\",\n    ...     \"young_modulus\": np.float64(210000.0),\n    ...     \"density\": np.float64(7850.0),\n    ...     \"poisson_ratio\": np.float64(0.3),\n    ... }\n    &gt;&gt;&gt; material = Material(data)\n    &gt;&gt;&gt; material.title\n    'Steel'\n    \"\"\"\n    self.title = json[\"title\"]\n    self.description = json[\"description\"]\n    self.density = json[\"density\"]\n    self.poisson_ratio = json[\"poisson_ratio\"]\n    self.young_modulus = json[\"young_modulus\"]\n    self.id = json[\"id\"]\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.structures.Material-functions","title":"Functions","text":"as_dict \u00b6 <pre><code>as_dict()\n</code></pre> <p>Transform data into dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"title\": Name of the material.</li> <li>\"description\": Description of the material.</li> <li>\"poisson_ratio\": Poisson ratio of the material.</li> <li>\"young_modulus\": Young modulus of the material.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\n...     \"title\": \"Steel\",\n...     \"slug\": \"steel\",\n...     \"id\": np.int64(1),\n...     \"description\": \"\",\n...     \"young_modulus\": np.float64(210000.0),\n...     \"density\": np.float64(7850.0),\n...     \"poisson_ratio\": np.float64(0.3),\n... }\n&gt;&gt;&gt; Material(data).as_dict()[\"title\"]\n'Steel'\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/structures.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Union[str, np.float64]]:\n    \"\"\"\n    Transform data into dictionary.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"title\": Name of the material.\n        - \"description\": Description of the material.\n        - \"poisson_ratio\": Poisson ratio of the material.\n        - \"young_modulus\": Young modulus of the material.\n\n    Examples\n    --------\n    &gt;&gt;&gt; data = {\n    ...     \"title\": \"Steel\",\n    ...     \"slug\": \"steel\",\n    ...     \"id\": np.int64(1),\n    ...     \"description\": \"\",\n    ...     \"young_modulus\": np.float64(210000.0),\n    ...     \"density\": np.float64(7850.0),\n    ...     \"poisson_ratio\": np.float64(0.3),\n    ... }\n    &gt;&gt;&gt; Material(data).as_dict()[\"title\"]\n    'Steel'\n    \"\"\"\n    return {\n        \"title\": self.title,\n        \"description\": self.description,\n        \"poisson_ratio\": self.poisson_ratio,\n        \"young_modulus\": self.young_modulus,\n    }\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.structures.Position","title":"Position","text":"<pre><code>Position(\n    x=DEFAULT_NP_FLOAT64_VALUE,\n    y=DEFAULT_NP_FLOAT64_VALUE,\n    z=DEFAULT_NP_FLOAT64_VALUE,\n    alpha=DEFAULT_NP_FLOAT64_VALUE,\n    beta=DEFAULT_NP_FLOAT64_VALUE,\n    gamma=DEFAULT_NP_FLOAT64_VALUE,\n    reference_system=\"LAT\",\n)\n</code></pre> <p>               Bases: <code>BaseStructure</code></p> <p>Position of the components.</p> <p>Create an instance of the Position class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float64</code> <p>X coordinate of the component.</p> <code>DEFAULT_NP_FLOAT64_VALUE</code> <code>y</code> <code>float64</code> <p>Y coordinate of the component.</p> <code>DEFAULT_NP_FLOAT64_VALUE</code> <code>z</code> <code>float64</code> <p>Z coordinate of the component.</p> <code>DEFAULT_NP_FLOAT64_VALUE</code> <code>alpha</code> <code>float64</code> <p>Rotation around the x-axis.</p> <code>DEFAULT_NP_FLOAT64_VALUE</code> <code>beta</code> <code>float64</code> <p>Rotation around the y-axis.</p> <code>DEFAULT_NP_FLOAT64_VALUE</code> <code>gamma</code> <code>float64</code> <p>Rotation around the z-axis.</p> <code>DEFAULT_NP_FLOAT64_VALUE</code> <code>reference_system</code> <code>str</code> <p>Reference system for the vertical position, default is \"LAT\".</p> <code>'LAT'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pos = Position(np.float64(1), np.float64(2), np.float64(3))\n&gt;&gt;&gt; tuple(map(float, (pos.x, pos.y, pos.z)))\n(1.0, 2.0, 3.0)\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/structures.py</code> <pre><code>def __init__(\n    self,\n    x: np.float64 = DEFAULT_NP_FLOAT64_VALUE,\n    y: np.float64 = DEFAULT_NP_FLOAT64_VALUE,\n    z: np.float64 = DEFAULT_NP_FLOAT64_VALUE,\n    alpha: np.float64 = DEFAULT_NP_FLOAT64_VALUE,\n    beta: np.float64 = DEFAULT_NP_FLOAT64_VALUE,\n    gamma: np.float64 = DEFAULT_NP_FLOAT64_VALUE,\n    reference_system: str = \"LAT\",\n) -&gt; None:\n    \"\"\"\n    Create an instance of the Position class with required\n    parameters.\n\n    Parameters\n    ----------\n    x : np.float64, optional\n        X coordinate of the component.\n    y : np.float64, optional\n        Y coordinate of the component.\n    z : np.float64, optional\n        Z coordinate of the component.\n    alpha : np.float64, optional\n        Rotation around the x-axis.\n    beta : np.float64, optional\n        Rotation around the y-axis.\n    gamma : np.float64, optional\n        Rotation around the z-axis.\n    reference_system : str, optional\n        Reference system for the vertical position, default is\n        \"LAT\".\n\n    Examples\n    --------\n    &gt;&gt;&gt; pos = Position(np.float64(1), np.float64(2), np.float64(3))\n    &gt;&gt;&gt; tuple(map(float, (pos.x, pos.y, pos.z)))\n    (1.0, 2.0, 3.0)\n    \"\"\"\n    self.x = x\n    self.y = y\n    self.z = z\n    self.alpha = alpha\n    self.beta = beta\n    self.gamma = gamma\n    self.reference_system = reference_system\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.structures.Position-functions","title":"Functions","text":""},{"location":"api/geometry/#owi.metadatabase.geometry.structures.BuildingBlock","title":"BuildingBlock","text":"<pre><code>BuildingBlock(json, subassembly=None)\n</code></pre> <p>               Bases: <code>BaseStructure</code></p> <p>Building blocks description.</p> <p>Create an instance of the BuildingBlock class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>json</code> <code>DataBB</code> <p>JSON data containing the building block information.</p> required <code>subassembly</code> <code>Any</code> <p>Subassembly object containing the building block.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\n...     \"id\": np.int64(1),\n...     \"description\": \"\",\n...     \"slug\": \"bb\",\n...     \"alpha\": np.float64(0),\n...     \"beta\": np.float64(0),\n...     \"gamma\": np.float64(0),\n...     \"x_position\": np.float64(0),\n...     \"y_position\": np.float64(0),\n...     \"z_position\": np.float64(0),\n...     \"vertical_position_reference_system\": \"LAT\",\n...     \"title\": \"BB_1\",\n...     \"height\": np.float64(0),\n...     \"mass_distribution\": np.float64(np.nan),\n...     \"volume_distribution\": np.float64(np.nan),\n...     \"area_distribution\": np.float64(np.nan),\n...     \"c_d\": np.float64(np.nan),\n...     \"c_m\": np.float64(np.nan),\n...     \"sub_assembly\": np.int64(1),\n...     \"projectsite_name\": \"Site\",\n...     \"asset_name\": \"T01\",\n...     \"subassembly_name\": \"SA\",\n...     \"material_name\": \"Steel\",\n...     \"youngs_modulus\": np.float64(np.nan),\n...     \"density\": np.float64(np.nan),\n...     \"poissons_ratio\": np.float64(np.nan),\n...     \"bottom_outer_diameter\": np.float64(np.nan),\n...     \"top_outer_diameter\": np.float64(np.nan),\n...     \"wall_thickness\": np.float64(np.nan),\n...     \"material\": np.float64(np.nan),\n...     \"moment_of_inertia_x\": np.float64(1.0),\n...     \"moment_of_inertia_y\": np.float64(2.0),\n...     \"moment_of_inertia_z\": np.float64(3.0),\n...     \"mass\": np.float64(100.0),\n... }\n&gt;&gt;&gt; BuildingBlock(data).title\n'BB_1'\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/structures.py</code> <pre><code>def __init__(self, json: DataBB, subassembly: Union[Any, None] = None) -&gt; None:\n    \"\"\"\n    Create an instance of the BuildingBlock class with required\n    parameters.\n\n    Parameters\n    ----------\n    json : DataBB\n        JSON data containing the building block information.\n    subassembly : Any, optional\n        Subassembly object containing the building block.\n\n    Examples\n    --------\n    &gt;&gt;&gt; data = {\n    ...     \"id\": np.int64(1),\n    ...     \"description\": \"\",\n    ...     \"slug\": \"bb\",\n    ...     \"alpha\": np.float64(0),\n    ...     \"beta\": np.float64(0),\n    ...     \"gamma\": np.float64(0),\n    ...     \"x_position\": np.float64(0),\n    ...     \"y_position\": np.float64(0),\n    ...     \"z_position\": np.float64(0),\n    ...     \"vertical_position_reference_system\": \"LAT\",\n    ...     \"title\": \"BB_1\",\n    ...     \"height\": np.float64(0),\n    ...     \"mass_distribution\": np.float64(np.nan),\n    ...     \"volume_distribution\": np.float64(np.nan),\n    ...     \"area_distribution\": np.float64(np.nan),\n    ...     \"c_d\": np.float64(np.nan),\n    ...     \"c_m\": np.float64(np.nan),\n    ...     \"sub_assembly\": np.int64(1),\n    ...     \"projectsite_name\": \"Site\",\n    ...     \"asset_name\": \"T01\",\n    ...     \"subassembly_name\": \"SA\",\n    ...     \"material_name\": \"Steel\",\n    ...     \"youngs_modulus\": np.float64(np.nan),\n    ...     \"density\": np.float64(np.nan),\n    ...     \"poissons_ratio\": np.float64(np.nan),\n    ...     \"bottom_outer_diameter\": np.float64(np.nan),\n    ...     \"top_outer_diameter\": np.float64(np.nan),\n    ...     \"wall_thickness\": np.float64(np.nan),\n    ...     \"material\": np.float64(np.nan),\n    ...     \"moment_of_inertia_x\": np.float64(1.0),\n    ...     \"moment_of_inertia_y\": np.float64(2.0),\n    ...     \"moment_of_inertia_z\": np.float64(3.0),\n    ...     \"mass\": np.float64(100.0),\n    ... }\n    &gt;&gt;&gt; BuildingBlock(data).title\n    'BB_1'\n    \"\"\"\n    self.id = json[\"id\"]\n    self.title = json[\"title\"]\n    if json[\"description\"]:\n        self.description = json[\"description\"]\n    else:\n        self.description = \"\"\n    self.position = Position(\n        x=json[\"x_position\"],\n        y=json[\"y_position\"],\n        z=json[\"z_position\"],\n        alpha=json[\"alpha\"],\n        beta=json[\"beta\"],\n        gamma=json[\"gamma\"],\n        reference_system=json[\"vertical_position_reference_system\"],\n    )\n    self.material = None\n    if \"material\" in json and subassembly:\n        material_id = json[\"material\"]\n        if material_id and not np.isnan(material_id):\n            for mat in subassembly.materials:\n                if np.int64(mat.id) == np.int64(material_id):\n                    self.material = mat\n                    break\n    self.json = json\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.structures.BuildingBlock-attributes","title":"Attributes","text":"type <code>property</code> \u00b6 <pre><code>type\n</code></pre> <p>Type of the building block.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\n...     \"id\": np.int64(1),\n...     \"description\": \"\",\n...     \"slug\": \"bb\",\n...     \"alpha\": np.float64(0),\n...     \"beta\": np.float64(0),\n...     \"gamma\": np.float64(0),\n...     \"x_position\": np.float64(0),\n...     \"y_position\": np.float64(0),\n...     \"z_position\": np.float64(0),\n...     \"vertical_position_reference_system\": \"LAT\",\n...     \"title\": \"BB_1\",\n...     \"height\": np.float64(0),\n...     \"mass_distribution\": np.float64(np.nan),\n...     \"volume_distribution\": np.float64(np.nan),\n...     \"area_distribution\": np.float64(np.nan),\n...     \"c_d\": np.float64(np.nan),\n...     \"c_m\": np.float64(np.nan),\n...     \"sub_assembly\": np.int64(1),\n...     \"projectsite_name\": \"Site\",\n...     \"asset_name\": \"T01\",\n...     \"subassembly_name\": \"SA\",\n...     \"material_name\": \"Steel\",\n...     \"youngs_modulus\": np.float64(np.nan),\n...     \"density\": np.float64(np.nan),\n...     \"poissons_ratio\": np.float64(np.nan),\n...     \"bottom_outer_diameter\": np.float64(np.nan),\n...     \"top_outer_diameter\": np.float64(np.nan),\n...     \"wall_thickness\": np.float64(np.nan),\n...     \"material\": np.float64(np.nan),\n...     \"moment_of_inertia_x\": np.float64(1.0),\n...     \"moment_of_inertia_y\": np.float64(2.0),\n...     \"moment_of_inertia_z\": np.float64(3.0),\n...     \"mass\": np.float64(100.0),\n... }\n&gt;&gt;&gt; BuildingBlock(data).type\n'lumped_mass'\n</code></pre> wall_thickness <code>property</code> \u00b6 <pre><code>wall_thickness\n</code></pre> <p>Wall thickness of the building block (if exists), mm.</p> bottom_outer_diameter <code>property</code> \u00b6 <pre><code>bottom_outer_diameter\n</code></pre> <p>Bottom outer diameter of the building block (if exists), mm.</p> top_outer_diameter <code>property</code> \u00b6 <pre><code>top_outer_diameter\n</code></pre> <p>Top outer diameter of the building block (if exists), mm.</p> diameter_str <code>property</code> \u00b6 <pre><code>diameter_str\n</code></pre> <p>Diameter of the building block as a string (if exists), mm.</p> height <code>property</code> \u00b6 <pre><code>height\n</code></pre> <p>Height of the building block , mm.</p> volume <code>property</code> \u00b6 <pre><code>volume\n</code></pre> <p>Volume of the building block, m\u00b3.</p> mass <code>property</code> \u00b6 <pre><code>mass\n</code></pre> <p>Mass of the building block, kg.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\n...     \"id\": np.int64(1),\n...     \"description\": \"\",\n...     \"slug\": \"bb\",\n...     \"alpha\": np.float64(0),\n...     \"beta\": np.float64(0),\n...     \"gamma\": np.float64(0),\n...     \"x_position\": np.float64(0),\n...     \"y_position\": np.float64(0),\n...     \"z_position\": np.float64(0),\n...     \"vertical_position_reference_system\": \"LAT\",\n...     \"title\": \"BB_1\",\n...     \"height\": np.float64(0),\n...     \"mass_distribution\": np.float64(np.nan),\n...     \"volume_distribution\": np.float64(np.nan),\n...     \"area_distribution\": np.float64(np.nan),\n...     \"c_d\": np.float64(np.nan),\n...     \"c_m\": np.float64(np.nan),\n...     \"sub_assembly\": np.int64(1),\n...     \"projectsite_name\": \"Site\",\n...     \"asset_name\": \"T01\",\n...     \"subassembly_name\": \"SA\",\n...     \"material_name\": \"Steel\",\n...     \"youngs_modulus\": np.float64(np.nan),\n...     \"density\": np.float64(np.nan),\n...     \"poissons_ratio\": np.float64(np.nan),\n...     \"bottom_outer_diameter\": np.float64(np.nan),\n...     \"top_outer_diameter\": np.float64(np.nan),\n...     \"wall_thickness\": np.float64(np.nan),\n...     \"material\": np.float64(np.nan),\n...     \"moment_of_inertia_x\": np.float64(1.0),\n...     \"moment_of_inertia_y\": np.float64(2.0),\n...     \"moment_of_inertia_z\": np.float64(3.0),\n...     \"mass\": np.float64(100.0),\n... }\n&gt;&gt;&gt; float(BuildingBlock(data).mass)\n100.0\n</code></pre> moment_of_inertia <code>property</code> \u00b6 <pre><code>moment_of_inertia\n</code></pre> <p>Moment of inertia of the building block, kg*m\u00b2.</p> <p>IMPORTANT! Only works for building blocks of the type lumped_mass.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the moment of inertia around the three axes, x, y, z.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\n...     \"id\": np.int64(1),\n...     \"description\": \"\",\n...     \"slug\": \"bb\",\n...     \"alpha\": np.float64(0),\n...     \"beta\": np.float64(0),\n...     \"gamma\": np.float64(0),\n...     \"x_position\": np.float64(0),\n...     \"y_position\": np.float64(0),\n...     \"z_position\": np.float64(0),\n...     \"vertical_position_reference_system\": \"LAT\",\n...     \"title\": \"BB_1\",\n...     \"height\": np.float64(0),\n...     \"mass_distribution\": np.float64(np.nan),\n...     \"volume_distribution\": np.float64(np.nan),\n...     \"area_distribution\": np.float64(np.nan),\n...     \"c_d\": np.float64(np.nan),\n...     \"c_m\": np.float64(np.nan),\n...     \"sub_assembly\": np.int64(1),\n...     \"projectsite_name\": \"Site\",\n...     \"asset_name\": \"T01\",\n...     \"subassembly_name\": \"SA\",\n...     \"material_name\": \"Steel\",\n...     \"youngs_modulus\": np.float64(np.nan),\n...     \"density\": np.float64(np.nan),\n...     \"poissons_ratio\": np.float64(np.nan),\n...     \"bottom_outer_diameter\": np.float64(np.nan),\n...     \"top_outer_diameter\": np.float64(np.nan),\n...     \"wall_thickness\": np.float64(np.nan),\n...     \"material\": np.float64(np.nan),\n...     \"moment_of_inertia_x\": np.float64(1.0),\n...     \"moment_of_inertia_y\": np.float64(2.0),\n...     \"moment_of_inertia_z\": np.float64(3.0),\n...     \"mass\": np.float64(100.0),\n... }\n&gt;&gt;&gt; float(BuildingBlock(data).moment_of_inertia[\"y\"])\n2.0\n</code></pre> outline <code>property</code> \u00b6 <pre><code>outline\n</code></pre> <p>Trace of the outlines.</p> <p>Returns:</p> Type Description <code>tuple or None</code> <p>A tuple of two lists containing the x and corresponding z coordinates of the outline, or None if not applicable.</p> marker <code>property</code> \u00b6 <pre><code>marker\n</code></pre> <p>Indication for the lumped mass in the building block.</p> <p>Returns:</p> Type Description <code>dict or None</code> <p>Dictionary containing the x, y, z coordinates of the marker and the radius of the marker, or None if not applicable.</p> line <code>property</code> \u00b6 <pre><code>line\n</code></pre> <p>Line for the distributed mass in the building block.</p> <p>Returns:</p> Type Description <code>dict or None</code> <p>Dictionary containing the x, y, z coordinates of the line and the color of the line, or None if not applicable.</p>"},{"location":"api/geometry/#owi.metadatabase.geometry.structures.BuildingBlock-functions","title":"Functions","text":"as_dict \u00b6 <pre><code>as_dict()\n</code></pre> <p>Transform data into dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"title\": Name of the building block.</li> <li>\"x\": X coordinate of the building block.</li> <li>\"y\": Y coordinate of the building block.</li> <li>\"z\": Z coordinate of the building block.</li> <li>\"OD\": Outer diameter of the building block.</li> <li>\"wall_thickness\": Wall thickness of the building block.</li> <li>\"height\": Height of the building block.</li> <li>\"volume\": Volume of the building block.</li> <li>\"mass\": Mass of the building block.</li> <li>\"moment_of_inertia\": Moment of inertia of the building   block.</li> <li>\"description\": Description of the building block.</li> </ul> Source code in <code>src/owi/metadatabase/geometry/structures.py</code> <pre><code>def as_dict(\n    self,\n) -&gt; dict[str, Union[str, np.float64, dict[str, Union[np.float64, None]], None]]:\n    \"\"\"\n    Transform data into dictionary.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"title\": Name of the building block.\n        - \"x\": X coordinate of the building block.\n        - \"y\": Y coordinate of the building block.\n        - \"z\": Z coordinate of the building block.\n        - \"OD\": Outer diameter of the building block.\n        - \"wall_thickness\": Wall thickness of the building block.\n        - \"height\": Height of the building block.\n        - \"volume\": Volume of the building block.\n        - \"mass\": Mass of the building block.\n        - \"moment_of_inertia\": Moment of inertia of the building\n          block.\n        - \"description\": Description of the building block.\n    \"\"\"\n    return {\n        \"title\": self.title,\n        \"x\": self.position.x,\n        \"y\": self.position.y,\n        \"z\": self.position.z,\n        \"OD\": self.diameter_str,\n        \"wall_thickness\": self.wall_thickness,\n        \"height\": self.height,\n        \"volume\": self.volume,\n        \"mass\": self.mass,\n        \"moment_of_inertia\": self.moment_of_inertia,\n        \"description\": self.description,\n    }\n</code></pre> __str__ \u00b6 <pre><code>__str__()\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\n...     \"id\": np.int64(1),\n...     \"description\": \"\",\n...     \"slug\": \"bb\",\n...     \"alpha\": np.float64(0),\n...     \"beta\": np.float64(0),\n...     \"gamma\": np.float64(0),\n...     \"x_position\": np.float64(0),\n...     \"y_position\": np.float64(0),\n...     \"z_position\": np.float64(0),\n...     \"vertical_position_reference_system\": \"LAT\",\n...     \"title\": \"BB_1\",\n...     \"height\": np.float64(0),\n...     \"mass_distribution\": np.float64(np.nan),\n...     \"volume_distribution\": np.float64(np.nan),\n...     \"area_distribution\": np.float64(np.nan),\n...     \"c_d\": np.float64(np.nan),\n...     \"c_m\": np.float64(np.nan),\n...     \"sub_assembly\": np.int64(1),\n...     \"projectsite_name\": \"Site\",\n...     \"asset_name\": \"T01\",\n...     \"subassembly_name\": \"SA\",\n...     \"material_name\": \"Steel\",\n...     \"youngs_modulus\": np.float64(np.nan),\n...     \"density\": np.float64(np.nan),\n...     \"poissons_ratio\": np.float64(np.nan),\n...     \"bottom_outer_diameter\": np.float64(np.nan),\n...     \"top_outer_diameter\": np.float64(np.nan),\n...     \"wall_thickness\": np.float64(np.nan),\n...     \"material\": np.float64(np.nan),\n...     \"moment_of_inertia_x\": np.float64(1.0),\n...     \"moment_of_inertia_y\": np.float64(2.0),\n...     \"moment_of_inertia_z\": np.float64(3.0),\n...     \"mass\": np.float64(100.0),\n... }\n&gt;&gt;&gt; str(BuildingBlock(data))\n'BB_1 (lumped_mass)'\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/structures.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Examples\n    --------\n    &gt;&gt;&gt; data = {\n    ...     \"id\": np.int64(1),\n    ...     \"description\": \"\",\n    ...     \"slug\": \"bb\",\n    ...     \"alpha\": np.float64(0),\n    ...     \"beta\": np.float64(0),\n    ...     \"gamma\": np.float64(0),\n    ...     \"x_position\": np.float64(0),\n    ...     \"y_position\": np.float64(0),\n    ...     \"z_position\": np.float64(0),\n    ...     \"vertical_position_reference_system\": \"LAT\",\n    ...     \"title\": \"BB_1\",\n    ...     \"height\": np.float64(0),\n    ...     \"mass_distribution\": np.float64(np.nan),\n    ...     \"volume_distribution\": np.float64(np.nan),\n    ...     \"area_distribution\": np.float64(np.nan),\n    ...     \"c_d\": np.float64(np.nan),\n    ...     \"c_m\": np.float64(np.nan),\n    ...     \"sub_assembly\": np.int64(1),\n    ...     \"projectsite_name\": \"Site\",\n    ...     \"asset_name\": \"T01\",\n    ...     \"subassembly_name\": \"SA\",\n    ...     \"material_name\": \"Steel\",\n    ...     \"youngs_modulus\": np.float64(np.nan),\n    ...     \"density\": np.float64(np.nan),\n    ...     \"poissons_ratio\": np.float64(np.nan),\n    ...     \"bottom_outer_diameter\": np.float64(np.nan),\n    ...     \"top_outer_diameter\": np.float64(np.nan),\n    ...     \"wall_thickness\": np.float64(np.nan),\n    ...     \"material\": np.float64(np.nan),\n    ...     \"moment_of_inertia_x\": np.float64(1.0),\n    ...     \"moment_of_inertia_y\": np.float64(2.0),\n    ...     \"moment_of_inertia_z\": np.float64(3.0),\n    ...     \"mass\": np.float64(100.0),\n    ... }\n    &gt;&gt;&gt; str(BuildingBlock(data))\n    'BB_1 (lumped_mass)'\n    \"\"\"\n    return self.title + \" (\" + self.type + \")\"\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.structures.SubAssembly","title":"SubAssembly","text":"<pre><code>SubAssembly(materials, json, api_object=None)\n</code></pre> <p>               Bases: <code>BaseStructure</code></p> <p>Subassemblies description.</p> <p>Create an instance of the SubAssembly class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>materials</code> <code>DataFrame or bool or int64 or None</code> <p>Pandas dataframe containing the material information.</p> required <code>json</code> <code>DataSA</code> <p>JSON data containing the subassembly information.</p> required <code>api_object</code> <code>Any</code> <p>API object to access the building blocks.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; materials = pd.DataFrame([\n...     {\n...         \"title\": \"Steel\",\n...         \"slug\": \"steel\",\n...         \"id\": np.int64(1),\n...         \"description\": \"\",\n...         \"young_modulus\": np.float64(210000.0),\n...         \"density\": np.float64(7850.0),\n...         \"poisson_ratio\": np.float64(0.3),\n...     }\n... ])\n&gt;&gt;&gt; data = {\n...     \"id\": np.int64(1),\n...     \"title\": \"SA_1\",\n...     \"description\": \"\",\n...     \"slug\": \"sa\",\n...     \"x_position\": np.float64(0),\n...     \"y_position\": np.float64(0),\n...     \"z_position\": np.float64(0),\n...     \"vertical_position_reference_system\": \"LAT\",\n...     \"subassembly_type\": \"TW\",\n...     \"source\": \"api\",\n...     \"asset\": np.int64(1),\n...     \"model_definition\": np.int64(1),\n... }\n&gt;&gt;&gt; sa = SubAssembly(materials, data)\n&gt;&gt;&gt; sa.title\n'SA_1'\n</code></pre> Source code in <code>src/owi/metadatabase/geometry/structures.py</code> <pre><code>def __init__(\n    self,\n    materials: Union[pd.DataFrame, bool, np.int64, None],\n    json: DataSA,\n    api_object: Union[Any, None] = None,\n) -&gt; None:\n    \"\"\"\n    Create an instance of the SubAssembly class with required\n    parameters.\n\n    Parameters\n    ----------\n    materials : pd.DataFrame or bool or np.int64 or None\n        Pandas dataframe containing the material information.\n    json : DataSA\n        JSON data containing the subassembly information.\n    api_object : Any, optional\n        API object to access the building blocks.\n\n    Examples\n    --------\n    &gt;&gt;&gt; materials = pd.DataFrame([\n    ...     {\n    ...         \"title\": \"Steel\",\n    ...         \"slug\": \"steel\",\n    ...         \"id\": np.int64(1),\n    ...         \"description\": \"\",\n    ...         \"young_modulus\": np.float64(210000.0),\n    ...         \"density\": np.float64(7850.0),\n    ...         \"poisson_ratio\": np.float64(0.3),\n    ...     }\n    ... ])\n    &gt;&gt;&gt; data = {\n    ...     \"id\": np.int64(1),\n    ...     \"title\": \"SA_1\",\n    ...     \"description\": \"\",\n    ...     \"slug\": \"sa\",\n    ...     \"x_position\": np.float64(0),\n    ...     \"y_position\": np.float64(0),\n    ...     \"z_position\": np.float64(0),\n    ...     \"vertical_position_reference_system\": \"LAT\",\n    ...     \"subassembly_type\": \"TW\",\n    ...     \"source\": \"api\",\n    ...     \"asset\": np.int64(1),\n    ...     \"model_definition\": np.int64(1),\n    ... }\n    &gt;&gt;&gt; sa = SubAssembly(materials, data)\n    &gt;&gt;&gt; sa.title\n    'SA_1'\n    \"\"\"\n    self.api = api_object\n    self.id = json[\"id\"]\n    self.title = json[\"title\"]\n    self.description = json[\"description\"]\n    self.position = Position(\n        x=json[\"x_position\"],\n        y=json[\"y_position\"],\n        z=json[\"z_position\"],\n        reference_system=json[\"vertical_position_reference_system\"],\n    )\n    self.type = json[\"subassembly_type\"]\n    self.source = json[\"source\"]\n    self.asset = json[\"asset\"]\n    self.bb = None\n    materials_df = cast(pd.DataFrame, materials)\n    self.materials = [Material(cast(DataMat, m.to_dict())) for _, m in materials_df.iterrows()]\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.structures.SubAssembly-attributes","title":"Attributes","text":"color <code>property</code> \u00b6 <pre><code>color\n</code></pre> <p>Color based on subassembly type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; materials = pd.DataFrame([\n...     {\n...         \"title\": \"Steel\",\n...         \"slug\": \"steel\",\n...         \"id\": np.int64(1),\n...         \"description\": \"\",\n...         \"young_modulus\": np.float64(210000.0),\n...         \"density\": np.float64(7850.0),\n...         \"poisson_ratio\": np.float64(0.3),\n...     }\n... ])\n&gt;&gt;&gt; data = {\n...     \"id\": np.int64(1),\n...     \"title\": \"SA_1\",\n...     \"description\": \"\",\n...     \"slug\": \"sa\",\n...     \"x_position\": np.float64(0),\n...     \"y_position\": np.float64(0),\n...     \"z_position\": np.float64(0),\n...     \"vertical_position_reference_system\": \"LAT\",\n...     \"subassembly_type\": \"TW\",\n...     \"source\": \"api\",\n...     \"asset\": np.int64(1),\n...     \"model_definition\": np.int64(1),\n... }\n&gt;&gt;&gt; SubAssembly(materials, data).color\n'grey'\n</code></pre> building_blocks <code>property</code> \u00b6 <pre><code>building_blocks\n</code></pre> <p>Building blocks of the subassembly.</p> <p>Returns:</p> Type Description <code>list of BuildingBlock or None</code> <p>List of instances of building block class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no API configured or no building blocks found.</p> height <code>property</code> \u00b6 <pre><code>height\n</code></pre> <p>Height of the subassembly.</p> mass <code>property</code> \u00b6 <pre><code>mass\n</code></pre> <p>Mass of the subassembly.</p> properties <code>property</code> \u00b6 <pre><code>properties\n</code></pre> <p>Mass and height of the subassembly.</p> outline <code>property</code> \u00b6 <pre><code>outline\n</code></pre> <p>Defines the traces of the outline of the subassembly.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of two lists containing the x and corresponding z coordinates of the outline.</p> absolute_bottom <code>property</code> \u00b6 <pre><code>absolute_bottom\n</code></pre> <p>Absolute bottom of the subassembly, m.</p> absolute_top <code>property</code> \u00b6 <pre><code>absolute_top\n</code></pre> <p>Absolute top of the subassembly, m.</p>"},{"location":"api/geometry/#owi.metadatabase.geometry.structures.SubAssembly-functions","title":"Functions","text":"plot \u00b6 <pre><code>plot(x_offset=DEFAULT_NP_FLOAT64_VALUE)\n</code></pre> <p>Plot the subassembly.</p> Source code in <code>src/owi/metadatabase/geometry/structures.py</code> <pre><code>def plot(self, x_offset: np.float64 = DEFAULT_NP_FLOAT64_VALUE) -&gt; None:\n    \"\"\"Plot the subassembly.\"\"\"\n    x0, z = self.outline\n    plt.plot(\n        [x + x_offset for x in x0],\n        z,\n        color=PLOT_SETTINGS_SUBASSEMBLY[self.type][\"color\"],\n    )\n    patches = []\n    if self.building_blocks:\n        for bb in self.building_blocks:\n            if bb.marker:\n                marker = bb.marker\n                patches.append(\n                    mpatches.Circle(\n                        (\n                            float(marker[\"x\"]),\n                            float(marker[\"z\"]) + float(self.position.z),\n                        ),\n                        float(marker[\"radius\"]),\n                        facecolor=\"black\",\n                        alpha=0.1,\n                        edgecolor=\"black\",\n                    )\n                )\n            if bb.line:\n                line = bb.line\n                xs = cast(list[float], line[\"x\"])\n                zs = cast(list[float], line[\"z\"])\n                plt.plot(\n                    [float(x) + float(x_offset) for x in xs],\n                    [float(z) + float(self.position.z) for z in zs],\n                    color=line[\"color\"],\n                )\n    for p in patches:\n        plt.gca().add_patch(p)\n        plt.ylabel(\"Height , mm\")\n        plt.axis(\"equal\")\n        plt.grid(which=\"both\", linestyle=\":\")\n</code></pre> plotly \u00b6 <pre><code>plotly(\n    x_offset=DEFAULT_NP_FLOAT64_VALUE,\n    y_offset=DEFAULT_NP_FLOAT64_VALUE,\n)\n</code></pre> <p>Plot the subassembly.</p> <p>Parameters:</p> Name Type Description Default <code>x_offset</code> <code>float64</code> <p>Offset in the x direction.</p> <code>DEFAULT_NP_FLOAT64_VALUE</code> <code>y_offset</code> <code>float64</code> <p>Offset in the y direction.</p> <code>DEFAULT_NP_FLOAT64_VALUE</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Plotly data and layout.</p> Source code in <code>src/owi/metadatabase/geometry/structures.py</code> <pre><code>def plotly(\n    self,\n    x_offset: np.float64 = DEFAULT_NP_FLOAT64_VALUE,\n    y_offset: np.float64 = DEFAULT_NP_FLOAT64_VALUE,\n):\n    \"\"\"\n    Plot the subassembly.\n\n    Parameters\n    ----------\n    x_offset : np.float64, optional\n        Offset in the x direction.\n    y_offset : np.float64, optional\n        Offset in the y direction.\n\n    Returns\n    -------\n    tuple\n        Plotly data and layout.\n    \"\"\"\n    x0, z = self.outline\n    data = [\n        go.Scattergl(\n            x=[x + x_offset for x in x0],\n            y=z,\n            mode=\"lines\",\n            name=self.title,\n            line={\"color\": self.color, \"width\": 1},\n        )\n    ]\n    layout = go.Layout(\n        scene={\"aspectmode\": \"data\"},\n        yaxis={\n            \"title\": go.layout.yaxis.Title(text=\"Height , mm\"),\n            \"scaleanchor\": \"x\",\n            \"scaleratio\": 1,\n            \"type\": \"linear\",\n        },\n    )\n    markers: list[dict[str, Any]] = []\n    if self.bb:\n        for bb in self.bb:\n            if bb.marker:\n                marker = bb.marker\n                marker_dict = {\n                    \"x\": [x_offset + float(marker[\"x\"])],\n                    \"y\": [float(marker[\"z\"]) + self.position.z],\n                    \"mode\": \"markers\",\n                    \"marker\": {\n                        \"size\": [np.float64(round(float(marker[\"radius\"]) ** (1 / 3)))],\n                        \"color\": \"grey\",\n                    },\n                    \"hovertext\": marker[\"hovertext\"],\n                    \"hoverinfo\": \"text\",\n                    \"name\": bb.title,\n                }\n                markers.append(marker_dict)\n    data.extend(markers)\n    return data, layout\n</code></pre> as_df \u00b6 <pre><code>as_df(include_absolute_postion=False)\n</code></pre> <p>Transform data into pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>include_absolute_postion</code> <code>bool</code> <p>Include absolute position of the building blocks, default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas dataframe with the building block information.</p> Source code in <code>src/owi/metadatabase/geometry/structures.py</code> <pre><code>def as_df(self, include_absolute_postion: bool = False) -&gt; pd.DataFrame:\n    \"\"\"\n    Transform data into pandas dataframe.\n\n    Parameters\n    ----------\n    include_absolute_postion : bool, optional\n        Include absolute position of the building blocks, default\n        is False.\n\n    Returns\n    -------\n    pd.DataFrame\n        Pandas dataframe with the building block information.\n    \"\"\"\n    out = []\n    if self.building_blocks:\n        for bb in self.building_blocks:\n            out.append(bb.as_dict())\n    df = pd.DataFrame(out)\n    df = df.set_index(\"title\")\n    df = df.sort_values(\"z\", ascending=False)\n    cols_at_end = [\"description\"]\n    df = df[[c for c in df if c not in cols_at_end] + [c for c in cols_at_end if c in df]]\n    if include_absolute_postion:\n        df[\"absolute_position, m\"] = (df[\"z\"] + self.position.z) / 1000\n    return df\n</code></pre> __str__ \u00b6 <pre><code>__str__()\n</code></pre> <p>Return a string representation of the subassembly.</p> Source code in <code>src/owi/metadatabase/geometry/structures.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the subassembly.\"\"\"\n    \"\"\"\n    Examples\n    --------\n    &gt;&gt;&gt; materials = pd.DataFrame([\n    ...     {\n    ...         \"title\": \"Steel\",\n    ...         \"slug\": \"steel\",\n    ...         \"id\": np.int64(1),\n    ...         \"description\": \"\",\n    ...         \"young_modulus\": np.float64(210000.0),\n    ...         \"density\": np.float64(7850.0),\n    ...         \"poisson_ratio\": np.float64(0.3),\n    ...     }\n    ... ])\n    &gt;&gt;&gt; data = {\n    ...     \"id\": np.int64(1),\n    ...     \"title\": \"SA_1\",\n    ...     \"description\": \"\",\n    ...     \"slug\": \"sa\",\n    ...     \"x_position\": np.float64(0),\n    ...     \"y_position\": np.float64(0),\n    ...     \"z_position\": np.float64(0),\n    ...     \"vertical_position_reference_system\": \"LAT\",\n    ...     \"subassembly_type\": \"TW\",\n    ...     \"source\": \"api\",\n    ...     \"asset\": np.int64(1),\n    ...     \"model_definition\": np.int64(1),\n    ... }\n    &gt;&gt;&gt; str(SubAssembly(materials, data))\n    'SA_1 subassembly'\n    \"\"\"\n    s = str(self.title) + \" subassembly\"\n    return s\n</code></pre>"},{"location":"api/geometry/#owi.metadatabase.geometry.structures-functions","title":"Functions","text":""},{"location":"api/io/","title":"I/O Module","text":"<p>API reference for the base I/O module.</p>"},{"location":"api/io/#owi.metadatabase.io","title":"io","text":"<p>Module for the base class handling the access to the Database API.</p>"},{"location":"api/io/#owi.metadatabase.io-classes","title":"Classes","text":""},{"location":"api/io/#owi.metadatabase.io.API","title":"API","text":"<pre><code>API(\n    api_root=\"https://owimetadatabase.azurewebsites.net/api/v1\",\n    token=None,\n    uname=None,\n    password=None,\n    **kwargs,\n)\n</code></pre> <p>Base API class handling user access information to the Database API.</p> <p>Create an instance of the API class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>api_root</code> <code>str</code> <p>Root URL of the API endpoint, the default working database url is provided.</p> <code>'https://owimetadatabase.azurewebsites.net/api/v1'</code> <code>token</code> <code>str</code> <p>Token to access the API.</p> <code>None</code> <code>uname</code> <code>str</code> <p>Username to access the API.</p> <code>None</code> <code>password</code> <code>str</code> <p>Password to access the API.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to pass to the API.</p> <code>{}</code> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If header format is invalid or if neither header, token, nor username and password are defined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; api.api_root\n'https://example'\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def __init__(\n    self,\n    api_root: str = \"https://owimetadatabase.azurewebsites.net/api/v1\",\n    token: Union[str, None] = None,\n    uname: Union[str, None] = None,\n    password: Union[str, None] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Create an instance of the API class with required parameters.\n\n    Parameters\n    ----------\n    api_root : str, optional\n        Root URL of the API endpoint, the default working database\n        url is provided.\n    token : str, optional\n        Token to access the API.\n    uname : str, optional\n        Username to access the API.\n    password : str, optional\n        Password to access the API.\n    **kwargs\n        Additional parameters to pass to the API.\n\n    Raises\n    ------\n    InvalidParameterError\n        If header format is invalid or if neither header, token,\n        nor username and password are defined.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; api.api_root\n    'https://example'\n    \"\"\"\n    self.api_root = api_root\n    self.uname = uname\n    self.password = password\n    self.auth = None\n    self.header = None\n    if \"header\" in kwargs:\n        self.header = kwargs[\"header\"]\n        if self.header and isinstance(self.header, dict) and \"Authorization\" in self.header:\n            if not self.header[\"Authorization\"].startswith(\"Token \"):\n                if self.header[\"Authorization\"].startswith(\"token \"):\n                    self.header = {\"Authorization\": f\"Token {self.header['Authorization'][6:]}\"}\n                elif self.header[\"Authorization\"].startswith(\"token\") or self.header[\"Authorization\"].startswith(\n                    \"Token\"\n                ):\n                    self.header = {\"Authorization\": f\"Token {self.header['Authorization'][5:]}\"}\n                else:\n                    self.header = {\"Authorization\": f\"Token {self.header['Authorization']}\"}\n        else:\n            raise InvalidParameterError(\n                \"If you provide a header directly, \\\n                the header must contain the 'Authorization' \\\n                key with the value starting with 'Token'.\"\n            )\n    elif token:\n        self.header = {\"Authorization\": f\"Token {token}\"}\n    elif self.uname and self.password:\n        self.auth = HTTPBasicAuth(self.uname, self.password)\n    else:\n        raise InvalidParameterError(\"Either header, token or user name and password must be defined.\")\n</code></pre>"},{"location":"api/io/#owi.metadatabase.io.API-functions","title":"Functions","text":""},{"location":"api/io/#owi.metadatabase.io.API.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compare two instances of the API class.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Another instance of the API class or a dictionary.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instances are equal, False otherwise.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If comparison is not possible due to incompatible types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api_1 = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; api_2 = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; api_1 == api_2\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Compare two instances of the API class.\n\n    Parameters\n    ----------\n    other : object\n        Another instance of the API class or a dictionary.\n\n    Returns\n    -------\n    bool\n        True if the instances are equal, False otherwise.\n\n    Raises\n    ------\n    AssertionError\n        If comparison is not possible due to incompatible types.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api_1 = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; api_2 = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; api_1 == api_2\n    True\n    \"\"\"\n    if not isinstance(other, (API, dict)):\n        return NotImplemented\n    if isinstance(other, type(self)):\n        comp = deepcompare(self, other)\n        assert comp[0], comp[1]\n    elif isinstance(other, dict):\n        comp = deepcompare(self.__dict__, other)\n        assert comp[0], comp[1]\n    else:\n        raise AssertionError(\"Comparison is not possible due to incompatible types!\")\n    return comp[0]\n</code></pre>"},{"location":"api/io/#owi.metadatabase.io.API.send_request","title":"send_request","text":"<pre><code>send_request(url_data_type, url_params)\n</code></pre> <p>Handle sending appropriate request.</p> <p>Handles sending appropriate request according to the type of authentication.</p> <p>Parameters:</p> Name Type Description Default <code>url_data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <code>url_params</code> <code>Mapping</code> <p>Parameters to send with the request to the database.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>An instance of the Response object.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If neither header nor username and password are defined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; response = SimpleNamespace(status_code=200, reason=\"OK\")\n&gt;&gt;&gt; with mock.patch(\"requests.get\", return_value=response):\n...     api = API(api_root=\"https://example\", token=\"test\")\n...     resp = api.send_request(\"/projects\", {})\n&gt;&gt;&gt; resp is response\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def send_request(\n    self,\n    url_data_type: str,\n    url_params: Mapping[str, Union[str, float, int, Sequence[Union[str, float, int]], None]],\n) -&gt; requests.Response:\n    \"\"\"\n    Handle sending appropriate request.\n\n    Handles sending appropriate request according to the type of\n    authentication.\n\n    Parameters\n    ----------\n    url_data_type : str\n        Type of the data we want to request (according to database\n        model).\n    url_params : Mapping\n        Parameters to send with the request to the database.\n\n    Returns\n    -------\n    requests.Response\n        An instance of the Response object.\n\n    Raises\n    ------\n    InvalidParameterError\n        If neither header nor username and password are defined.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; response = SimpleNamespace(status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; with mock.patch(\"requests.get\", return_value=response):\n    ...     api = API(api_root=\"https://example\", token=\"test\")\n    ...     resp = api.send_request(\"/projects\", {})\n    &gt;&gt;&gt; resp is response\n    True\n    \"\"\"\n    if self.header is not None:\n        response = requests.get(\n            url=self.api_root + url_data_type,\n            headers=self.header,\n            params=url_params,\n        )\n    else:\n        if self.uname is None or self.password is None:\n            e = \"Either self.header or self.uname and self.password must be defined.\"\n            raise InvalidParameterError(e)\n        else:\n            response = requests.get(\n                url=self.api_root + url_data_type,\n                auth=self.auth,\n                params=url_params,\n            )\n    return response\n</code></pre>"},{"location":"api/io/#owi.metadatabase.io.API.check_request_health","title":"check_request_health  <code>staticmethod</code>","text":"<pre><code>check_request_health(resp)\n</code></pre> <p>Check status code of the response and provide details.</p> <p>Checks status code of the response to request and provides details if unexpected.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>Instance of the Response object.</p> required <p>Raises:</p> Type Description <code>APIConnectionError</code> <p>If response status code is not 200.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; ok = SimpleNamespace(status_code=200, reason=\"OK\")\n&gt;&gt;&gt; API.check_request_health(ok)\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef check_request_health(resp: requests.Response) -&gt; None:\n    \"\"\"\n    Check status code of the response and provide details.\n\n    Checks status code of the response to request and provides\n    details if unexpected.\n\n    Parameters\n    ----------\n    resp : requests.Response\n        Instance of the Response object.\n\n    Raises\n    ------\n    APIConnectionError\n        If response status code is not 200.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; ok = SimpleNamespace(status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; API.check_request_health(ok)\n    \"\"\"\n    if resp.status_code != 200:\n        raise APIConnectionError(\n            message=f\"Error {resp.status_code}.\\n{resp.reason}\",\n            response=resp,\n        )\n</code></pre>"},{"location":"api/io/#owi.metadatabase.io.API.output_to_df","title":"output_to_df  <code>staticmethod</code>","text":"<pre><code>output_to_df(response)\n</code></pre> <p>Transform output to Pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Raw output of the sent request.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas dataframe of the data from the output.</p> <p>Raises:</p> Type Description <code>DataProcessingError</code> <p>If failed to decode JSON from API response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; resp = SimpleNamespace(text='[{\"a\": 1}]')\n&gt;&gt;&gt; int(API.output_to_df(resp)[\"a\"].iloc[0])\n1\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef output_to_df(response: requests.Response) -&gt; pd.DataFrame:\n    \"\"\"\n    Transform output to Pandas dataframe.\n\n    Parameters\n    ----------\n    response : requests.Response\n        Raw output of the sent request.\n\n    Returns\n    -------\n    pd.DataFrame\n        Pandas dataframe of the data from the output.\n\n    Raises\n    ------\n    DataProcessingError\n        If failed to decode JSON from API response.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; resp = SimpleNamespace(text='[{\"a\": 1}]')\n    &gt;&gt;&gt; int(API.output_to_df(resp)[\"a\"].iloc[0])\n    1\n    \"\"\"\n    try:\n        data = json.loads(response.text)\n    except Exception as err:\n        raise DataProcessingError(\"Failed to decode JSON from API response\") from err\n    return pd.DataFrame(data)\n</code></pre>"},{"location":"api/io/#owi.metadatabase.io.API.postprocess_data","title":"postprocess_data  <code>staticmethod</code>","text":"<pre><code>postprocess_data(df, output_type)\n</code></pre> <p>Process dataframe information to extract additional data.</p> <p>Processes dataframe information to extract the necessary additional data.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe of the output data.</p> required <code>output_type</code> <code>str</code> <p>Expected type (amount) of the data extracted.</p> required <p>Returns:</p> Type Description <code>PostprocessData</code> <p>Dictionary of the additional data extracted.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If more than one record was returned for 'single' output type, or if output type is not 'single' or 'list'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n&gt;&gt;&gt; int(API.postprocess_data(df, \"single\")[\"id\"])\n1\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef postprocess_data(df: pd.DataFrame, output_type: str) -&gt; PostprocessData:\n    \"\"\"\n    Process dataframe information to extract additional data.\n\n    Processes dataframe information to extract the necessary\n    additional data.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe of the output data.\n    output_type : str\n        Expected type (amount) of the data extracted.\n\n    Returns\n    -------\n    PostprocessData\n        Dictionary of the additional data extracted.\n\n    Raises\n    ------\n    InvalidParameterError\n        If more than one record was returned for 'single' output\n        type, or if output type is not 'single' or 'list'.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; int(API.postprocess_data(df, \"single\")[\"id\"])\n    1\n    \"\"\"\n    if output_type == \"single\":\n        if df.__len__() == 0:\n            exists = False\n            project_id = None\n        elif df.__len__() == 1:\n            exists = True\n            project_id = df[\"id\"].iloc[0]\n        else:\n            raise InvalidParameterError(\"More than one project site was returned, check search criteria.\")\n        data_add: PostprocessData = {\n            \"existance\": exists,\n            \"id\": project_id,\n            \"response\": None,\n        }\n    elif output_type == \"list\":\n        exists = df.__len__() != 0\n        data_add: PostprocessData = {\n            \"existance\": exists,\n            \"id\": None,\n            \"response\": None,\n        }\n    else:\n        raise InvalidParameterError(\"Output type must be either 'single' or 'list', not \" + output_type + \".\")\n    return data_add\n</code></pre>"},{"location":"api/io/#owi.metadatabase.io.API.validate_data","title":"validate_data  <code>staticmethod</code>","text":"<pre><code>validate_data(df, data_type)\n</code></pre> <p>Validate the data extracted from the database.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe of the output data.</p> required <code>data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with corrected data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame()\n&gt;&gt;&gt; API.validate_data(df, \"subassemblies\").empty\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef validate_data(df: pd.DataFrame, data_type: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Validate the data extracted from the database.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe of the output data.\n    data_type : str\n        Type of the data we want to request (according to database\n        model).\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with corrected data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame()\n    &gt;&gt;&gt; API.validate_data(df, \"subassemblies\").empty\n    True\n    \"\"\"\n    z_sa_mp = {\"min\": -100000, \"max\": -10000}\n    z_sa_tp = {\"min\": -20000, \"max\": -1000}\n    z_sa_tw = {\"min\": 1000, \"max\": 100000}\n    sa_type = [\"TW\", \"TP\", \"MP\"]\n    z = [z_sa_tw, z_sa_tp, z_sa_mp]\n    if data_type == \"subassemblies\":\n        if df.__len__() == 0:\n            return df\n        for i, sat in enumerate(sa_type):\n            cond_small_units = (df[\"subassembly_type\"] == sat) &amp; (df[\"z_position\"] &lt; z[i][\"min\"])\n            cond_big_units = (df[\"subassembly_type\"] == sat) &amp; (df[\"z_position\"] &gt; z[i][\"max\"])\n            if df[cond_small_units].__len__() &gt; 0:\n                df.loc[cond_small_units, \"z_position\"] = df.loc[cond_small_units, \"z_position\"] / 1e3\n                warnings.warn(\n                    f\"The value of z location for {df.loc[cond_small_units | cond_big_units, 'title'].values} \\\n                    might be wrong or in wrong units! There will be an attempt to correct the units.\",\n                    stacklevel=2,\n                )\n            if df[cond_big_units].__len__() &gt; 0:\n                df.loc[cond_big_units, \"z_position\"] = df.loc[cond_big_units, \"z_position\"] * 1e3\n                warnings.warn(\n                    f\"The value of z location for {df.loc[cond_small_units | cond_big_units, 'title'].values} \\\n                    might be wrong or in wrong units! There will be an attempt to correct the units.\",\n                    stacklevel=2,\n                )\n    return df\n</code></pre>"},{"location":"api/io/#owi.metadatabase.io.API.process_data","title":"process_data","text":"<pre><code>process_data(url_data_type, url_params, output_type)\n</code></pre> <p>Process output data according to specified request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>url_data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <code>url_params</code> <code>Mapping</code> <p>Parameters to send with the request to the database.</p> required <code>output_type</code> <code>str</code> <p>Expected type (amount) of the data extracted.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of dataframe with the requested data and additional data from postprocessing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; response = SimpleNamespace(text=\"[]\", status_code=200, reason=\"OK\")\n&gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; with mock.patch.object(API, \"send_request\", return_value=response):\n...     df, info = api.process_data(\"projects\", {}, \"list\")\n&gt;&gt;&gt; df.empty\nTrue\n&gt;&gt;&gt; info[\"existance\"]\nFalse\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def process_data(\n    self,\n    url_data_type: str,\n    url_params: Mapping[str, Union[str, float, int, Sequence[Union[str, float, int]], None]],\n    output_type: str,\n) -&gt; tuple[pd.DataFrame, PostprocessData]:\n    \"\"\"\n    Process output data according to specified request parameters.\n\n    Parameters\n    ----------\n    url_data_type : str\n        Type of the data we want to request (according to database\n        model).\n    url_params : Mapping\n        Parameters to send with the request to the database.\n    output_type : str\n        Expected type (amount) of the data extracted.\n\n    Returns\n    -------\n    tuple\n        A tuple of dataframe with the requested data and\n        additional data from postprocessing.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; response = SimpleNamespace(text=\"[]\", status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; with mock.patch.object(API, \"send_request\", return_value=response):\n    ...     df, info = api.process_data(\"projects\", {}, \"list\")\n    &gt;&gt;&gt; df.empty\n    True\n    &gt;&gt;&gt; info[\"existance\"]\n    False\n    \"\"\"\n    resp = self.send_request(url_data_type, url_params)\n    self.check_request_health(resp)\n    df = self.output_to_df(resp)\n    df = self.validate_data(df, url_data_type)\n    df_add = self.postprocess_data(df, output_type)\n    # Add the response object to the returned dictionary so tests can inspect it\n    df_add[\"response\"] = resp\n    return df, df_add\n</code></pre>"},{"location":"api/io/#owi.metadatabase.io-functions","title":"Functions","text":""},{"location":"api/locations/","title":"Locations Module","text":"<p>API reference for the locations module.</p>"},{"location":"api/locations/#owi.metadatabase.locations","title":"locations","text":"<p>Module for handling location data from OWI metadatabase.</p>"},{"location":"api/locations/#owi.metadatabase.locations-classes","title":"Classes","text":""},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI","title":"LocationsAPI","text":"<pre><code>LocationsAPI(api_subdir='/locations/', **kwargs)\n</code></pre> <p>               Bases: <code>API</code></p> <p>Class to connect to the location data API with methods to retrieve data.</p> <p>A number of methods are provided to query the database via the owimetadatabase API. In the majority of cases, the methods return a dataframe based on the URL parameters provided. The methods are written such that a number of mandatory URL parameters are required (see documentation of the methods). The URL parameters can be expanded with Django-style additional filtering arguments (e.g. <code>location__title__icontains=\"BB\"</code>) as optional keyword arguments. Knowledge of the Django models is required for this (see <code>owimetadatabase</code> code).</p> <p>Create an instance of the LocationsAPI class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>api_subdir</code> <code>str</code> <p>Subdirectory of the API endpoint url for specific type of data.</p> <code>'/locations/'</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to pass to the API (see the base class).</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api = LocationsAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; api.api_root.endswith(\"/locations/\")\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def __init__(\n    self,\n    api_subdir: str = \"/locations/\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Create an instance of the LocationsAPI class with required\n    parameters.\n\n    Parameters\n    ----------\n    api_subdir : str, optional\n        Subdirectory of the API endpoint url for specific type of\n        data.\n    **kwargs\n        Additional parameters to pass to the API (see the base\n        class).\n\n    Examples\n    --------\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; api.api_root.endswith(\"/locations/\")\n    True\n    \"\"\"\n    super().__init__(**kwargs)\n    self.api_root = self.api_root + api_subdir\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI-functions","title":"Functions","text":""},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compare two instances of the API class.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Another instance of the API class or a dictionary.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instances are equal, False otherwise.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If comparison is not possible due to incompatible types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api_1 = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; api_2 = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; api_1 == api_2\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Compare two instances of the API class.\n\n    Parameters\n    ----------\n    other : object\n        Another instance of the API class or a dictionary.\n\n    Returns\n    -------\n    bool\n        True if the instances are equal, False otherwise.\n\n    Raises\n    ------\n    AssertionError\n        If comparison is not possible due to incompatible types.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api_1 = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; api_2 = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; api_1 == api_2\n    True\n    \"\"\"\n    if not isinstance(other, (API, dict)):\n        return NotImplemented\n    if isinstance(other, type(self)):\n        comp = deepcompare(self, other)\n        assert comp[0], comp[1]\n    elif isinstance(other, dict):\n        comp = deepcompare(self.__dict__, other)\n        assert comp[0], comp[1]\n    else:\n        raise AssertionError(\"Comparison is not possible due to incompatible types!\")\n    return comp[0]\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.send_request","title":"send_request","text":"<pre><code>send_request(url_data_type, url_params)\n</code></pre> <p>Handle sending appropriate request.</p> <p>Handles sending appropriate request according to the type of authentication.</p> <p>Parameters:</p> Name Type Description Default <code>url_data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <code>url_params</code> <code>Mapping</code> <p>Parameters to send with the request to the database.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>An instance of the Response object.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If neither header nor username and password are defined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; response = SimpleNamespace(status_code=200, reason=\"OK\")\n&gt;&gt;&gt; with mock.patch(\"requests.get\", return_value=response):\n...     api = API(api_root=\"https://example\", token=\"test\")\n...     resp = api.send_request(\"/projects\", {})\n&gt;&gt;&gt; resp is response\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def send_request(\n    self,\n    url_data_type: str,\n    url_params: Mapping[str, Union[str, float, int, Sequence[Union[str, float, int]], None]],\n) -&gt; requests.Response:\n    \"\"\"\n    Handle sending appropriate request.\n\n    Handles sending appropriate request according to the type of\n    authentication.\n\n    Parameters\n    ----------\n    url_data_type : str\n        Type of the data we want to request (according to database\n        model).\n    url_params : Mapping\n        Parameters to send with the request to the database.\n\n    Returns\n    -------\n    requests.Response\n        An instance of the Response object.\n\n    Raises\n    ------\n    InvalidParameterError\n        If neither header nor username and password are defined.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; response = SimpleNamespace(status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; with mock.patch(\"requests.get\", return_value=response):\n    ...     api = API(api_root=\"https://example\", token=\"test\")\n    ...     resp = api.send_request(\"/projects\", {})\n    &gt;&gt;&gt; resp is response\n    True\n    \"\"\"\n    if self.header is not None:\n        response = requests.get(\n            url=self.api_root + url_data_type,\n            headers=self.header,\n            params=url_params,\n        )\n    else:\n        if self.uname is None or self.password is None:\n            e = \"Either self.header or self.uname and self.password must be defined.\"\n            raise InvalidParameterError(e)\n        else:\n            response = requests.get(\n                url=self.api_root + url_data_type,\n                auth=self.auth,\n                params=url_params,\n            )\n    return response\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.check_request_health","title":"check_request_health  <code>staticmethod</code>","text":"<pre><code>check_request_health(resp)\n</code></pre> <p>Check status code of the response and provide details.</p> <p>Checks status code of the response to request and provides details if unexpected.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>Instance of the Response object.</p> required <p>Raises:</p> Type Description <code>APIConnectionError</code> <p>If response status code is not 200.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; ok = SimpleNamespace(status_code=200, reason=\"OK\")\n&gt;&gt;&gt; API.check_request_health(ok)\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef check_request_health(resp: requests.Response) -&gt; None:\n    \"\"\"\n    Check status code of the response and provide details.\n\n    Checks status code of the response to request and provides\n    details if unexpected.\n\n    Parameters\n    ----------\n    resp : requests.Response\n        Instance of the Response object.\n\n    Raises\n    ------\n    APIConnectionError\n        If response status code is not 200.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; ok = SimpleNamespace(status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; API.check_request_health(ok)\n    \"\"\"\n    if resp.status_code != 200:\n        raise APIConnectionError(\n            message=f\"Error {resp.status_code}.\\n{resp.reason}\",\n            response=resp,\n        )\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.output_to_df","title":"output_to_df  <code>staticmethod</code>","text":"<pre><code>output_to_df(response)\n</code></pre> <p>Transform output to Pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Raw output of the sent request.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas dataframe of the data from the output.</p> <p>Raises:</p> Type Description <code>DataProcessingError</code> <p>If failed to decode JSON from API response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; resp = SimpleNamespace(text='[{\"a\": 1}]')\n&gt;&gt;&gt; int(API.output_to_df(resp)[\"a\"].iloc[0])\n1\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef output_to_df(response: requests.Response) -&gt; pd.DataFrame:\n    \"\"\"\n    Transform output to Pandas dataframe.\n\n    Parameters\n    ----------\n    response : requests.Response\n        Raw output of the sent request.\n\n    Returns\n    -------\n    pd.DataFrame\n        Pandas dataframe of the data from the output.\n\n    Raises\n    ------\n    DataProcessingError\n        If failed to decode JSON from API response.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; resp = SimpleNamespace(text='[{\"a\": 1}]')\n    &gt;&gt;&gt; int(API.output_to_df(resp)[\"a\"].iloc[0])\n    1\n    \"\"\"\n    try:\n        data = json.loads(response.text)\n    except Exception as err:\n        raise DataProcessingError(\"Failed to decode JSON from API response\") from err\n    return pd.DataFrame(data)\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.postprocess_data","title":"postprocess_data  <code>staticmethod</code>","text":"<pre><code>postprocess_data(df, output_type)\n</code></pre> <p>Process dataframe information to extract additional data.</p> <p>Processes dataframe information to extract the necessary additional data.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe of the output data.</p> required <code>output_type</code> <code>str</code> <p>Expected type (amount) of the data extracted.</p> required <p>Returns:</p> Type Description <code>PostprocessData</code> <p>Dictionary of the additional data extracted.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If more than one record was returned for 'single' output type, or if output type is not 'single' or 'list'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n&gt;&gt;&gt; int(API.postprocess_data(df, \"single\")[\"id\"])\n1\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef postprocess_data(df: pd.DataFrame, output_type: str) -&gt; PostprocessData:\n    \"\"\"\n    Process dataframe information to extract additional data.\n\n    Processes dataframe information to extract the necessary\n    additional data.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe of the output data.\n    output_type : str\n        Expected type (amount) of the data extracted.\n\n    Returns\n    -------\n    PostprocessData\n        Dictionary of the additional data extracted.\n\n    Raises\n    ------\n    InvalidParameterError\n        If more than one record was returned for 'single' output\n        type, or if output type is not 'single' or 'list'.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; int(API.postprocess_data(df, \"single\")[\"id\"])\n    1\n    \"\"\"\n    if output_type == \"single\":\n        if df.__len__() == 0:\n            exists = False\n            project_id = None\n        elif df.__len__() == 1:\n            exists = True\n            project_id = df[\"id\"].iloc[0]\n        else:\n            raise InvalidParameterError(\"More than one project site was returned, check search criteria.\")\n        data_add: PostprocessData = {\n            \"existance\": exists,\n            \"id\": project_id,\n            \"response\": None,\n        }\n    elif output_type == \"list\":\n        exists = df.__len__() != 0\n        data_add: PostprocessData = {\n            \"existance\": exists,\n            \"id\": None,\n            \"response\": None,\n        }\n    else:\n        raise InvalidParameterError(\"Output type must be either 'single' or 'list', not \" + output_type + \".\")\n    return data_add\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.validate_data","title":"validate_data  <code>staticmethod</code>","text":"<pre><code>validate_data(df, data_type)\n</code></pre> <p>Validate the data extracted from the database.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe of the output data.</p> required <code>data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with corrected data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame()\n&gt;&gt;&gt; API.validate_data(df, \"subassemblies\").empty\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef validate_data(df: pd.DataFrame, data_type: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Validate the data extracted from the database.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe of the output data.\n    data_type : str\n        Type of the data we want to request (according to database\n        model).\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with corrected data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame()\n    &gt;&gt;&gt; API.validate_data(df, \"subassemblies\").empty\n    True\n    \"\"\"\n    z_sa_mp = {\"min\": -100000, \"max\": -10000}\n    z_sa_tp = {\"min\": -20000, \"max\": -1000}\n    z_sa_tw = {\"min\": 1000, \"max\": 100000}\n    sa_type = [\"TW\", \"TP\", \"MP\"]\n    z = [z_sa_tw, z_sa_tp, z_sa_mp]\n    if data_type == \"subassemblies\":\n        if df.__len__() == 0:\n            return df\n        for i, sat in enumerate(sa_type):\n            cond_small_units = (df[\"subassembly_type\"] == sat) &amp; (df[\"z_position\"] &lt; z[i][\"min\"])\n            cond_big_units = (df[\"subassembly_type\"] == sat) &amp; (df[\"z_position\"] &gt; z[i][\"max\"])\n            if df[cond_small_units].__len__() &gt; 0:\n                df.loc[cond_small_units, \"z_position\"] = df.loc[cond_small_units, \"z_position\"] / 1e3\n                warnings.warn(\n                    f\"The value of z location for {df.loc[cond_small_units | cond_big_units, 'title'].values} \\\n                    might be wrong or in wrong units! There will be an attempt to correct the units.\",\n                    stacklevel=2,\n                )\n            if df[cond_big_units].__len__() &gt; 0:\n                df.loc[cond_big_units, \"z_position\"] = df.loc[cond_big_units, \"z_position\"] * 1e3\n                warnings.warn(\n                    f\"The value of z location for {df.loc[cond_small_units | cond_big_units, 'title'].values} \\\n                    might be wrong or in wrong units! There will be an attempt to correct the units.\",\n                    stacklevel=2,\n                )\n    return df\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.process_data","title":"process_data","text":"<pre><code>process_data(url_data_type, url_params, output_type)\n</code></pre> <p>Process output data according to specified request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>url_data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <code>url_params</code> <code>Mapping</code> <p>Parameters to send with the request to the database.</p> required <code>output_type</code> <code>str</code> <p>Expected type (amount) of the data extracted.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of dataframe with the requested data and additional data from postprocessing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; response = SimpleNamespace(text=\"[]\", status_code=200, reason=\"OK\")\n&gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; with mock.patch.object(API, \"send_request\", return_value=response):\n...     df, info = api.process_data(\"projects\", {}, \"list\")\n&gt;&gt;&gt; df.empty\nTrue\n&gt;&gt;&gt; info[\"existance\"]\nFalse\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def process_data(\n    self,\n    url_data_type: str,\n    url_params: Mapping[str, Union[str, float, int, Sequence[Union[str, float, int]], None]],\n    output_type: str,\n) -&gt; tuple[pd.DataFrame, PostprocessData]:\n    \"\"\"\n    Process output data according to specified request parameters.\n\n    Parameters\n    ----------\n    url_data_type : str\n        Type of the data we want to request (according to database\n        model).\n    url_params : Mapping\n        Parameters to send with the request to the database.\n    output_type : str\n        Expected type (amount) of the data extracted.\n\n    Returns\n    -------\n    tuple\n        A tuple of dataframe with the requested data and\n        additional data from postprocessing.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; response = SimpleNamespace(text=\"[]\", status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; with mock.patch.object(API, \"send_request\", return_value=response):\n    ...     df, info = api.process_data(\"projects\", {}, \"list\")\n    &gt;&gt;&gt; df.empty\n    True\n    &gt;&gt;&gt; info[\"existance\"]\n    False\n    \"\"\"\n    resp = self.send_request(url_data_type, url_params)\n    self.check_request_health(resp)\n    df = self.output_to_df(resp)\n    df = self.validate_data(df, url_data_type)\n    df_add = self.postprocess_data(df, output_type)\n    # Add the response object to the returned dictionary so tests can inspect it\n    df_add[\"response\"] = resp\n    return df, df_add\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.get_projectsites","title":"get_projectsites","text":"<pre><code>get_projectsites(**kwargs)\n</code></pre> <p>Get all available projects.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional parameters to pass to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the location data for each   project</li> <li>\"exists\": Boolean indicating whether matching records   are found</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     LocationsAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_projectsites()\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def get_projectsites(self, **kwargs: Any) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get all available projects.\n\n    Parameters\n    ----------\n    **kwargs\n        Additional parameters to pass to the API.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the location data for each\n          project\n        - \"exists\": Boolean indicating whether matching records\n          are found\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = LocationsAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     LocationsAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True}),\n            ... ):\n            ...     out = api.get_projectsites()\n            &gt;&gt;&gt; out[\"exists\"]\n            True\n    \"\"\"\n    url_params = {}  # type: dict[str, str]\n    url_params = {**url_params, **kwargs}\n    url_data_type = \"projectsites\"\n    output_type = \"list\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.get_projectsite_detail","title":"get_projectsite_detail","text":"<pre><code>get_projectsite_detail(projectsite, **kwargs)\n</code></pre> <p>Get details for a specific projectsite.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>Title of the projectsite.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional parameters to pass to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"id\": ID of the selected project site.</li> <li>\"data\": Pandas dataframe with the location data for each   projectsite.</li> <li>\"exists\": Boolean indicating whether matching records   are found.</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     LocationsAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True, \"id\": 1}),\n    ... ):\n    ...     out = api.get_projectsite_detail(\"Site\")\n    &gt;&gt;&gt; out[\"id\"]\n    1\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def get_projectsite_detail(\n    self, projectsite: str, **kwargs: Any\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get details for a specific projectsite.\n\n    Parameters\n    ----------\n    projectsite : str\n        Title of the projectsite.\n    **kwargs\n        Additional parameters to pass to the API.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"id\": ID of the selected project site.\n        - \"data\": Pandas dataframe with the location data for each\n          projectsite.\n        - \"exists\": Boolean indicating whether matching records\n          are found.\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = LocationsAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     LocationsAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True, \"id\": 1}),\n            ... ):\n            ...     out = api.get_projectsite_detail(\"Site\")\n            &gt;&gt;&gt; out[\"id\"]\n            1\n    \"\"\"\n    url_params = {\"projectsite\": projectsite}\n    url_params = {**url_params, **kwargs}\n    url_data_type = \"projectsites\"\n    output_type = \"single\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"id\": df_add[\"id\"], \"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.get_assetlocations","title":"get_assetlocations","text":"<pre><code>get_assetlocations(projectsite=None, **kwargs)\n</code></pre> <p>Get all available asset locations.</p> <p>Get all available asset locations for all projectsites or a specific projectsite.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>String with the projectsite title (e.g. \"Nobelwind\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to pass to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the location data for each   location in the projectsite.</li> <li>\"exists\": Boolean indicating whether matching records   are found.</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     LocationsAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_assetlocations(projectsite=\"Site\")\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def get_assetlocations(\n    self, projectsite: Union[str, None] = None, **kwargs: Any\n) -&gt; dict[str, Union[pd.DataFrame, bool, list[bool], np.int64, None]]:\n    \"\"\"\n    Get all available asset locations.\n\n    Get all available asset locations for all projectsites or a\n    specific projectsite.\n\n    Parameters\n    ----------\n    projectsite : str, optional\n        String with the projectsite title (e.g. \"Nobelwind\").\n    **kwargs\n        Additional parameters to pass to the API.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the location data for each\n          location in the projectsite.\n        - \"exists\": Boolean indicating whether matching records\n          are found.\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = LocationsAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     LocationsAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True}),\n            ... ):\n            ...     out = api.get_assetlocations(projectsite=\"Site\")\n            &gt;&gt;&gt; out[\"exists\"]\n            True\n    \"\"\"\n    url_params = {}  # type: dict[str, str]\n    url_params = {**url_params, **kwargs}\n    if projectsite:\n        url_params[\"projectsite__title\"] = projectsite\n    url_data_type = \"assetlocations\"\n    if \"assetlocations\" in url_params and isinstance(url_params[\"assetlocations\"], list):\n        df = []\n        df_add = {\"existance\": []}\n        for assetlocation in url_params[\"assetlocations\"]:\n            output_type = \"single\"\n            url_params[\"assetlocation\"] = assetlocation\n            df_temp, df_add_temp = self.process_data(url_data_type, url_params, output_type)\n            df.append(df_temp)\n            df_add[\"existance\"].append(df_add_temp[\"existance\"])\n        df = pd.concat(df)\n    else:\n        output_type = \"list\"\n        df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.get_assetlocation_detail","title":"get_assetlocation_detail","text":"<pre><code>get_assetlocation_detail(\n    assetlocation, projectsite=None, **kwargs\n)\n</code></pre> <p>Get a selected turbine.</p> <p>Parameters:</p> Name Type Description Default <code>assetlocation</code> <code>str</code> <p>Title of the asset location (e.g. \"BBK05\").</p> required <code>projectsite</code> <code>str</code> <p>Name of the projectsite (e.g. \"Nobelwind\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to pass to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"id\": ID of the selected projectsite site.</li> <li>\"data\": Pandas dataframe with the location data for the   individual location.</li> <li>\"exists\": Boolean indicating whether a matching location   is found.</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     LocationsAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True, \"id\": 1}),\n    ... ):\n    ...     out = api.get_assetlocation_detail(\"T01\")\n    &gt;&gt;&gt; out[\"id\"]\n    1\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def get_assetlocation_detail(\n    self,\n    assetlocation: str,\n    projectsite: Union[None, str] = None,\n    **kwargs: Any,\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get a selected turbine.\n\n    Parameters\n    ----------\n    assetlocation : str\n        Title of the asset location (e.g. \"BBK05\").\n    projectsite : str, optional\n        Name of the projectsite (e.g. \"Nobelwind\").\n    **kwargs\n        Additional parameters to pass to the API.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"id\": ID of the selected projectsite site.\n        - \"data\": Pandas dataframe with the location data for the\n          individual location.\n        - \"exists\": Boolean indicating whether a matching location\n          is found.\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = LocationsAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     LocationsAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True, \"id\": 1}),\n            ... ):\n            ...     out = api.get_assetlocation_detail(\"T01\")\n            &gt;&gt;&gt; out[\"id\"]\n            1\n    \"\"\"\n    if projectsite is None:\n        url_params = {\"assetlocation\": assetlocation}\n    else:\n        url_params = {\n            \"projectsite\": projectsite,\n            \"assetlocation\": assetlocation,\n        }\n    url_params = {**url_params, **kwargs}\n    url_data_type = \"assetlocations\"\n    output_type = \"single\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"id\": df_add[\"id\"], \"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.LocationsAPI.plot_assetlocations","title":"plot_assetlocations","text":"<pre><code>plot_assetlocations(return_fig=False, **kwargs)\n</code></pre> <p>Retrieve asset locations and generate a Plotly plot.</p> <p>Retrieves asset locations and generates a Plotly plot to show them.</p> <p>Parameters:</p> Name Type Description Default <code>return_fig</code> <code>bool</code> <p>Boolean indicating whether to return the figure, default is False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for the search (see <code>get_assetlocations</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure or None</code> <p>Plotly figure object with selected asset locations plotted on OpenStreetMap tiles (if requested) or nothing.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no asset locations found for the given parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; api = LocationsAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; data = pd.DataFrame(\n...     {\n...         \"northing\": [51.5],\n...         \"easting\": [2.8],\n...         \"title\": [\"T01\"],\n...         \"projectsite_name\": [\"Site\"],\n...         \"description\": [\"\"],\n...     }\n... )\n&gt;&gt;&gt; with mock.patch.object(\n...     LocationsAPI,\n...     \"get_assetlocations\",\n...     return_value={\"exists\": True, \"data\": data},\n... ):\n...     fig = api.plot_assetlocations(return_fig=True)\n&gt;&gt;&gt; fig is not None\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def plot_assetlocations(self, return_fig: bool = False, **kwargs: Any) -&gt; Union[go.Figure, None]:\n    \"\"\"\n    Retrieve asset locations and generate a Plotly plot.\n\n    Retrieves asset locations and generates a Plotly plot to show\n    them.\n\n    Parameters\n    ----------\n    return_fig : bool, optional\n        Boolean indicating whether to return the figure, default\n        is False.\n    **kwargs\n        Keyword arguments for the search (see\n        ``get_assetlocations``).\n\n    Returns\n    -------\n    plotly.graph_objects.Figure or None\n        Plotly figure object with selected asset locations plotted\n        on OpenStreetMap tiles (if requested) or nothing.\n\n    Raises\n    ------\n    ValueError\n        If no asset locations found for the given parameters.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; data = pd.DataFrame(\n    ...     {\n    ...         \"northing\": [51.5],\n    ...         \"easting\": [2.8],\n    ...         \"title\": [\"T01\"],\n    ...         \"projectsite_name\": [\"Site\"],\n    ...         \"description\": [\"\"],\n    ...     }\n    ... )\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     LocationsAPI,\n    ...     \"get_assetlocations\",\n    ...     return_value={\"exists\": True, \"data\": data},\n    ... ):\n    ...     fig = api.plot_assetlocations(return_fig=True)\n    &gt;&gt;&gt; fig is not None\n    True\n    \"\"\"\n    assetlocations_data = self.get_assetlocations(**kwargs)\n    if assetlocations_data[\"exists\"]:\n        assetlocations = assetlocations_data[\"data\"]\n    else:\n        raise ValueError(\n            f\"No asset locations found for the given parameters: {kwargs}. \\\n            Please check for typos or if it is expected to exists.\"\n        )\n    fig = px.scatter_mapbox(\n        assetlocations,\n        lat=\"northing\",\n        lon=\"easting\",\n        hover_name=\"title\",\n        hover_data=[\"projectsite_name\", \"description\"],\n        zoom=9.6,\n        height=500,\n    )\n    fig.update_layout(mapbox_style=\"open-street-map\")\n    fig.update_layout(margin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0})\n    if return_fig:\n        return fig\n    else:\n        fig.show()\n        return None\n</code></pre>"},{"location":"api/locations/#locationsio-api-client","title":"locations.io - API Client","text":""},{"location":"api/locations/#owi.metadatabase.locations.io","title":"io","text":"<p>Module to connect to the database API to retrieve and operate on locations data.</p>"},{"location":"api/locations/#owi.metadatabase.locations.io-classes","title":"Classes","text":""},{"location":"api/locations/#owi.metadatabase.locations.io.LocationsAPI","title":"LocationsAPI","text":"<pre><code>LocationsAPI(api_subdir='/locations/', **kwargs)\n</code></pre> <p>               Bases: <code>API</code></p> <p>Class to connect to the location data API with methods to retrieve data.</p> <p>A number of methods are provided to query the database via the owimetadatabase API. In the majority of cases, the methods return a dataframe based on the URL parameters provided. The methods are written such that a number of mandatory URL parameters are required (see documentation of the methods). The URL parameters can be expanded with Django-style additional filtering arguments (e.g. <code>location__title__icontains=\"BB\"</code>) as optional keyword arguments. Knowledge of the Django models is required for this (see <code>owimetadatabase</code> code).</p> <p>Create an instance of the LocationsAPI class with required parameters.</p> <p>Parameters:</p> Name Type Description Default <code>api_subdir</code> <code>str</code> <p>Subdirectory of the API endpoint url for specific type of data.</p> <code>'/locations/'</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to pass to the API (see the base class).</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api = LocationsAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; api.api_root.endswith(\"/locations/\")\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def __init__(\n    self,\n    api_subdir: str = \"/locations/\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Create an instance of the LocationsAPI class with required\n    parameters.\n\n    Parameters\n    ----------\n    api_subdir : str, optional\n        Subdirectory of the API endpoint url for specific type of\n        data.\n    **kwargs\n        Additional parameters to pass to the API (see the base\n        class).\n\n    Examples\n    --------\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; api.api_root.endswith(\"/locations/\")\n    True\n    \"\"\"\n    super().__init__(**kwargs)\n    self.api_root = self.api_root + api_subdir\n</code></pre>"},{"location":"api/locations/#owi.metadatabase.locations.io.LocationsAPI-functions","title":"Functions","text":"get_projectsites \u00b6 <pre><code>get_projectsites(**kwargs)\n</code></pre> <p>Get all available projects.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional parameters to pass to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the location data for each   project</li> <li>\"exists\": Boolean indicating whether matching records   are found</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     LocationsAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_projectsites()\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def get_projectsites(self, **kwargs: Any) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get all available projects.\n\n    Parameters\n    ----------\n    **kwargs\n        Additional parameters to pass to the API.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the location data for each\n          project\n        - \"exists\": Boolean indicating whether matching records\n          are found\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = LocationsAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     LocationsAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True}),\n            ... ):\n            ...     out = api.get_projectsites()\n            &gt;&gt;&gt; out[\"exists\"]\n            True\n    \"\"\"\n    url_params = {}  # type: dict[str, str]\n    url_params = {**url_params, **kwargs}\n    url_data_type = \"projectsites\"\n    output_type = \"list\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre> get_projectsite_detail \u00b6 <pre><code>get_projectsite_detail(projectsite, **kwargs)\n</code></pre> <p>Get details for a specific projectsite.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>Title of the projectsite.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional parameters to pass to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"id\": ID of the selected project site.</li> <li>\"data\": Pandas dataframe with the location data for each   projectsite.</li> <li>\"exists\": Boolean indicating whether matching records   are found.</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     LocationsAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True, \"id\": 1}),\n    ... ):\n    ...     out = api.get_projectsite_detail(\"Site\")\n    &gt;&gt;&gt; out[\"id\"]\n    1\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def get_projectsite_detail(\n    self, projectsite: str, **kwargs: Any\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get details for a specific projectsite.\n\n    Parameters\n    ----------\n    projectsite : str\n        Title of the projectsite.\n    **kwargs\n        Additional parameters to pass to the API.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"id\": ID of the selected project site.\n        - \"data\": Pandas dataframe with the location data for each\n          projectsite.\n        - \"exists\": Boolean indicating whether matching records\n          are found.\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = LocationsAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     LocationsAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True, \"id\": 1}),\n            ... ):\n            ...     out = api.get_projectsite_detail(\"Site\")\n            &gt;&gt;&gt; out[\"id\"]\n            1\n    \"\"\"\n    url_params = {\"projectsite\": projectsite}\n    url_params = {**url_params, **kwargs}\n    url_data_type = \"projectsites\"\n    output_type = \"single\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"id\": df_add[\"id\"], \"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre> get_assetlocations \u00b6 <pre><code>get_assetlocations(projectsite=None, **kwargs)\n</code></pre> <p>Get all available asset locations.</p> <p>Get all available asset locations for all projectsites or a specific projectsite.</p> <p>Parameters:</p> Name Type Description Default <code>projectsite</code> <code>str</code> <p>String with the projectsite title (e.g. \"Nobelwind\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to pass to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"data\": Pandas dataframe with the location data for each   location in the projectsite.</li> <li>\"exists\": Boolean indicating whether matching records   are found.</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     LocationsAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True}),\n    ... ):\n    ...     out = api.get_assetlocations(projectsite=\"Site\")\n    &gt;&gt;&gt; out[\"exists\"]\n    True\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def get_assetlocations(\n    self, projectsite: Union[str, None] = None, **kwargs: Any\n) -&gt; dict[str, Union[pd.DataFrame, bool, list[bool], np.int64, None]]:\n    \"\"\"\n    Get all available asset locations.\n\n    Get all available asset locations for all projectsites or a\n    specific projectsite.\n\n    Parameters\n    ----------\n    projectsite : str, optional\n        String with the projectsite title (e.g. \"Nobelwind\").\n    **kwargs\n        Additional parameters to pass to the API.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"data\": Pandas dataframe with the location data for each\n          location in the projectsite.\n        - \"exists\": Boolean indicating whether matching records\n          are found.\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = LocationsAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     LocationsAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True}),\n            ... ):\n            ...     out = api.get_assetlocations(projectsite=\"Site\")\n            &gt;&gt;&gt; out[\"exists\"]\n            True\n    \"\"\"\n    url_params = {}  # type: dict[str, str]\n    url_params = {**url_params, **kwargs}\n    if projectsite:\n        url_params[\"projectsite__title\"] = projectsite\n    url_data_type = \"assetlocations\"\n    if \"assetlocations\" in url_params and isinstance(url_params[\"assetlocations\"], list):\n        df = []\n        df_add = {\"existance\": []}\n        for assetlocation in url_params[\"assetlocations\"]:\n            output_type = \"single\"\n            url_params[\"assetlocation\"] = assetlocation\n            df_temp, df_add_temp = self.process_data(url_data_type, url_params, output_type)\n            df.append(df_temp)\n            df_add[\"existance\"].append(df_add_temp[\"existance\"])\n        df = pd.concat(df)\n    else:\n        output_type = \"list\"\n        df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre> get_assetlocation_detail \u00b6 <pre><code>get_assetlocation_detail(\n    assetlocation, projectsite=None, **kwargs\n)\n</code></pre> <p>Get a selected turbine.</p> <p>Parameters:</p> Name Type Description Default <code>assetlocation</code> <code>str</code> <p>Title of the asset location (e.g. \"BBK05\").</p> required <code>projectsite</code> <code>str</code> <p>Name of the projectsite (e.g. \"Nobelwind\").</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters to pass to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with the following keys:</p> <ul> <li>\"id\": ID of the selected projectsite site.</li> <li>\"data\": Pandas dataframe with the location data for the   individual location.</li> <li>\"exists\": Boolean indicating whether a matching location   is found.</li> </ul> <p>Examples:</p> <pre><code>    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     LocationsAPI,\n    ...     \"process_data\",\n    ...     return_value=(df, {\"existance\": True, \"id\": 1}),\n    ... ):\n    ...     out = api.get_assetlocation_detail(\"T01\")\n    &gt;&gt;&gt; out[\"id\"]\n    1\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def get_assetlocation_detail(\n    self,\n    assetlocation: str,\n    projectsite: Union[None, str] = None,\n    **kwargs: Any,\n) -&gt; dict[str, Union[pd.DataFrame, bool, np.int64, None]]:\n    \"\"\"\n    Get a selected turbine.\n\n    Parameters\n    ----------\n    assetlocation : str\n        Title of the asset location (e.g. \"BBK05\").\n    projectsite : str, optional\n        Name of the projectsite (e.g. \"Nobelwind\").\n    **kwargs\n        Additional parameters to pass to the API.\n\n    Returns\n    -------\n    dict\n        Dictionary with the following keys:\n\n        - \"id\": ID of the selected projectsite site.\n        - \"data\": Pandas dataframe with the location data for the\n          individual location.\n        - \"exists\": Boolean indicating whether a matching location\n          is found.\n\n    Examples\n    --------\n            &gt;&gt;&gt; from unittest import mock\n            &gt;&gt;&gt; api = LocationsAPI(\n            ...     api_root=\"https://example\",\n            ...     header={\"Authorization\": \"Token test\"},\n            ... )\n            &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n            &gt;&gt;&gt; with mock.patch.object(\n            ...     LocationsAPI,\n            ...     \"process_data\",\n            ...     return_value=(df, {\"existance\": True, \"id\": 1}),\n            ... ):\n            ...     out = api.get_assetlocation_detail(\"T01\")\n            &gt;&gt;&gt; out[\"id\"]\n            1\n    \"\"\"\n    if projectsite is None:\n        url_params = {\"assetlocation\": assetlocation}\n    else:\n        url_params = {\n            \"projectsite\": projectsite,\n            \"assetlocation\": assetlocation,\n        }\n    url_params = {**url_params, **kwargs}\n    url_data_type = \"assetlocations\"\n    output_type = \"single\"\n    df, df_add = self.process_data(url_data_type, url_params, output_type)\n    return {\"id\": df_add[\"id\"], \"data\": df, \"exists\": df_add[\"existance\"]}\n</code></pre> plot_assetlocations \u00b6 <pre><code>plot_assetlocations(return_fig=False, **kwargs)\n</code></pre> <p>Retrieve asset locations and generate a Plotly plot.</p> <p>Retrieves asset locations and generates a Plotly plot to show them.</p> <p>Parameters:</p> Name Type Description Default <code>return_fig</code> <code>bool</code> <p>Boolean indicating whether to return the figure, default is False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for the search (see <code>get_assetlocations</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure or None</code> <p>Plotly figure object with selected asset locations plotted on OpenStreetMap tiles (if requested) or nothing.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no asset locations found for the given parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; api = LocationsAPI(\n...     api_root=\"https://example\",\n...     header={\"Authorization\": \"Token test\"},\n... )\n&gt;&gt;&gt; data = pd.DataFrame(\n...     {\n...         \"northing\": [51.5],\n...         \"easting\": [2.8],\n...         \"title\": [\"T01\"],\n...         \"projectsite_name\": [\"Site\"],\n...         \"description\": [\"\"],\n...     }\n... )\n&gt;&gt;&gt; with mock.patch.object(\n...     LocationsAPI,\n...     \"get_assetlocations\",\n...     return_value={\"exists\": True, \"data\": data},\n... ):\n...     fig = api.plot_assetlocations(return_fig=True)\n&gt;&gt;&gt; fig is not None\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/locations/io.py</code> <pre><code>def plot_assetlocations(self, return_fig: bool = False, **kwargs: Any) -&gt; Union[go.Figure, None]:\n    \"\"\"\n    Retrieve asset locations and generate a Plotly plot.\n\n    Retrieves asset locations and generates a Plotly plot to show\n    them.\n\n    Parameters\n    ----------\n    return_fig : bool, optional\n        Boolean indicating whether to return the figure, default\n        is False.\n    **kwargs\n        Keyword arguments for the search (see\n        ``get_assetlocations``).\n\n    Returns\n    -------\n    plotly.graph_objects.Figure or None\n        Plotly figure object with selected asset locations plotted\n        on OpenStreetMap tiles (if requested) or nothing.\n\n    Raises\n    ------\n    ValueError\n        If no asset locations found for the given parameters.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; api = LocationsAPI(\n    ...     api_root=\"https://example\",\n    ...     header={\"Authorization\": \"Token test\"},\n    ... )\n    &gt;&gt;&gt; data = pd.DataFrame(\n    ...     {\n    ...         \"northing\": [51.5],\n    ...         \"easting\": [2.8],\n    ...         \"title\": [\"T01\"],\n    ...         \"projectsite_name\": [\"Site\"],\n    ...         \"description\": [\"\"],\n    ...     }\n    ... )\n    &gt;&gt;&gt; with mock.patch.object(\n    ...     LocationsAPI,\n    ...     \"get_assetlocations\",\n    ...     return_value={\"exists\": True, \"data\": data},\n    ... ):\n    ...     fig = api.plot_assetlocations(return_fig=True)\n    &gt;&gt;&gt; fig is not None\n    True\n    \"\"\"\n    assetlocations_data = self.get_assetlocations(**kwargs)\n    if assetlocations_data[\"exists\"]:\n        assetlocations = assetlocations_data[\"data\"]\n    else:\n        raise ValueError(\n            f\"No asset locations found for the given parameters: {kwargs}. \\\n            Please check for typos or if it is expected to exists.\"\n        )\n    fig = px.scatter_mapbox(\n        assetlocations,\n        lat=\"northing\",\n        lon=\"easting\",\n        hover_name=\"title\",\n        hover_data=[\"projectsite_name\", \"description\"],\n        zoom=9.6,\n        height=500,\n    )\n    fig.update_layout(mapbox_style=\"open-street-map\")\n    fig.update_layout(margin={\"r\": 0, \"t\": 0, \"l\": 0, \"b\": 0})\n    if return_fig:\n        return fig\n    else:\n        fig.show()\n        return None\n</code></pre> __eq__ \u00b6 <pre><code>__eq__(other)\n</code></pre> <p>Compare two instances of the API class.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Another instance of the API class or a dictionary.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instances are equal, False otherwise.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If comparison is not possible due to incompatible types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; api_1 = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; api_2 = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; api_1 == api_2\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Compare two instances of the API class.\n\n    Parameters\n    ----------\n    other : object\n        Another instance of the API class or a dictionary.\n\n    Returns\n    -------\n    bool\n        True if the instances are equal, False otherwise.\n\n    Raises\n    ------\n    AssertionError\n        If comparison is not possible due to incompatible types.\n\n    Examples\n    --------\n    &gt;&gt;&gt; api_1 = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; api_2 = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; api_1 == api_2\n    True\n    \"\"\"\n    if not isinstance(other, (API, dict)):\n        return NotImplemented\n    if isinstance(other, type(self)):\n        comp = deepcompare(self, other)\n        assert comp[0], comp[1]\n    elif isinstance(other, dict):\n        comp = deepcompare(self.__dict__, other)\n        assert comp[0], comp[1]\n    else:\n        raise AssertionError(\"Comparison is not possible due to incompatible types!\")\n    return comp[0]\n</code></pre> send_request \u00b6 <pre><code>send_request(url_data_type, url_params)\n</code></pre> <p>Handle sending appropriate request.</p> <p>Handles sending appropriate request according to the type of authentication.</p> <p>Parameters:</p> Name Type Description Default <code>url_data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <code>url_params</code> <code>Mapping</code> <p>Parameters to send with the request to the database.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>An instance of the Response object.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If neither header nor username and password are defined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; response = SimpleNamespace(status_code=200, reason=\"OK\")\n&gt;&gt;&gt; with mock.patch(\"requests.get\", return_value=response):\n...     api = API(api_root=\"https://example\", token=\"test\")\n...     resp = api.send_request(\"/projects\", {})\n&gt;&gt;&gt; resp is response\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def send_request(\n    self,\n    url_data_type: str,\n    url_params: Mapping[str, Union[str, float, int, Sequence[Union[str, float, int]], None]],\n) -&gt; requests.Response:\n    \"\"\"\n    Handle sending appropriate request.\n\n    Handles sending appropriate request according to the type of\n    authentication.\n\n    Parameters\n    ----------\n    url_data_type : str\n        Type of the data we want to request (according to database\n        model).\n    url_params : Mapping\n        Parameters to send with the request to the database.\n\n    Returns\n    -------\n    requests.Response\n        An instance of the Response object.\n\n    Raises\n    ------\n    InvalidParameterError\n        If neither header nor username and password are defined.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; response = SimpleNamespace(status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; with mock.patch(\"requests.get\", return_value=response):\n    ...     api = API(api_root=\"https://example\", token=\"test\")\n    ...     resp = api.send_request(\"/projects\", {})\n    &gt;&gt;&gt; resp is response\n    True\n    \"\"\"\n    if self.header is not None:\n        response = requests.get(\n            url=self.api_root + url_data_type,\n            headers=self.header,\n            params=url_params,\n        )\n    else:\n        if self.uname is None or self.password is None:\n            e = \"Either self.header or self.uname and self.password must be defined.\"\n            raise InvalidParameterError(e)\n        else:\n            response = requests.get(\n                url=self.api_root + url_data_type,\n                auth=self.auth,\n                params=url_params,\n            )\n    return response\n</code></pre> check_request_health <code>staticmethod</code> \u00b6 <pre><code>check_request_health(resp)\n</code></pre> <p>Check status code of the response and provide details.</p> <p>Checks status code of the response to request and provides details if unexpected.</p> <p>Parameters:</p> Name Type Description Default <code>resp</code> <code>Response</code> <p>Instance of the Response object.</p> required <p>Raises:</p> Type Description <code>APIConnectionError</code> <p>If response status code is not 200.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; ok = SimpleNamespace(status_code=200, reason=\"OK\")\n&gt;&gt;&gt; API.check_request_health(ok)\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef check_request_health(resp: requests.Response) -&gt; None:\n    \"\"\"\n    Check status code of the response and provide details.\n\n    Checks status code of the response to request and provides\n    details if unexpected.\n\n    Parameters\n    ----------\n    resp : requests.Response\n        Instance of the Response object.\n\n    Raises\n    ------\n    APIConnectionError\n        If response status code is not 200.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; ok = SimpleNamespace(status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; API.check_request_health(ok)\n    \"\"\"\n    if resp.status_code != 200:\n        raise APIConnectionError(\n            message=f\"Error {resp.status_code}.\\n{resp.reason}\",\n            response=resp,\n        )\n</code></pre> output_to_df <code>staticmethod</code> \u00b6 <pre><code>output_to_df(response)\n</code></pre> <p>Transform output to Pandas dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Raw output of the sent request.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Pandas dataframe of the data from the output.</p> <p>Raises:</p> Type Description <code>DataProcessingError</code> <p>If failed to decode JSON from API response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; resp = SimpleNamespace(text='[{\"a\": 1}]')\n&gt;&gt;&gt; int(API.output_to_df(resp)[\"a\"].iloc[0])\n1\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef output_to_df(response: requests.Response) -&gt; pd.DataFrame:\n    \"\"\"\n    Transform output to Pandas dataframe.\n\n    Parameters\n    ----------\n    response : requests.Response\n        Raw output of the sent request.\n\n    Returns\n    -------\n    pd.DataFrame\n        Pandas dataframe of the data from the output.\n\n    Raises\n    ------\n    DataProcessingError\n        If failed to decode JSON from API response.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; resp = SimpleNamespace(text='[{\"a\": 1}]')\n    &gt;&gt;&gt; int(API.output_to_df(resp)[\"a\"].iloc[0])\n    1\n    \"\"\"\n    try:\n        data = json.loads(response.text)\n    except Exception as err:\n        raise DataProcessingError(\"Failed to decode JSON from API response\") from err\n    return pd.DataFrame(data)\n</code></pre> postprocess_data <code>staticmethod</code> \u00b6 <pre><code>postprocess_data(df, output_type)\n</code></pre> <p>Process dataframe information to extract additional data.</p> <p>Processes dataframe information to extract the necessary additional data.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe of the output data.</p> required <code>output_type</code> <code>str</code> <p>Expected type (amount) of the data extracted.</p> required <p>Returns:</p> Type Description <code>PostprocessData</code> <p>Dictionary of the additional data extracted.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If more than one record was returned for 'single' output type, or if output type is not 'single' or 'list'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n&gt;&gt;&gt; int(API.postprocess_data(df, \"single\")[\"id\"])\n1\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef postprocess_data(df: pd.DataFrame, output_type: str) -&gt; PostprocessData:\n    \"\"\"\n    Process dataframe information to extract additional data.\n\n    Processes dataframe information to extract the necessary\n    additional data.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe of the output data.\n    output_type : str\n        Expected type (amount) of the data extracted.\n\n    Returns\n    -------\n    PostprocessData\n        Dictionary of the additional data extracted.\n\n    Raises\n    ------\n    InvalidParameterError\n        If more than one record was returned for 'single' output\n        type, or if output type is not 'single' or 'list'.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame({\"id\": [1]})\n    &gt;&gt;&gt; int(API.postprocess_data(df, \"single\")[\"id\"])\n    1\n    \"\"\"\n    if output_type == \"single\":\n        if df.__len__() == 0:\n            exists = False\n            project_id = None\n        elif df.__len__() == 1:\n            exists = True\n            project_id = df[\"id\"].iloc[0]\n        else:\n            raise InvalidParameterError(\"More than one project site was returned, check search criteria.\")\n        data_add: PostprocessData = {\n            \"existance\": exists,\n            \"id\": project_id,\n            \"response\": None,\n        }\n    elif output_type == \"list\":\n        exists = df.__len__() != 0\n        data_add: PostprocessData = {\n            \"existance\": exists,\n            \"id\": None,\n            \"response\": None,\n        }\n    else:\n        raise InvalidParameterError(\"Output type must be either 'single' or 'list', not \" + output_type + \".\")\n    return data_add\n</code></pre> validate_data <code>staticmethod</code> \u00b6 <pre><code>validate_data(df, data_type)\n</code></pre> <p>Validate the data extracted from the database.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Dataframe of the output data.</p> required <code>data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with corrected data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame()\n&gt;&gt;&gt; API.validate_data(df, \"subassemblies\").empty\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>@staticmethod\ndef validate_data(df: pd.DataFrame, data_type: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Validate the data extracted from the database.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Dataframe of the output data.\n    data_type : str\n        Type of the data we want to request (according to database\n        model).\n\n    Returns\n    -------\n    pd.DataFrame\n        Dataframe with corrected data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pd.DataFrame()\n    &gt;&gt;&gt; API.validate_data(df, \"subassemblies\").empty\n    True\n    \"\"\"\n    z_sa_mp = {\"min\": -100000, \"max\": -10000}\n    z_sa_tp = {\"min\": -20000, \"max\": -1000}\n    z_sa_tw = {\"min\": 1000, \"max\": 100000}\n    sa_type = [\"TW\", \"TP\", \"MP\"]\n    z = [z_sa_tw, z_sa_tp, z_sa_mp]\n    if data_type == \"subassemblies\":\n        if df.__len__() == 0:\n            return df\n        for i, sat in enumerate(sa_type):\n            cond_small_units = (df[\"subassembly_type\"] == sat) &amp; (df[\"z_position\"] &lt; z[i][\"min\"])\n            cond_big_units = (df[\"subassembly_type\"] == sat) &amp; (df[\"z_position\"] &gt; z[i][\"max\"])\n            if df[cond_small_units].__len__() &gt; 0:\n                df.loc[cond_small_units, \"z_position\"] = df.loc[cond_small_units, \"z_position\"] / 1e3\n                warnings.warn(\n                    f\"The value of z location for {df.loc[cond_small_units | cond_big_units, 'title'].values} \\\n                    might be wrong or in wrong units! There will be an attempt to correct the units.\",\n                    stacklevel=2,\n                )\n            if df[cond_big_units].__len__() &gt; 0:\n                df.loc[cond_big_units, \"z_position\"] = df.loc[cond_big_units, \"z_position\"] * 1e3\n                warnings.warn(\n                    f\"The value of z location for {df.loc[cond_small_units | cond_big_units, 'title'].values} \\\n                    might be wrong or in wrong units! There will be an attempt to correct the units.\",\n                    stacklevel=2,\n                )\n    return df\n</code></pre> process_data \u00b6 <pre><code>process_data(url_data_type, url_params, output_type)\n</code></pre> <p>Process output data according to specified request parameters.</p> <p>Parameters:</p> Name Type Description Default <code>url_data_type</code> <code>str</code> <p>Type of the data we want to request (according to database model).</p> required <code>url_params</code> <code>Mapping</code> <p>Parameters to send with the request to the database.</p> required <code>output_type</code> <code>str</code> <p>Expected type (amount) of the data extracted.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of dataframe with the requested data and additional data from postprocessing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from types import SimpleNamespace\n&gt;&gt;&gt; from unittest import mock\n&gt;&gt;&gt; response = SimpleNamespace(text=\"[]\", status_code=200, reason=\"OK\")\n&gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n&gt;&gt;&gt; with mock.patch.object(API, \"send_request\", return_value=response):\n...     df, info = api.process_data(\"projects\", {}, \"list\")\n&gt;&gt;&gt; df.empty\nTrue\n&gt;&gt;&gt; info[\"existance\"]\nFalse\n</code></pre> Source code in <code>src/owi/metadatabase/io.py</code> <pre><code>def process_data(\n    self,\n    url_data_type: str,\n    url_params: Mapping[str, Union[str, float, int, Sequence[Union[str, float, int]], None]],\n    output_type: str,\n) -&gt; tuple[pd.DataFrame, PostprocessData]:\n    \"\"\"\n    Process output data according to specified request parameters.\n\n    Parameters\n    ----------\n    url_data_type : str\n        Type of the data we want to request (according to database\n        model).\n    url_params : Mapping\n        Parameters to send with the request to the database.\n    output_type : str\n        Expected type (amount) of the data extracted.\n\n    Returns\n    -------\n    tuple\n        A tuple of dataframe with the requested data and\n        additional data from postprocessing.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from types import SimpleNamespace\n    &gt;&gt;&gt; from unittest import mock\n    &gt;&gt;&gt; response = SimpleNamespace(text=\"[]\", status_code=200, reason=\"OK\")\n    &gt;&gt;&gt; api = API(api_root=\"https://example\", token=\"test\")\n    &gt;&gt;&gt; with mock.patch.object(API, \"send_request\", return_value=response):\n    ...     df, info = api.process_data(\"projects\", {}, \"list\")\n    &gt;&gt;&gt; df.empty\n    True\n    &gt;&gt;&gt; info[\"existance\"]\n    False\n    \"\"\"\n    resp = self.send_request(url_data_type, url_params)\n    self.check_request_health(resp)\n    df = self.output_to_df(resp)\n    df = self.validate_data(df, url_data_type)\n    df_add = self.postprocess_data(df, output_type)\n    # Add the response object to the returned dictionary so tests can inspect it\n    df_add[\"response\"] = resp\n    return df, df_add\n</code></pre>"},{"location":"api/utils/","title":"Utilities","text":"<p>API reference for internal utilities.</p>"},{"location":"api/utils/#owi.metadatabase._utils","title":"_utils","text":"<p>Internal utilities for owi.metadatabase package.</p>"},{"location":"api/utils/#owi.metadatabase._utils-classes","title":"Classes","text":""},{"location":"api/utils/#owi.metadatabase._utils.APIConnectionError","title":"APIConnectionError","text":"<pre><code>APIConnectionError(message, response=None)\n</code></pre> <p>               Bases: <code>APIException</code></p> <p>Exception raised when the API cannot be reached or returns a failure.</p> <p>This exception is raised when there are network issues, server errors, or other connection-related problems during API communication.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error message.</p> required <code>response</code> <code>Response or None</code> <p>The HTTP response object if available, default is None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exc = APIConnectionError(\"Network timeout\")\n&gt;&gt;&gt; str(exc)\n'Network timeout'\n&gt;&gt;&gt; exc.message\n'Network timeout'\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/exceptions.py</code> <pre><code>def __init__(self, message: str, response: Optional[requests.Response] = None) -&gt; None:\n    self.response = response\n    super().__init__(message)\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.DataProcessingError","title":"DataProcessingError","text":"<pre><code>DataProcessingError(\n    message=\"Error during data processing.\",\n)\n</code></pre> <p>               Bases: <code>APIException</code></p> <p>Exception raised when there is a problem while processing the data.</p> <p>This exception indicates that data was retrieved successfully from the API but could not be processed, transformed, or validated correctly.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error message, default is \"Error during data processing.\"</p> <code>'Error during data processing.'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exc = DataProcessingError()\n&gt;&gt;&gt; str(exc)\n'Error during data processing.'\n</code></pre> <pre><code>&gt;&gt;&gt; exc = DataProcessingError(\"Cannot parse geometry coordinates\")\n&gt;&gt;&gt; str(exc)\n'Cannot parse geometry coordinates'\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/exceptions.py</code> <pre><code>def __init__(self, message: str = \"Error during data processing.\") -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.InvalidParameterError","title":"InvalidParameterError","text":"<pre><code>InvalidParameterError(\n    message=\"Invalid or missing parameters for the request.\",\n)\n</code></pre> <p>               Bases: <code>APIException</code></p> <p>Exception raised when query parameters are invalid or missing.</p> <p>This exception is raised before making API requests when the provided parameters fail validation checks or are inconsistent.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error message, default is \"Invalid or missing parameters for the request.\"</p> <code>'Invalid or missing parameters for the request.'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exc = InvalidParameterError()\n&gt;&gt;&gt; str(exc)\n'Invalid or missing parameters for the request.'\n</code></pre> <pre><code>&gt;&gt;&gt; exc = InvalidParameterError(\"Project name required\")\n&gt;&gt;&gt; str(exc)\n'Project name required'\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/exceptions.py</code> <pre><code>def __init__(self, message: str = \"Invalid or missing parameters for the request.\") -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils-functions","title":"Functions","text":""},{"location":"api/utils/#owi.metadatabase._utils.deepcompare","title":"deepcompare","text":"<pre><code>deepcompare(a, b, tol=1e-05)\n</code></pre> <p>Compare two complicated objects recursively.</p> <p>Compares two complicated (potentially nested) objects recursively and returns a result and a message.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Any</code> <p>First object to be compared.</p> required <code>b</code> <code>Any</code> <p>Second object to be compared.</p> required <code>tol</code> <code>float</code> <p>Tolerance for the comparison, default is 1e-5.</p> <code>1e-05</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple with a result of comparison and a message if different.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; deepcompare({\"a\": 1.0}, {\"a\": 1.0})[0]\nTrue\n&gt;&gt;&gt; deepcompare([1, 2], [1, 3])[0]\nFalse\n&gt;&gt;&gt; deepcompare(np.nan, np.nan)[0]\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/utils.py</code> <pre><code>def deepcompare(a: Any, b: Any, tol: float = 1e-5) -&gt; tuple[bool, None | str]:\n    \"\"\"\n    Compare two complicated objects recursively.\n\n    Compares two complicated (potentially nested) objects recursively\n    and returns a result and a message.\n\n    Parameters\n    ----------\n    a : Any\n        First object to be compared.\n    b : Any\n        Second object to be compared.\n    tol : float, optional\n        Tolerance for the comparison, default is 1e-5.\n\n    Returns\n    -------\n    tuple\n        Tuple with a result of comparison and a message if different.\n\n    Examples\n    --------\n    &gt;&gt;&gt; deepcompare({\"a\": 1.0}, {\"a\": 1.0})[0]\n    True\n    &gt;&gt;&gt; deepcompare([1, 2], [1, 3])[0]\n    False\n    &gt;&gt;&gt; deepcompare(np.nan, np.nan)[0]\n    True\n    \"\"\"\n    if type(a) != type(b):  # noqa: E721\n        if hasattr(a, \"__dict__\") and isinstance(b, dict):\n            return deepcompare(a.__dict__, b, tol)\n        elif hasattr(b, \"__dict__\") and isinstance(a, dict):\n            return deepcompare(a, b.__dict__, tol)\n        elif isinstance(a, (float, np.floating)) and isinstance(b, (float, np.floating)):\n            return deepcompare(np.float64(a), np.float64(b), tol)\n        return (\n            False,\n            f\"Types of {a} and {b} are different: {type(a).__name__} and {type(b).__name__}.\",\n        )\n    elif isinstance(a, dict):\n        if a.keys() != b.keys():\n            return (\n                False,\n                f\"Dictionary keys {a.keys()} and {b.keys()} are different.\",\n            )\n        compare = [deepcompare(a[key], b[key], tol)[0] for key in a]\n        assertion = all(compare)\n        if assertion:\n            message = None\n        else:\n            keys = [key for key, val in zip(a.keys(), compare) if val is False]\n            message = f\"Dictionary values are different for {a} and {b}, for keys: {keys}.\"\n        return assertion, message\n    elif isinstance(a, (list, tuple)):\n        if len(a) != len(b):\n            return (\n                False,\n                f\"Lists/tuples {a} and {b} are of different length: {len(a)} and {len(b)}.\",\n            )\n        compare = [deepcompare(i, j, tol)[0] for i, j in zip(a, b)]\n        assertion = all(compare)\n        if assertion:\n            message = None\n        else:\n            inds = [ind for ind, val in zip(range(len(compare)), compare) if val is False]\n            message = f\"Lists/tuples are different for {a} and {b}, for indices: {inds}.\"\n        return assertion, message\n    elif hasattr(a, \"__dict__\") and not isinstance(a, pd.DataFrame):\n        return deepcompare(a.__dict__, b.__dict__, tol)\n    elif isinstance(a, pd.DataFrame):\n        assertion = check_df_eq(a, b, tol)\n        message = None if assertion else f\"Dataframes {a} and {b} are different for {a.compare(b)}.\"\n        return assertion, message\n    else:\n        return compare_if_simple_close(a, b, tol)\n</code></pre>"},{"location":"api/utils/#exceptions","title":"Exceptions","text":""},{"location":"api/utils/#owi.metadatabase._utils.exceptions","title":"exceptions","text":"<p>Custom exceptions for the API client. These exceptions encapsulate common errors that can occur during API calls and data post-processing.</p>"},{"location":"api/utils/#owi.metadatabase._utils.exceptions-classes","title":"Classes","text":""},{"location":"api/utils/#owi.metadatabase._utils.exceptions.APIException","title":"APIException","text":"<pre><code>APIException(message)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base exception for all errors raised by API.</p> <p>This is the parent class for all custom exceptions in the package. It provides a consistent interface for error handling across API operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error message describing what went wrong.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; exc = APIException(\"Something went wrong\")\n&gt;&gt;&gt; str(exc)\n'Something went wrong'\n&gt;&gt;&gt; exc.message\n'Something went wrong'\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/exceptions.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.exceptions.APIConnectionError","title":"APIConnectionError","text":"<pre><code>APIConnectionError(message, response=None)\n</code></pre> <p>               Bases: <code>APIException</code></p> <p>Exception raised when the API cannot be reached or returns a failure.</p> <p>This exception is raised when there are network issues, server errors, or other connection-related problems during API communication.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error message.</p> required <code>response</code> <code>Response or None</code> <p>The HTTP response object if available, default is None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exc = APIConnectionError(\"Network timeout\")\n&gt;&gt;&gt; str(exc)\n'Network timeout'\n&gt;&gt;&gt; exc.message\n'Network timeout'\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/exceptions.py</code> <pre><code>def __init__(self, message: str, response: Optional[requests.Response] = None) -&gt; None:\n    self.response = response\n    super().__init__(message)\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.exceptions.DataNotFoundError","title":"DataNotFoundError","text":"<pre><code>DataNotFoundError(\n    message=\"No data found for the given search criteria.\",\n)\n</code></pre> <p>               Bases: <code>APIException</code></p> <p>Exception raised when no data is found for the given query parameters.</p> <p>This exception indicates that the API request was successful but returned no results matching the search criteria.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error message, default is \"No data found for the given search criteria.\"</p> <code>'No data found for the given search criteria.'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exc = DataNotFoundError()\n&gt;&gt;&gt; str(exc)\n'No data found for the given search criteria.'\n</code></pre> <pre><code>&gt;&gt;&gt; exc = DataNotFoundError(\"No turbine T99 in project\")\n&gt;&gt;&gt; str(exc)\n'No turbine T99 in project'\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/exceptions.py</code> <pre><code>def __init__(self, message: str = \"No data found for the given search criteria.\") -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.exceptions.DataProcessingError","title":"DataProcessingError","text":"<pre><code>DataProcessingError(\n    message=\"Error during data processing.\",\n)\n</code></pre> <p>               Bases: <code>APIException</code></p> <p>Exception raised when there is a problem while processing the data.</p> <p>This exception indicates that data was retrieved successfully from the API but could not be processed, transformed, or validated correctly.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error message, default is \"Error during data processing.\"</p> <code>'Error during data processing.'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exc = DataProcessingError()\n&gt;&gt;&gt; str(exc)\n'Error during data processing.'\n</code></pre> <pre><code>&gt;&gt;&gt; exc = DataProcessingError(\"Cannot parse geometry coordinates\")\n&gt;&gt;&gt; str(exc)\n'Cannot parse geometry coordinates'\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/exceptions.py</code> <pre><code>def __init__(self, message: str = \"Error during data processing.\") -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.exceptions.InvalidParameterError","title":"InvalidParameterError","text":"<pre><code>InvalidParameterError(\n    message=\"Invalid or missing parameters for the request.\",\n)\n</code></pre> <p>               Bases: <code>APIException</code></p> <p>Exception raised when query parameters are invalid or missing.</p> <p>This exception is raised before making API requests when the provided parameters fail validation checks or are inconsistent.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error message, default is \"Invalid or missing parameters for the request.\"</p> <code>'Invalid or missing parameters for the request.'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exc = InvalidParameterError()\n&gt;&gt;&gt; str(exc)\n'Invalid or missing parameters for the request.'\n</code></pre> <pre><code>&gt;&gt;&gt; exc = InvalidParameterError(\"Project name required\")\n&gt;&gt;&gt; str(exc)\n'Project name required'\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/exceptions.py</code> <pre><code>def __init__(self, message: str = \"Invalid or missing parameters for the request.\") -&gt; None:\n    super().__init__(message)\n</code></pre>"},{"location":"api/utils/#helper-functions","title":"Helper Functions","text":""},{"location":"api/utils/#owi.metadatabase._utils.utils","title":"utils","text":"<p>Utility functions for the owimetadatabase_preprocessor package.</p>"},{"location":"api/utils/#owi.metadatabase._utils.utils-functions","title":"Functions","text":""},{"location":"api/utils/#owi.metadatabase._utils.utils.custom_formatwarning","title":"custom_formatwarning","text":"<pre><code>custom_formatwarning(\n    message, category, filename, lineno, line=None\n)\n</code></pre> <p>Return customized warning.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Warning message.</p> required <code>category</code> <code>type</code> <p>Warning category.</p> required <code>filename</code> <code>str</code> <p>Filename where warning occurred.</p> required <code>lineno</code> <code>int</code> <p>Line number where warning occurred.</p> required <code>line</code> <code>str</code> <p>Line text where warning occurred.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted warning string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(custom_formatwarning(\"warn\", UserWarning, \"file.py\", 10), end=\"\")\nUserWarning: warn\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/utils.py</code> <pre><code>def custom_formatwarning(message, category, filename, lineno, line=None):\n    \"\"\"\n    Return customized warning.\n\n    Parameters\n    ----------\n    message : str\n        Warning message.\n    category : type\n        Warning category.\n    filename : str\n        Filename where warning occurred.\n    lineno : int\n        Line number where warning occurred.\n    line : str, optional\n        Line text where warning occurred.\n\n    Returns\n    -------\n    str\n        Formatted warning string.\n\n    Examples\n    --------\n    &gt;&gt;&gt; print(custom_formatwarning(\"warn\", UserWarning, \"file.py\", 10), end=\"\")\n    UserWarning: warn\n    \"\"\"\n    return f\"{category.__name__}: {message}\\n\"\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.utils.dict_generator","title":"dict_generator","text":"<pre><code>dict_generator(dict_, keys_=None, method_='exclude')\n</code></pre> <p>Generate a dictionary with the specified keys.</p> <p>Parameters:</p> Name Type Description Default <code>dict_</code> <code>dict</code> <p>Dictionary to be filtered.</p> required <code>keys_</code> <code>Sequence of str</code> <p>List of keys to be included or excluded.</p> <code>None</code> <code>method_</code> <code>str</code> <p>Method to be used for filtering. Options are \"exclude\" and \"include\", default is \"exclude\".</p> <code>'exclude'</code> <p>Returns:</p> Type Description <code>dict</code> <p>Filtered dictionary.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If method is not recognized.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dict_generator({\"a\": 1, \"b\": 2}, keys_=[\"a\"])\n{'b': 2}\n&gt;&gt;&gt; dict_generator({\"a\": 1, \"b\": 2}, keys_=[\"a\"], method_=\"include\")\n{'a': 1}\n&gt;&gt;&gt; dict_generator({\"a\": 1}, method_=\"unknown\")\nTraceback (most recent call last):\n    ...\nValueError: Method not recognized!\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/utils.py</code> <pre><code>def dict_generator(\n    dict_: dict[str, Any],\n    keys_: Sequence[str] | None = None,\n    method_: str = \"exclude\",\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Generate a dictionary with the specified keys.\n\n    Parameters\n    ----------\n    dict_ : dict\n        Dictionary to be filtered.\n    keys_ : Sequence of str, optional\n        List of keys to be included or excluded.\n    method_ : str, optional\n        Method to be used for filtering. Options are \"exclude\" and\n        \"include\", default is \"exclude\".\n\n    Returns\n    -------\n    dict\n        Filtered dictionary.\n\n    Raises\n    ------\n    ValueError\n        If method is not recognized.\n\n    Examples\n    --------\n    &gt;&gt;&gt; dict_generator({\"a\": 1, \"b\": 2}, keys_=[\"a\"])\n    {'b': 2}\n    &gt;&gt;&gt; dict_generator({\"a\": 1, \"b\": 2}, keys_=[\"a\"], method_=\"include\")\n    {'a': 1}\n    &gt;&gt;&gt; dict_generator({\"a\": 1}, method_=\"unknown\")  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n        ...\n    ValueError: Method not recognized!\n    \"\"\"\n    if keys_ is None:\n        keys_ = []\n    if method_ == \"exclude\":\n        return {k: dict_[k] for k in dict_ if k not in keys_}\n    elif method_ == \"include\":\n        return {k: dict_[k] for k in dict_ if k in keys_}\n    else:\n        raise ValueError(\"Method not recognized!\")\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.utils.compare_if_simple_close","title":"compare_if_simple_close","text":"<pre><code>compare_if_simple_close(a, b, tol=1e-09)\n</code></pre> <p>Compare two values and return a boolean and a message.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Any</code> <p>First value to be compared.</p> required <code>b</code> <code>Any</code> <p>Second value to be compared.</p> required <code>tol</code> <code>float</code> <p>Tolerance for the comparison, default is 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple with a result of comparison and a message if different.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; compare_if_simple_close(1.0, 1.0)\n(True, None)\n&gt;&gt;&gt; compare_if_simple_close(1.0, 2.0)\n(False, 'Values of 1.0 and 2.0 are different.')\n&gt;&gt;&gt; compare_if_simple_close(np.nan, np.nan)\n(True, None)\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/utils.py</code> <pre><code>def compare_if_simple_close(a: Any, b: Any, tol: float = 1e-9) -&gt; tuple[bool, None | str]:\n    \"\"\"\n    Compare two values and return a boolean and a message.\n\n    Parameters\n    ----------\n    a : Any\n        First value to be compared.\n    b : Any\n        Second value to be compared.\n    tol : float, optional\n        Tolerance for the comparison, default is 1e-9.\n\n    Returns\n    -------\n    tuple\n        Tuple with a result of comparison and a message if different.\n\n    Examples\n    --------\n    &gt;&gt;&gt; compare_if_simple_close(1.0, 1.0)\n    (True, None)\n    &gt;&gt;&gt; compare_if_simple_close(1.0, 2.0)\n    (False, 'Values of 1.0 and 2.0 are different.')\n    &gt;&gt;&gt; compare_if_simple_close(np.nan, np.nan)\n    (True, None)\n    \"\"\"\n    if isinstance(a, (float, np.floating)) and isinstance(b, (float, np.floating)):\n        if np.isnan(a) and np.isnan(b):\n            return True, None\n        assertion = math.isclose(a, b, rel_tol=tol)\n        messsage = None if assertion else f\"Values of {a} and {b} are different.\"\n        return assertion, messsage\n    assertion = a == b\n    messsage = None if assertion else f\"Values of {a} and {b} are different.\"\n    return assertion, messsage\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.utils.check_df_eq","title":"check_df_eq","text":"<pre><code>check_df_eq(df1, df2, tol=1e-09)\n</code></pre> <p>Check if two dataframes are equal.</p> <p>Parameters:</p> Name Type Description Default <code>df1</code> <code>DataFrame</code> <p>First dataframe to be compared.</p> required <code>df2</code> <code>DataFrame</code> <p>Second dataframe to be compared.</p> required <code>tol</code> <code>float</code> <p>Tolerance for the comparison, default is 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean indicating if the dataframes are equal.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df1 = pd.DataFrame({\"a\": [1.0, 2.0], \"b\": [\"x\", \"y\"]})\n&gt;&gt;&gt; df2 = pd.DataFrame({\"a\": [1.0, 2.0], \"b\": [\"x\", \"y\"]})\n&gt;&gt;&gt; check_df_eq(df1, df2)\nTrue\n&gt;&gt;&gt; check_df_eq(pd.DataFrame(), pd.DataFrame())\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/utils.py</code> <pre><code>def check_df_eq(df1: pd.DataFrame, df2: pd.DataFrame, tol: float = 1e-9) -&gt; bool:\n    \"\"\"\n    Check if two dataframes are equal.\n\n    Parameters\n    ----------\n    df1 : pd.DataFrame\n        First dataframe to be compared.\n    df2 : pd.DataFrame\n        Second dataframe to be compared.\n    tol : float, optional\n        Tolerance for the comparison, default is 1e-9.\n\n    Returns\n    -------\n    bool\n        Boolean indicating if the dataframes are equal.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df1 = pd.DataFrame({\"a\": [1.0, 2.0], \"b\": [\"x\", \"y\"]})\n    &gt;&gt;&gt; df2 = pd.DataFrame({\"a\": [1.0, 2.0], \"b\": [\"x\", \"y\"]})\n    &gt;&gt;&gt; check_df_eq(df1, df2)\n    True\n    &gt;&gt;&gt; check_df_eq(pd.DataFrame(), pd.DataFrame())\n    True\n    \"\"\"\n    if df1.empty and df2.empty:\n        return True\n    elif (df1.empty and not df2.empty) or (not df1.empty and df2.empty):\n        return False\n    if df1.shape != df2.shape:\n        return False\n    num_cols_eq = np.allclose(\n        df1.select_dtypes(include=\"number\"),\n        df2.select_dtypes(include=\"number\"),\n        rtol=tol,\n        atol=tol,\n        equal_nan=True,\n    )\n    str_cols_eq = df1.select_dtypes(include=\"object\").equals(df2.select_dtypes(include=\"object\"))\n    return num_cols_eq and str_cols_eq\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.utils.deepcompare","title":"deepcompare","text":"<pre><code>deepcompare(a, b, tol=1e-05)\n</code></pre> <p>Compare two complicated objects recursively.</p> <p>Compares two complicated (potentially nested) objects recursively and returns a result and a message.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Any</code> <p>First object to be compared.</p> required <code>b</code> <code>Any</code> <p>Second object to be compared.</p> required <code>tol</code> <code>float</code> <p>Tolerance for the comparison, default is 1e-5.</p> <code>1e-05</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple with a result of comparison and a message if different.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; deepcompare({\"a\": 1.0}, {\"a\": 1.0})[0]\nTrue\n&gt;&gt;&gt; deepcompare([1, 2], [1, 3])[0]\nFalse\n&gt;&gt;&gt; deepcompare(np.nan, np.nan)[0]\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/utils.py</code> <pre><code>def deepcompare(a: Any, b: Any, tol: float = 1e-5) -&gt; tuple[bool, None | str]:\n    \"\"\"\n    Compare two complicated objects recursively.\n\n    Compares two complicated (potentially nested) objects recursively\n    and returns a result and a message.\n\n    Parameters\n    ----------\n    a : Any\n        First object to be compared.\n    b : Any\n        Second object to be compared.\n    tol : float, optional\n        Tolerance for the comparison, default is 1e-5.\n\n    Returns\n    -------\n    tuple\n        Tuple with a result of comparison and a message if different.\n\n    Examples\n    --------\n    &gt;&gt;&gt; deepcompare({\"a\": 1.0}, {\"a\": 1.0})[0]\n    True\n    &gt;&gt;&gt; deepcompare([1, 2], [1, 3])[0]\n    False\n    &gt;&gt;&gt; deepcompare(np.nan, np.nan)[0]\n    True\n    \"\"\"\n    if type(a) != type(b):  # noqa: E721\n        if hasattr(a, \"__dict__\") and isinstance(b, dict):\n            return deepcompare(a.__dict__, b, tol)\n        elif hasattr(b, \"__dict__\") and isinstance(a, dict):\n            return deepcompare(a, b.__dict__, tol)\n        elif isinstance(a, (float, np.floating)) and isinstance(b, (float, np.floating)):\n            return deepcompare(np.float64(a), np.float64(b), tol)\n        return (\n            False,\n            f\"Types of {a} and {b} are different: {type(a).__name__} and {type(b).__name__}.\",\n        )\n    elif isinstance(a, dict):\n        if a.keys() != b.keys():\n            return (\n                False,\n                f\"Dictionary keys {a.keys()} and {b.keys()} are different.\",\n            )\n        compare = [deepcompare(a[key], b[key], tol)[0] for key in a]\n        assertion = all(compare)\n        if assertion:\n            message = None\n        else:\n            keys = [key for key, val in zip(a.keys(), compare) if val is False]\n            message = f\"Dictionary values are different for {a} and {b}, for keys: {keys}.\"\n        return assertion, message\n    elif isinstance(a, (list, tuple)):\n        if len(a) != len(b):\n            return (\n                False,\n                f\"Lists/tuples {a} and {b} are of different length: {len(a)} and {len(b)}.\",\n            )\n        compare = [deepcompare(i, j, tol)[0] for i, j in zip(a, b)]\n        assertion = all(compare)\n        if assertion:\n            message = None\n        else:\n            inds = [ind for ind, val in zip(range(len(compare)), compare) if val is False]\n            message = f\"Lists/tuples are different for {a} and {b}, for indices: {inds}.\"\n        return assertion, message\n    elif hasattr(a, \"__dict__\") and not isinstance(a, pd.DataFrame):\n        return deepcompare(a.__dict__, b.__dict__, tol)\n    elif isinstance(a, pd.DataFrame):\n        assertion = check_df_eq(a, b, tol)\n        message = None if assertion else f\"Dataframes {a} and {b} are different for {a.compare(b)}.\"\n        return assertion, message\n    else:\n        return compare_if_simple_close(a, b, tol)\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.utils.fix_nan","title":"fix_nan","text":"<pre><code>fix_nan(obj)\n</code></pre> <p>Replace \"nan\" strings with None.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Object to be fixed.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Fixed object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fixed = fix_nan({\"a\": \"NaN\", \"b\": [\"nan\", \"ok\"]})\n&gt;&gt;&gt; bool(np.isnan(fixed[\"a\"]))\nTrue\n&gt;&gt;&gt; bool(np.isnan(fixed[\"b\"][0]))\nTrue\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/utils.py</code> <pre><code>def fix_nan(obj: Any) -&gt; Any:\n    \"\"\"\n    Replace \"nan\" strings with None.\n\n    Parameters\n    ----------\n    obj : Any\n        Object to be fixed.\n\n    Returns\n    -------\n    Any\n        Fixed object.\n\n    Examples\n    --------\n    &gt;&gt;&gt; fixed = fix_nan({\"a\": \"NaN\", \"b\": [\"nan\", \"ok\"]})\n    &gt;&gt;&gt; bool(np.isnan(fixed[\"a\"]))\n    True\n    &gt;&gt;&gt; bool(np.isnan(fixed[\"b\"][0]))\n    True\n    \"\"\"\n    if isinstance(obj, dict):\n        for k, v in obj.items():\n            obj[k] = fix_nan(v)\n    elif isinstance(obj, list):\n        for i in range(len(obj)):\n            obj[i] = fix_nan(obj[i])\n    elif isinstance(obj, str) and obj.lower() == \"nan\":\n        # obj = None\n        obj = np.nan\n    return obj\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.utils.fix_outline","title":"fix_outline","text":"<pre><code>fix_outline(data)\n</code></pre> <p>Fix the outline attribute in the data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to be fixed.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Fixed data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data type is not supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fix_outline({\"outline\": [[0, 1], [2, 3]]})\n{'outline': ([0, 1], [2, 3])}\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/utils.py</code> <pre><code>def fix_outline(data: Any) -&gt; Any:\n    \"\"\"\n    Fix the outline attribute in the data.\n\n    Parameters\n    ----------\n    data : Any\n        Data to be fixed.\n\n    Returns\n    -------\n    Any\n        Fixed data.\n\n    Raises\n    ------\n    ValueError\n        If data type is not supported.\n\n    Examples\n    --------\n    &gt;&gt;&gt; fix_outline({\"outline\": [[0, 1], [2, 3]]})\n    {'outline': ([0, 1], [2, 3])}\n    \"\"\"\n    if isinstance(data, list):\n        for i in range(len(data)):\n            if \"outline\" in data[i] and data[i][\"outline\"] is not None:\n                data[i][\"outline\"] = tuple(data[i][\"outline\"])\n    elif isinstance(data, dict):\n        if \"outline\" in data and data[\"outline\"] is not None:\n            data[\"outline\"] = tuple(data[\"outline\"])\n    else:\n        raise ValueError(\"Not supported data type.\")\n    return data\n</code></pre>"},{"location":"api/utils/#owi.metadatabase._utils.utils.hex_to_dec","title":"hex_to_dec","text":"<pre><code>hex_to_dec(value: str) -&gt; list[float]\n</code></pre><pre><code>hex_to_dec(value: list[str]) -&gt; list[list[float]]\n</code></pre><pre><code>hex_to_dec(value: tuple[str, ...]) -&gt; list[list[float]]\n</code></pre> <pre><code>hex_to_dec(value)\n</code></pre> <p>Convert hex color(s) to normalized [r, g, b, a] floats.</p> <p>Accepts 6-digit (#rrggbb) or 8-digit (#rrggbbaa) hex strings, with or without leading '#'. - If <code>value</code> is a string: returns [r, g, b, a] - If <code>value</code> is a list of strings: returns [[r, g, b, a], ...]</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str or Sequence of str</code> <p>Hex color string or list of hex color strings.</p> required <p>Returns:</p> Type Description <code>list of float or list of list of float</code> <p>Normalized RGBA list or list of such lists.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the hex string length is not 6 or 8, or if the input type is not supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hex_to_dec(\"#ff0000\")\n[1.0, 0.0, 0.0, 1.0]\n&gt;&gt;&gt; hex_to_dec([\"#000000\", \"ffffff\"])\n[[0.0, 0.0, 0.0, 1.0], [1.0, 1.0, 1.0, 1.0]]\n</code></pre> Source code in <code>src/owi/metadatabase/_utils/utils.py</code> <pre><code>def hex_to_dec(value: str | Sequence[str]) -&gt; list[float] | list[list[float]]:\n    \"\"\"\n    Convert hex color(s) to normalized [r, g, b, a] floats.\n\n    Accepts 6-digit (#rrggbb) or 8-digit (#rrggbbaa) hex strings, with\n    or without leading '#'.\n    - If `value` is a string: returns [r, g, b, a]\n    - If `value` is a list of strings: returns [[r, g, b, a], ...]\n\n    Parameters\n    ----------\n    value : str or Sequence of str\n        Hex color string or list of hex color strings.\n\n    Returns\n    -------\n    list of float or list of list of float\n        Normalized RGBA list or list of such lists.\n\n    Raises\n    ------\n    ValueError\n        If the hex string length is not 6 or 8, or if the input type\n        is not supported.\n\n    Examples\n    --------\n    &gt;&gt;&gt; hex_to_dec(\"#ff0000\")\n    [1.0, 0.0, 0.0, 1.0]\n    &gt;&gt;&gt; hex_to_dec([\"#000000\", \"ffffff\"])\n    [[0.0, 0.0, 0.0, 1.0], [1.0, 1.0, 1.0, 1.0]]\n    \"\"\"\n\n    def _hex_to_dec(s: str) -&gt; list[float]:\n        s = s.lstrip(\"#\") if s.startswith(\"#\") else s\n        if len(s) not in (6, 8):\n            raise ValueError(\"Length of the color string must be 6 or 8 (excluding #)\")\n        r = int(s[0:2], 16) / 255.0\n        g = int(s[2:4], 16) / 255.0\n        b = int(s[4:6], 16) / 255.0\n        a = int(s[6:8], 16) / 255.0 if len(s) == 8 else 1.0\n        return [r, g, b, a]\n\n    if isinstance(value, str):\n        return _hex_to_dec(value)\n    elif isinstance(value, Sequence) and not isinstance(value, (str, bytes)):\n        return [_hex_to_dec(v) for v in value]\n    raise ValueError(\"Value must be a string or a list of strings.\")\n</code></pre>"},{"location":"development/contributing/","title":"Contributing","text":"<p>Thanks for contributing. This project uses uv and invoke for workflows.</p>"},{"location":"development/contributing/#setup","title":"Setup","text":"<pre><code>uv sync --dev\n</code></pre>"},{"location":"development/contributing/#quality-checks","title":"Quality Checks","text":"<pre><code>uv run invoke lint\nuv run invoke format\nuv run invoke test\n</code></pre>"},{"location":"development/contributing/#pull-requests","title":"Pull Requests","text":"<ul> <li>Keep changes focused and well scoped</li> <li>Add or update tests for behavior changes</li> <li>Update documentation when behavior changes</li> </ul>"},{"location":"development/doctest_guide/","title":"Doctest Style Guide","text":"<p>All public functions should include executable doctest examples.</p>"},{"location":"development/doctest_guide/#requirements","title":"Requirements","text":"<ul> <li>Include 2 to 3 examples per public function</li> <li>Cover basic usage and edge cases</li> <li>Use <code># doctest: +SKIP</code> for live API calls</li> <li>Prefer simple, deterministic output</li> </ul>"},{"location":"development/doctest_guide/#template","title":"Template","text":"<pre><code>def function_name(param1: int, param2: str) -&gt; bool:\n    \"\"\"\n    Short description.\n\n    Parameters\n    ----------\n    param1 : int\n        Description of param1.\n    param2 : str\n        Description of param2.\n\n    Returns\n    -------\n    bool\n        Description of return value.\n\n    Examples\n    --------\n    Basic usage:\n\n    &gt;&gt;&gt; function_name(1, \"ok\")\n    True\n\n    Edge case:\n\n    &gt;&gt;&gt; function_name(0, \"\")\n    False\n    \"\"\"\n</code></pre>"},{"location":"development/doctest_guide/#output-handling","title":"Output Handling","text":"<p>Use these doctest flags when needed:</p> <ul> <li><code>+ELLIPSIS</code> for long output</li> <li><code>+NORMALIZE_WHITESPACE</code> for whitespace differences</li> <li><code>+IGNORE_EXCEPTION_DETAIL</code> for platform-specific messages</li> </ul>"},{"location":"development/doctest_guide/#fixtures","title":"Fixtures","text":"<p>Common fixtures are injected into doctests via <code>tests/conftest.py</code>. Use them to avoid repeating large test data.</p>"},{"location":"development/documentation/","title":"Documentation","text":"<p>Documentation is built with MkDocs Material and mkdocstrings.</p>"},{"location":"development/documentation/#build","title":"Build","text":"<pre><code>uv run invoke docs.build\n</code></pre>"},{"location":"development/documentation/#serve-locally","title":"Serve Locally","text":"<pre><code>uv run invoke docs.serve\n</code></pre> <p>The server is available at http://localhost:8001/owi-metadatabase-sdk/.</p>"},{"location":"development/documentation/#api-docs","title":"API Docs","text":"<p>API pages are generated from NumPy-style docstrings.</p>"},{"location":"development/namespace_packages/","title":"Namespace Packages","text":"<p>This project uses a PEP 420 namespace package layout.</p>"},{"location":"development/namespace_packages/#key-points","title":"Key Points","text":"<ul> <li>The <code>owi</code> namespace is a native namespace package</li> <li>There is no <code>__init__.py</code> at the <code>owi/</code> root</li> <li>Extension packages can contribute additional modules</li> </ul>"},{"location":"development/namespace_packages/#import-pattern","title":"Import Pattern","text":"<pre><code>from owi.metadatabase.geometry.io import GeometryAPI\nfrom owi.metadatabase.locations.io import LocationsAPI\n</code></pre>"},{"location":"development/namespace_packages/#validation","title":"Validation","text":"<pre><code>import owi.metadatabase\nassert not hasattr(owi.metadatabase, \"__file__\")\n</code></pre>"},{"location":"development/release/","title":"Release Process","text":"<p>This page documents the release workflow for the SDK.</p>"},{"location":"development/release/#high-level-steps","title":"High Level Steps","text":"<ul> <li>Update version and changelog</li> <li>Run full test suite</li> <li>Build and verify documentation</li> <li>Create a release tag and publish artifacts</li> </ul>"},{"location":"development/release/#notes","title":"Notes","text":"<p>Release automation will be added in a later phase.</p>"},{"location":"development/testing/","title":"Testing","text":"<p>This project uses pytest for unit tests and doctest for docstring examples.</p>"},{"location":"development/testing/#run-tests","title":"Run Tests","text":"<pre><code>uv run pytest\n</code></pre>"},{"location":"development/testing/#run-doctests","title":"Run Doctests","text":"<pre><code>uv run pytest --doctest-modules src/\n</code></pre>"},{"location":"development/testing/#coverage","title":"Coverage","text":"<pre><code>uv run pytest --cov=src/owi/metadatabase --cov-report=term-missing\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or higher</li> <li>pip or uv package manager</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The recommended way to install the OWI Metadatabase SDK is via pip:</p> <pre><code>pip install owi-metadatabase\n</code></pre>"},{"location":"getting-started/installation/#using-uv-recommended-for-development","title":"Using uv (recommended for development)","text":"<p>If you're using uv, you can install with:</p> <pre><code>uv pip install owi-metadatabase\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>For development or to get the latest features:</p> <pre><code>git clone https://github.com/OWI-Lab/owi-metadatabase-sdk.git\ncd owi-metadatabase-sdk\nuv sync --dev\n</code></pre> <p>This will install the package in editable mode with all development dependencies.</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Check that the package is installed correctly:</p> <pre><code>import owi.metadatabase\nprint(owi.metadatabase.__version__)\n# Output: 0.1.0\n</code></pre> <p>Test basic imports:</p> <pre><code>from owi.metadatabase.geometry import GeometryAPI\nfrom owi.metadatabase.locations import LocationsAPI\n\nprint(\"\u2713 Installation successful!\")\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"getting-started/installation/#documentation","title":"Documentation","text":"<p>To build documentation locally:</p> <pre><code>pip install owi-metadatabase[docs]\n</code></pre> <p>Or with uv:</p> <pre><code>uv sync --group docs\n</code></pre>"},{"location":"getting-started/installation/#development","title":"Development","text":"<p>For contributing to the project:</p> <pre><code>pip install owi-metadatabase[dev]\n</code></pre> <p>Or with uv:</p> <pre><code>uv sync --dev\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#import-errors","title":"Import Errors","text":"<p>If you encounter import errors, ensure you're using the new import paths:</p> <pre><code># \u2717 Old (v0.10.x)\nfrom owimetadatabase_preprocessor.geometry import GeometryAPI\n\n# \u2713 New (v0.11.0+)\nfrom owi.metadatabase.geometry.io import GeometryAPI\n</code></pre>"},{"location":"getting-started/installation/#namespace-package-issues","title":"Namespace Package Issues","text":"<p>If you have issues with the namespace package structure, ensure you don't have any old installations:</p> <pre><code>pip uninstall owi-metadatabase-sdk owimetadatabase-preprocessor\npip install owi-metadatabase\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide</li> <li>Migration from v0.10.x</li> <li>User Guide</li> </ul>"},{"location":"getting-started/migration/","title":"Migration Guide: v0.10.x \u2192 v0.11.0","text":"<p>This guide helps you migrate from <code>owi-metadatabase-sdk</code> v0.10.x to v0.11.0.</p>"},{"location":"getting-started/migration/#breaking-changes","title":"\u26a0\ufe0f Breaking Changes","text":""},{"location":"getting-started/migration/#1-package-name-change","title":"1. Package Name Change","text":"<p>PyPI Package Name: - Old: <code>owi-metadatabase-sdk</code> - New: <code>owi-metadatabase</code></p> <p>Note: The GitHub repository name remains <code>owi-metadatabase-sdk</code>.</p>"},{"location":"getting-started/migration/#2-import-path-changes","title":"2. Import Path Changes","text":"<p>All import paths have changed to use the new namespace package structure:</p> <pre><code># \u274c Old (v0.10.x)\nfrom owimetadatabase_preprocessor.geometry import GeometryAPI\nfrom owimetadatabase_preprocessor.locations.io import LocationsAPI\nfrom owimetadatabase_preprocessor.geometry.processing import OWT\nfrom owimetadatabase_preprocessor.utility.exceptions import APIConnectionError\n\n# \u2705 New (v0.11.0+)\nfrom owi.metadatabase.geometry.io import GeometryAPI\nfrom owi.metadatabase.locations.io import LocationsAPI\nfrom owi.metadatabase.geometry.processing import OWT\nfrom owi.metadatabase._utils.exceptions import APIConnectionError\n</code></pre>"},{"location":"getting-started/migration/#3-removed-modules","title":"3. Removed Modules","text":"<p>The following modules have been removed from the core package and will be released as separate extension packages:</p> <ul> <li><code>fatigue</code> \u2192 <code>owi-metadatabase-fatigue</code> (coming soon)</li> <li><code>soil</code> \u2192 <code>owi-metadatabase-soil</code> (coming soon)</li> <li><code>results</code> \u2192 Functionality consolidated elsewhere</li> </ul>"},{"location":"getting-started/migration/#migration-steps","title":"Migration Steps","text":""},{"location":"getting-started/migration/#step-1-uninstall-old-package","title":"Step 1: Uninstall Old Package","text":"<pre><code>pip uninstall owi-metadatabase-sdk\n</code></pre>"},{"location":"getting-started/migration/#step-2-install-new-package","title":"Step 2: Install New Package","text":"<pre><code>pip install owi-metadatabase\n</code></pre>"},{"location":"getting-started/migration/#step-3-update-imports","title":"Step 3: Update Imports","text":"<p>Use find-and-replace in your codebase:</p> Old Import New Import <code>owimetadatabase_preprocessor.geometry</code> <code>owi.metadatabase.geometry</code> <code>owimetadatabase_preprocessor.locations</code> <code>owi.metadatabase.locations</code> <code>owimetadatabase_preprocessor.utility</code> <code>owi.metadatabase._utils</code> <code>owimetadatabase_preprocessor.io</code> <code>owi.metadatabase.io</code>"},{"location":"getting-started/migration/#step-4-update-api-imports","title":"Step 4: Update API Imports","text":"<pre><code># Old\nfrom owimetadatabase_preprocessor.geometry.io import GeometryAPI\nfrom owimetadatabase_preprocessor.locations.io import LocationsAPI\n\n# New\nfrom owi.metadatabase.geometry.io import GeometryAPI\nfrom owi.metadatabase.locations.io import LocationsAPI\n</code></pre>"},{"location":"getting-started/migration/#step-5-update-utility-imports","title":"Step 5: Update Utility Imports","text":"<pre><code># Old\nfrom owimetadatabase_preprocessor.utility.exceptions import (\n    APIConnectionError,\n    DataProcessingError\n)\nfrom owimetadatabase_preprocessor.utility.utils import deepcompare\n\n# New\nfrom owi.metadatabase._utils.exceptions import (\n    APIConnectionError,\n    DataProcessingError\n)\nfrom owi.metadatabase._utils.utils import deepcompare\n</code></pre>"},{"location":"getting-started/migration/#automated-migration-script","title":"Automated Migration Script","text":"<p>Here's a Python script to help automate the migration:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nAutomated migration script for owi-metadatabase v0.11.0\n\"\"\"\nfrom pathlib import Path\nimport re\n\ndef migrate_file(filepath: Path) -&gt; int:\n    \"\"\"Migrate a single Python file.\"\"\"\n    content = filepath.read_text()\n    original = content\n\n    # Replace import paths\n    replacements = {\n        'owimetadatabase_preprocessor.geometry': 'owi.metadatabase.geometry',\n        'owimetadatabase_preprocessor.locations': 'owi.metadatabase.locations',\n        'owimetadatabase_preprocessor.utility': 'owi.metadatabase._utils',\n        'owimetadatabase_preprocessor.io': 'owi.metadatabase.io',\n        'owimetadatabase_preprocessor': 'owi.metadatabase',\n    }\n\n    for old, new in replacements.items():\n        content = content.replace(old, new)\n\n    if content != original:\n        filepath.write_text(content)\n        return 1\n    return 0\n\ndef migrate_project(project_dir: Path) -&gt; None:\n    \"\"\"Migrate all Python files in a project.\"\"\"\n    count = 0\n    for filepath in project_dir.rglob('*.py'):\n        count += migrate_file(filepath)\n    print(f\"\u2713 Migrated {count} files\")\n\nif __name__ == '__main__':\n    import sys\n    project_dir = Path(sys.argv[1] if len(sys.argv) &gt; 1 else '.')\n    migrate_project(project_dir)\n</code></pre> <p>Save this as <code>migrate.py</code> and run:</p> <pre><code>python migrate.py /path/to/your/project\n</code></pre>"},{"location":"getting-started/migration/#testing-your-migration","title":"Testing Your Migration","text":"<p>After migration, run your tests:</p> <pre><code>pytest\n</code></pre> <p>Verify imports work:</p> <pre><code>import owi.metadatabase\nfrom owi.metadatabase.geometry.io import GeometryAPI\nfrom owi.metadatabase.locations.io import LocationsAPI\n\nprint(f\"\u2713 Migration successful! Version: {owi.metadatabase.__version__}\")\n</code></pre>"},{"location":"getting-started/migration/#key-changes-summary","title":"Key Changes Summary","text":"Aspect v0.10.x v0.11.0 PyPI Package <code>owi-metadatabase-sdk</code> <code>owi-metadatabase</code> Import Root <code>owimetadatabase_preprocessor</code> <code>owi.metadatabase</code> Package Type Regular package PEP 420 namespace package Fatigue Module Included Separate package (future) Soil Module Included Separate package (future) Line Length 127 characters 120 characters Docstring Style PEP 257 NumPy Documentation Sphinx MkDocs Material"},{"location":"getting-started/migration/#benefits-of-v0110","title":"Benefits of v0.11.0","text":"<ul> <li>\u2728 Namespace package architecture - Modular, extensible design</li> <li>\ud83d\udce6 Cleaner dependencies - Core package has fewer dependencies</li> <li>\ud83d\udcdd Better documentation - NumPy-style docstrings with extensive doctests</li> <li>\ud83c\udfa8 Modern tooling - Built with uv, ruff, and invoke</li> <li>\ud83e\uddea Enhanced testing - Comprehensive doctest coverage</li> <li>\ud83d\udcd6 MkDocs documentation - Beautiful, searchable documentation</li> </ul>"},{"location":"getting-started/migration/#need-help","title":"Need Help?","text":"<ul> <li>GitHub Issues - Report bugs or issues</li> <li>GitHub Discussions - Ask questions</li> <li>Documentation - Full documentation</li> </ul>"},{"location":"getting-started/migration/#extension-packages-coming-soon","title":"Extension Packages (Coming Soon)","text":"<p>Once available, you'll be able to install extension packages:</p> <pre><code># Core package (available now)\npip install owi-metadatabase\n\n# Extension packages (coming soon)\npip install owi-metadatabase-fatigue\npip install owi-metadatabase-soil\n</code></pre> <p>All packages will work together seamlessly through the namespace package mechanism:</p> <pre><code>from owi.metadatabase.geometry import GeometryAPI\nfrom owi.metadatabase.fatigue import FatigueAPI  # Future\nfrom owi.metadatabase.soil import SoilAPI        # Future\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will help you get started with the OWI Metadatabase SDK in just a few minutes.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>OWI Metadatabase API token (contact OWI-Lab for access)</li> <li>Python 3.9 or higher installed</li> <li>Package installed (see Installation)</li> </ul>"},{"location":"getting-started/quickstart/#basic-workflow","title":"Basic Workflow","text":""},{"location":"getting-started/quickstart/#1-import-the-required-modules","title":"1. Import the Required Modules","text":"<pre><code>from owi.metadatabase.geometry.io import GeometryAPI\nfrom owi.metadatabase.locations.io import LocationsAPI\n</code></pre>"},{"location":"getting-started/quickstart/#2-initialize-api-clients","title":"2. Initialize API Clients","text":"<pre><code># Using token authentication\nTOKEN = \"your-api-token-here\"\n\ngeometry_api = GeometryAPI(token=TOKEN)\nlocations_api = LocationsAPI(token=TOKEN)\n</code></pre>"},{"location":"getting-started/quickstart/#3-retrieve-location-data","title":"3. Retrieve Location Data","text":"<pre><code># Get all turbine locations for a project\nlocations = locations_api.get_locations(\n    projectsite=\"YourProjectName\"\n)\n\nprint(f\"Found {len(locations)} turbines\")\nprint(locations.head())\n</code></pre>"},{"location":"getting-started/quickstart/#4-retrieve-geometry-data","title":"4. Retrieve Geometry Data","text":"<pre><code># Get geometry data for specific turbines\nturbines = [\"TURB01\", \"TURB02\", \"TURB03\"]\n\nfor turbine in turbines:\n    geometry = geometry_api.get_turbine_geometry(\n        assetlocation=turbine,\n        projectsite=\"YourProjectName\"\n    )\n    print(f\"Turbine: {turbine}\")\n    print(f\"  Hub height: {geometry['hub_height']} m\")\n    print(f\"  Tower base: {geometry['tower_base']} mLAT\")\n</code></pre>"},{"location":"getting-started/quickstart/#5-process-geometry","title":"5. Process Geometry","text":"<pre><code>from owi.metadatabase.geometry.processing import OWT\n\n# Create OWT object for detailed processing\nowt = OWT(\n    turbine=\"TURB01\",\n    projectsite=\"YourProjectName\",\n    api=geometry_api\n)\n\n# Process structure\nowt.process_structure()\n\n# Access processed data\nprint(owt.tower.head())         # Tower geometry\nprint(owt.monopile.head())      # Monopile geometry\nprint(owt.rna)                  # RNA (Rotor-Nacelle-Assembly) data\n</code></pre>"},{"location":"getting-started/quickstart/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates the workflow:</p> <pre><code>from owi.metadatabase.geometry.io import GeometryAPI\nfrom owi.metadatabase.locations.io import LocationsAPI\nfrom owi.metadatabase.geometry.processing import OWT\n\n# Configuration\nTOKEN = \"your-api-token\"\nPROJECT = \"YourProjectName\"\nTURBINE = \"TURB01\"\n\n# Initialize APIs\ngeo_api = GeometryAPI(token=TOKEN)\nloc_api = LocationsAPI(token=TOKEN)\n\n# Get locations\nlocations = loc_api.get_locations(projectsite=PROJECT)\nprint(f\"Project has {len(locations)} turbines\")\n\n# Get and process geometry for one turbine\nowt = OWT(\n    turbine=TURBINE,\n    projectsite=PROJECT,\n    api=geo_api\n)\n\nowt.process_structure()\n\n# Display results\nprint(f\"\\n{TURBINE} Geometry Summary:\")\nprint(f\"  Tower segments: {len(owt.tower)}\")\nprint(f\"  Monopile segments: {len(owt.monopile)}\")\nprint(f\"  RNA mass: {owt.rna['Mass [t]'].sum():.2f} tonnes\")\n</code></pre>"},{"location":"getting-started/quickstart/#working-with-multiple-turbines","title":"Working with Multiple Turbines","text":"<p>Process multiple turbines efficiently:</p> <pre><code>from owi.metadatabase.geometry.processing import OWTs\n\n# Get locations first\nlocations = loc_api.get_locations(projectsite=PROJECT)\nturbine_list = locations['title'].tolist()\n\n# Process all turbines\nowts = OWTs(\n    turbines=turbine_list,\n    api=geo_api,\n    projectsite=PROJECT\n)\n\nowts.process_structures()\n\n# Access aggregated data\nprint(owts.all_turbines)  # Summary of all turbines\nprint(owts.tower)          # All tower data concatenated\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>User Guide - Detailed documentation</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#authentication","title":"Authentication","text":"<pre><code># Token authentication (recommended)\napi = GeometryAPI(token=\"your-token\")\n\n# Username/password authentication\napi = GeometryAPI(uname=\"username\", password=\"password\")\n</code></pre>"},{"location":"getting-started/quickstart/#error-handling","title":"Error Handling","text":"<pre><code>from owi.metadatabase._utils.exceptions import (\n    APIConnectionError,\n    DataProcessingError\n)\n\ntry:\n    data = geometry_api.get_turbine_geometry(\n        assetlocation=\"TURB01\",\n        projectsite=\"Project\"\n    )\nexcept APIConnectionError as e:\n    print(f\"Connection failed: {e}\")\nexcept DataProcessingError as e:\n    print(f\"Data processing error: {e}\")\n</code></pre>"},{"location":"getting-started/quickstart/#filtering-data","title":"Filtering Data","text":"<pre><code># Django-style filtering\nlocations = loc_api.get_locations(\n    projectsite=\"Project\",\n    title__icontains=\"A01\"  # Turbines containing \"A01\"\n)\n</code></pre>"},{"location":"user-guide/authentication/","title":"API Authentication","text":"<p>The SDK supports API key authentication via the <code>API_key</code> argument.</p>"},{"location":"user-guide/authentication/#basic-usage","title":"Basic Usage","text":"<ul> <li>Pass <code>API_key</code> when creating an API client</li> <li>Store the key securely in your environment or secrets manager</li> </ul>"},{"location":"user-guide/authentication/#example","title":"Example","text":"<p>Initialize a client with an API key:</p> <pre><code>from owi.metadatabase.geometry.io import GeometryAPI\n\napi = GeometryAPI(API_key=\"your-api-key\")\n</code></pre>"},{"location":"user-guide/authentication/#notes","title":"Notes","text":"<ul> <li>Do not hardcode real keys in source control</li> <li>Use <code># doctest: +SKIP</code> for examples that require live API access</li> </ul>"},{"location":"user-guide/geometry/","title":"Geometry Module","text":"<p>The geometry module provides API clients and processing utilities for offshore wind turbine geometry data.</p>"},{"location":"user-guide/geometry/#scope","title":"Scope","text":"<ul> <li>Retrieve geometry data from the metadatabase API</li> <li>Transform raw API data into structured objects</li> <li>Assemble turbine components into coherent structures</li> </ul>"},{"location":"user-guide/geometry/#key-api-entries","title":"Key API Entries","text":"<ul> <li>Geometry API client: <code>GeometryAPI</code></li> <li>Processing helpers: <code>OWT</code>, <code>OWTs</code></li> <li>Data structures: <code>Material</code>, <code>BuildingBlock</code>, <code>SubAssembly</code></li> </ul>"},{"location":"user-guide/geometry/#see-also","title":"See Also","text":"<ul> <li>API reference: api/geometry.md</li> <li>Processing details: api/geometry/processing.md</li> <li>Structures reference: api/geometry/structures.md</li> </ul>"},{"location":"user-guide/locations/","title":"Locations Module","text":"<p>The locations module provides access to project sites and asset locations for metadatabase projects.</p>"},{"location":"user-guide/locations/#scope","title":"Scope","text":"<ul> <li>Retrieve project site information</li> <li>Fetch asset location records</li> <li>Visualize asset locations on maps</li> </ul>"},{"location":"user-guide/locations/#key-api-entries","title":"Key API Entries","text":"<ul> <li>Locations API client: <code>LocationsAPI</code></li> </ul>"},{"location":"user-guide/locations/#see-also","title":"See Also","text":"<ul> <li>API reference: api/locations.md</li> <li>Locations I/O: api/locations/io.md</li> </ul>"},{"location":"user-guide/overview/","title":"User Guide","text":"<p>Welcome to the OWI Metadatabase SDK user guide. This guide provides comprehensive information on using the package to interact with the OWI Metadatabase API.</p>"},{"location":"user-guide/overview/#what-is-owi-metadatabase-sdk","title":"What is OWI Metadatabase SDK?","text":"<p>The OWI Metadatabase SDK is a Python package that simplifies interaction with the OWI Metadatabase, a centralized repository for offshore wind turbine data. The SDK handles:</p> <ul> <li>Geometry Data: Offshore wind turbine geometries, components, and structures</li> <li>Location Data: Geographic locations and site information</li> <li>API Authentication: Automatic token management and request handling</li> <li>Data Processing: Utilities for processing and transforming data</li> </ul>"},{"location":"user-guide/overview/#core-modules","title":"Core Modules","text":""},{"location":"user-guide/overview/#geometry-module","title":"Geometry Module","text":"<p>The <code>geometry</code> module provides access to offshore wind turbine geometries:</p> <pre><code>from owi.metadatabase.geometry.io import GeometryAPI\nfrom owi.metadatabase.geometry.processing import OWT, OWTs\n\n# Initialize API\ngeometry_api = GeometryAPI(API_key='your-api-key')\n\n# Fetch turbine geometry\nturbine = geometry_api.get_geometry_turbine(turbine_id)\n\n# Process geometry\nowt = OWT(turbine_data)\n</code></pre> <p>Key features:</p> <ul> <li>Retrieve turbine geometries, substructures and components</li> <li>Process and transform geometry data</li> <li>Work with building blocks, subassemblies, and complete structures</li> </ul>"},{"location":"user-guide/overview/#locations-module","title":"Locations Module","text":"<p>The <code>locations</code> module handles geographic location data:</p> <pre><code>from owi.metadatabase.locations.io import LocationsAPI\n\n# Initialize API\nlocations_api = LocationsAPI(API_key='your-api-key')\n\n# Get location information\nlocation = locations_api.get_location(location_id)\n</code></pre> <p>Key features:</p> <ul> <li>Retrieve location data for wind farms and sites</li> <li>Access geographic coordinates and metadata</li> <li>Query available locations</li> </ul>"},{"location":"user-guide/overview/#package-structure","title":"Package Structure","text":"<pre><code>owi.metadatabase/\n\u251c\u2500\u2500 geometry/          # Geometry data handling\n\u2502   \u251c\u2500\u2500 io.py         # GeometryAPI class\n\u2502   \u251c\u2500\u2500 processing.py # OWT, OWTs processing classes\n\u2502   \u2514\u2500\u2500 structures.py # Data structures\n\u251c\u2500\u2500 locations/         # Location data handling\n\u2502   \u2514\u2500\u2500 io.py         # LocationsAPI class\n\u2514\u2500\u2500 _utils/           # Internal utilities\n    \u251c\u2500\u2500 exceptions.py # Custom exceptions\n    \u2514\u2500\u2500 utils.py      # Utility functions\n</code></pre>"},{"location":"user-guide/overview/#authentication","title":"Authentication","text":"<p>All API clients require an API key for authentication:</p> <pre><code>from owi.metadatabase.geometry.io import GeometryAPI\n\n# Set API key directly\napi = GeometryAPI(API_key='your-api-key-here')\n\n# Or use environment variable\nimport os\nos.environ['OWI_API_KEY'] = 'your-api-key-here'\napi = GeometryAPI()\n</code></pre> <p>Store your API key securely, for example using environment variables.</p>"},{"location":"user-guide/overview/#error-handling","title":"Error Handling","text":"<p>The SDK provides custom exceptions for different error scenarios:</p> <pre><code>from owi.metadatabase._utils.exceptions import (\n    APIConnectionError,      # API connection failures\n    DataProcessingError,     # Data processing errors\n    InvalidParameterError,   # Invalid parameters\n)\n\ntry:\n    turbine = geometry_api.get_geometry_turbine(turbine_id)\nexcept APIConnectionError as e:\n    print(f\"Failed to connect: {e}\")\nexcept DataProcessingError as e:\n    print(f\"Failed to process data: {e}\")\n</code></pre>"},{"location":"user-guide/overview/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/overview/#1-fetching-turbine-geometry","title":"1. Fetching Turbine Geometry","text":"<pre><code>from owi.metadatabase.geometry.io import GeometryAPI\n\n# Initialize\napi = GeometryAPI(API_key='your-key')\n\n# Get turbine\nturbine = api.get_geometry_turbine(turbine_id=123)\n\n# Access components\nprint(turbine['name'])\nprint(turbine['components'])\n</code></pre>"},{"location":"user-guide/overview/#2-processing-multiple-turbines","title":"2. Processing Multiple Turbines","text":"<pre><code>from owi.metadatabase.geometry.processing import OWTs\n\n# Process multiple turbines\nturbines_data = [...]  # List of turbine data\nowts = OWTs(turbines_data)\n\n# Perform calculations\nowts.calculate_properties()\nowts.export_processed_data()\n</code></pre>"},{"location":"user-guide/overview/#3-location-queries","title":"3. Location Queries","text":"<pre><code>from owi.metadatabase.locations.io import LocationsAPI\n\n# Initialize\napi = LocationsAPI(API_key='your-key')\n\n# Get locations\nlocations = api.get_all_locations()\n\n# Filter by criteria\noffshore_locations = [\n    loc for loc in locations\n    if loc['type'] == 'offshore'\n]\n</code></pre>"},{"location":"user-guide/overview/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Getting Started - Installation and quickstart guides</li> </ul>"},{"location":"user-guide/overview/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li>Cache API responses - Avoid redundant API calls by caching responses</li> <li>Use environment variables - Store API keys securely in environment variables</li> <li>Handle errors gracefully - Always wrap API calls in try-except blocks</li> <li>Validate inputs - Check parameters before making API requests</li> <li>Close connections - Properly close API connections when done</li> </ol>"},{"location":"user-guide/overview/#getting-help","title":"Getting Help","text":"<p>If you encounter issues or have questions:</p> <ul> <li>Check the API Reference for detailed documentation</li> <li>Report bugs on GitHub Issues</li> <li>Ask questions in GitHub Discussions</li> </ul>"}]}